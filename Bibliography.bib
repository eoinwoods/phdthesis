@inproceedings{kim2014-fullstackenergy,
abstract = {Modern demand for energy-efficient computation has spurred research$\backslash$nat all levels of the stack, from devices to microarchitecture, operating$\backslash$nsystems, compilers, and languages. Unfortunately, this breadth has$\backslash$nresulted in a disjointed space, with technologies at different levels$\backslash$nof the system stack rarely compared, let alone coordinated. Copyright$\backslash$n2014 ACM. This work begins to remedy the problem, conducting an experimental$\backslash$nsurvey of the present state of energy management across the stack.$\backslash$nFocusing on settings that are exposed to software, we measure the$\backslash$ntotal energy, average power, and execution time of 41 benchmark applications$\backslash$nin 220 configurations, across a total of 200,000 program executions.$\backslash$nSome of the more important findings of the survey include that effective$\backslash$nparallelization and compiler optimizations have the potential to$\backslash$nsave far more energy than Linux's frequency tuning algorithms; that$\backslash$ncertain non-complementary energy strategies can undercut each other's$\backslash$nsavings by half when combined; and that while the power impacts of$\backslash$nmost strategies remain constant across applications, the runtime$\backslash$nimpacts vary, resulting in inconsistent energy impacts.},
author = {Kambadur, Melanie and Kim, Martha A.},
booktitle = {Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages {\&} Applications - OOPSLA '14},
doi = {10.1145/2660193.2660196},
isbn = {9781450325851},
issn = {0362-1340},
pages = {329--344},
title = {{An experimental survey of energy management across the stack}},
year = {2014}
}
@article{mobius2014-powerest,
abstract = {The power consumption of presently available Internet servers and data centers is not proportional to the work they accomplish. The scientific community is attempting to address this problem in a number of ways, for example, employing dynamic voltage and frequency scaling, selectively switching off idle or underutilized servers, and employing energy-aware task scheduling. Central to these approaches is the accurate estimation of the power consumption of the various subsystems of a server, particularly, the processor. We distinguish between power consumption measurement techniques and power consumption estimation models. The techniques refer to the art of instrumenting a system to measure its actual power consumption whereas the estimation models deal with indirect evidences (such as information pertaining to the CPU utilization or events captured by hardware performance counters) to reason about the power consumption of a system under consideration. The paper provides a comprehensive survey of existing or proposed approaches to estimate the power consumption of single-core as well as multicore processors, virtual machines, and an entire server.},
author = {M{\"{o}}bius, Christoph and Dargie, Waltenegus and Schill, Alexander},
doi = {10.1109/TPDS.2013.183},
isbn = {1045-9219 VO - PP},
issn = {10459219},
journal = {IEEE Transactions on Parallel and Distributed Systems},
keywords = {Power consumption models,energy-efficiency,power consumption estimation,processor's power consumption,server's power consumption,virtual machine's power consumption},
number = {6},
pages = {1600--1614},
title = {{Power consumption estimation models for processors, virtual machines, and servers}},
volume = {25},
year = {2014}
}
@inproceedings{yuki2014-compilingenergy,
abstract = {As we move towards exa-scale computing, energy is becoming increasingly important, even in the high performance computing arena. However, the simple equation, Energy = Power {\$}{\$}$\backslash$times {\$}{\$} Time, suggests that optimizing for speed already optimizes for energy, under the assumption that Power is constant. When power is not constant, a strategy that achieves energy savings at the cost of slower execution is Dynamic Voltage and Frequency Scaling (DVFS). However, DVFS is currently applicable only to the processor, and the entire system has many other sources of power dissipation. We show that there is little to gain in compilers by trying to trade off speed for energy using DVFS. It is best to produce code that runs full-throttle, completing as quickly as possible, an approach called ``race to sleep.'' Our result is based on analyses of a high-level energy model that characterizes energy consumption, related to survey of power consumption trends of recent processors for both desktop and server, as well as Cray supercomputers.},
author = {Yuki, Tomofumi and Rajopadhye, Sanjay},
booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
doi = {10.1007/978-3-319-09967-5_10},
isbn = {9783319099668},
issn = {16113349},
pages = {169 -- 184},
title = {{Folklore confirmed: Compiling for speed = Compiling for energy}},
year = {2014}
}
@inproceedings{amsel2010-greentracker,
abstract = {The energy consumption of computers has become an important environmental issue. This paper describes the development of Green Tracker, a tool that estimates the energy consumption of software in order to help concerned users make informed decisions about the software they use. We present preliminary results gathered from this system's initial usage. Ultimately the information gathered from this tool will be used to raise awareness and help make the energy consumption of software a more central concern among software developers.},
author = {Amsel, Nadine and Tomlinson, Bill},
booktitle = {CHI '10 Extended Abstracts on Human Factors in Computing Systems},
doi = {10.1145/1753846.1753981},
isbn = {9781605589305},
keywords = {Software,green IT,green computing,sustainability},
pages = {3337--3342},
title = {{Green Tracker : A Tool for Estimating the Energy Consumption of Software}},
year = {2010}
}
@inproceedings{chen2014-automatedanalysis,
author = {Chen, Feifei and Grundy, John and Schneider, Jean-Guy and Yang, Yun and He, Qiang},
booktitle = {Proceedings of the 5th ACM/SPEC international conference on Performance engineering},
organization = {ACM},
pages = {39--50},
title = {{Automated analysis of performance and energy consumption for cloud applications}},
year = {2014}
}
@inproceedings{cordero2015-legacyenergy,
abstract = {Nowadays, software sustainability is growing in importance. Not only IT infrastructure is becoming greener, but also software. It is possible to find methods and methodologies intended to produce more sustainable software with lower power consumption. In spite the slow evolution of software engineering towards " Green software", there exist a huge amount of legacy systems still running in organizations. Is then necessary to develop such systems from scratch in order to make them more sustainable? Probably, the most logical and appropriate answer for this question is no, since existing software can be refactored in order to improve its green ability quality characteristic. As a first step towards power consumption improvement, the authors propose a tool to analyze legacy systems in order to detect parts of the system with higher energy consumption. Using the profiling technique, the proposed tool instrument legacy Java systems in order to keep track of its execution. This information, together with the energy consumption (logged by means a data logger hardware), enables the engineer to analyze legacy system consumption detecting energy peaks in the system (e.g. The PC). The analysis gives the engineer evidences about candidates to be refactored in order to reduce energy consumption.},
author = {Cordero, Victor and {De Guzm{\'{a}}n}, Ignacio Garc{\'{i}}a Rodr{\'{i}}guez and Piattini, Mario},
booktitle = {Proceedings - 2015 IEEE 10th International Conference on Global Software Engineering Workshops, ICGSEW 2015},
doi = {10.1109/ICGSEW.2015.15},
isbn = {9781479998746},
issn = {2329-6305},
keywords = {Energy consumption,Energy data logger,Profiling,Reverse engineering,Software energy consumption,Software sustainability},
pages = {35--43},
title = {{A first approach on legacy system energy consumption measurement}},
year = {2015}
}
@article{baumeister1997-narrativereviews,
abstract = {Narrative literature reviews serve a vital scientific function, but few resources help people learn to write them. As compared with empirical reports, literature reviews can tackle broader and more abstract questions, can engage in more post hoc theorizing without the danger of capitalizing on chance, can make a stronger case for a null-hypothesis conclusion, and can appreciate and use methodological diversity better. Also, literature reviews can draw any of 4 conclusions: The hypothesis is correct, it has not been conclusively established but is the currently best guess, it is false, or the evidence permits no conclusion. Common mistakes of authors of literature review manuscripts are described.},
author = {Baumeister, Roy F. and Leary, Mark R.},
doi = {10.1037/1089-2680.1.3.311},
isbn = {1089-2680},
issn = {10892680},
journal = {Review of General Psychology},
number = {3},
pages = {311--320},
pmid = {19674681},
title = {{Writing narrative literature reviews}},
volume = {1},
year = {1997}
}
@inproceedings{noureddine2014-energyutest,
abstract = {The development of energy-efficient software has become a key requirement for a large number of devices, from smart-phones to data centers. However, measuring accurately this consumption is a major challenge that state-of-the-art approaches have tried to tackle with a limited success. While monitoring applications' consumption offers a clear insight on where the energy is being spent, it does not help in understanding how the energy is consumed. In this paper, we therefore introduce JALENUNIT, a software framework that infers the energy consumption model of software libraries from execution traces. This model can then be used to diagnose application code for detecting energy bugs, understanding energy distribution, establishing energy profiles and classifications, and comparing software libraries against their energy consumption. Copyright 2014 ACM.},
author = {Noureddine, Adel and Rouvoy, Romain and Seinturier, Lionel},
booktitle = {Proceedings of the 29th Annual ACM Symposium on Applied Computing - SAC '14},
doi = {10.1145/2554850.2554932},
isbn = {9781450324694},
issn = {0928-8910},
pages = {1200--1205},
title = {{Unit testing of energy consumption of software libraries}},
year = {2014}
}
@book{gillham2000-questionnaire,
abstract = {"It is easy to construct a questionnaire. With a word-processor it is possible to design one in a single evening. But developing a questionnaire that yields genuinely worthwhile data is much harder than one might think - and useful research does require worth-while data." "Developing a Questionnaire provides a comprehensive guide to the successful design and implementation of questionnaires as a research method."--BOOK JACKET.},
author = {Gillham, Bill},
booktitle = {Real world research, 2nd Edition.},
doi = {10.1002/9780470024522.ch3},
isbn = {0826447953},
keywords = {Questionnaires Handbooks,etc.,manuals},
pages = {122},
pmid = {15426991},
publisher = {A and C Black},
title = {{Developing a questionnaire}},
year = {2008}
}
@article{noureddine2015-hotspots,
abstract = {Green IT has emerged as a discipline concerned with the optimiza- tion of software solutions with regards to their energy consumption. In this domain, most of the state-of-the-art solutions concentrate on coarse-grained approaches to monitor the energy consumption of a device or a process. In this paper, we report on a fine-grained runtime energy monitoring framework we developed to help developers to diagnose energy hotspots with a better accuracy.$\backslash$r$\backslash$nConcretely, our approach adopts a 2-layer architecture including OS-level and process-level energy monitoring. OS-level energy monitoring estimates the energy consumption of processes according to different hardware devices (CPU, network card). Process-level energy monitoring focuses on Java-based applications and builds on OS-level energy monitoring to provide an estimation of energy consumption at the granularity of classes and methods. We argue that this per-method analysis of energy consumption provides better insights to the application in order to identify potential energy hotspots. In particular, our preliminary validation demonstrates that we can monitor energy hotspots of Jetty web servers and monitor their variations under stress scenarios.},
author = {Noureddine, Adel and Rouvoy, Romain and Seinturier, Lionel},
doi = {10.1007/s10515-014-0171-1},
isbn = {0990212106},
issn = {15737535},
journal = {Automated Software Engineering},
keywords = {Energy consumption,Power model,Power monitoring},
number = {3},
pages = {291--332},
title = {{Monitoring energy hotspots in software: Energy profiling of software code}},
volume = {22},
year = {2015}
}
@article{kansal2008-energyprofiling,
abstract = {Significant opportunities for power optimization exist at application design stage and are not yet fully exploited by system and application designers. We describe the challenges developers face in optimizing software for energy efficiency by exploiting application-level knowledge. To address these challenges, we propose the development of automated tools that profile the energy usage of various resource components used by an application and guide the design choices accordingly. We use a preliminary version of a tool we have developed to demonstrate how automated energy profiling helps a developer choose between alternative designs in the energy-performance trade-off space.},
author = {Kansal, Aman and Zhao, Feng},
doi = {10.1145/1453175.1453180},
isbn = {1-59593-061-2},
issn = {01635999},
journal = {ACM SIGMETRICS Performance Evaluation Review},
number = {2},
pages = {26--31},
title = {{Fine-grained energy profiling for power-aware application design}},
volume = {36},
year = {2008}
}
@inproceedings{murwantara2014-webserviceenergy,
abstract = {Copyright 2014 ACM. Because of the economies of scale that Cloud provides, there is great interest in hosting web services on the Cloud. Web services are created from components such as Database Management Systems and HTTP servers. There is a wide variety of components that can be used to configure a web service. The choice of components influences the performance and energy consumption. Most current research in the web service technologies focuses on system performance, and only small number of researchers give attention to energy consumption. In this paper, we propose a method to select the web service configurations which reduce energy consumption. Our method has capabilities to manage feature configuration and predict energy consumption of web service systems. To validate, we developed a technique to measure energy consumption of several web service configurations running in a Virtualized environment. Our approach allows Cloud companies to provide choices of web service technology that consumes less energy.},
author = {Murwantara, I.M. and Bordbar, B. and Minku, L.L.},
booktitle = {ACM International Conference Proceeding Series},
doi = {10.1145/2684200.2684314},
isbn = {9781450330015},
keywords = {Energy aware,Machine learning,Software product line,Web system},
pages = {224--228},
title = {{Measuring energy consumption for web service product configuration}},
year = {2014}
}
@article{liu2015-webservicepower,
abstract = {Service-oriented computing (SOC) is a popular software paradigm that is widely employed in IT industry. SOC uses “services” as the unit of functionality of a software application. The massive wave of SOC applications involves considerable energy consumption of servers, which should not be ignored in large-scale computing environment. When a service requirement can be answered by several web services, the energy consumption for each service to reply to the service request may be different. When this happens, web service selection (WSS) is often required to choose appropriate services to maximize global energy efficiency of SOC applications. Accordingly, this paper proposes a Virtual Power Meter Supported Power Consumption Prediction method for WSS (VPMSPCP). VPMSPCP facilitates choosing appropriate services to minimize wasteful electrical energy from the overall environment of SOC applications. According to our empirical proof, there is a correlation between the power consumption of a service and the status of the server where this service resides. We take advantage of this discovery to develop VPMSPCP by combining a ridge regression model with a well-known web service power modeling method. There are mainly two steps to establish VPMSPCP. First, we develop a virtual power meter (VPM) for each server. VPM is used to estimate the average power of a server under a certain status. Second, we apply the VPM to develop VPMSPCP which estimates power consumption of a web service according to the current status of the corresponding servers. Experiments show that VPMSPCP performs well in improving energy saving in WSS.},
author = {Liu, Jin and Jiang, Jiaming and Cui, Xiaohui and Yang, Wei and Liu, Xiao},
doi = {10.1007/s00779-015-0887-3},
issn = {16174909},
journal = {Personal and Ubiquitous Computing},
keywords = {Power consumption prediction,QoS,Virtual power meter,Web service},
number = {7},
pages = {1063--1073},
title = {{Power consumption prediction of web services for energy-efficient service selection}},
volume = {19},
year = {2015}
}
@inproceedings{phung2017-agnosticpower,
abstract = {{\textcopyright} 2017 IEEE. Many servers use technologies such as virtualization or containerization to improve server utilization. These technologies pose challenges for power monitoring since it is not possible to directly measure the power use of an abstraction such as a virtual machine. Much work has been done in modeling the power use of CPUs, virtual machines and entire servers, however, there is a scarcity of work in building lightweight power monitoring middleware that can be deployed across a range of systems. In this paper, we present cWatts+ as a prototype lightweight software-based virtual power meter. Utilizing a simple but powerful application-Agnostic power model, it offers comparable performance to existing 'more complex and heavier-weight' power models. It uses a small number of widely available CPU event counters and the Performance Application Programming Interface Library to estimate power usage on a per-Thread basis. It has minimal overhead and is portable across a variety of systems. It can be used in containerized or virtualized environments. We evaluate the estimation performance of cWatts+ for a variety of real-world benchmarks that are relevant to large distributed systems. Also, we examine the importance of including CPU core temperature data in the power model. We demonstrate that our power model has an average error of less than 5{\%}. This result compares favorably with existing state-of-The-Art power models and is achieved using a relatively simple power model that exhibits minimal power consumption (overhead). Consequently, our power monitoring middleware is viable for use in real-world applications such as power estimation for energy-Aware scheduling.},
author = {Phung, James and Lee, Young Choon and Zomaya, Albert Y.},
booktitle = {Proceedings - 2017 17th IEEE/ACM International Symposium on Cluster, Cloud and Grid Computing, CCGRID 2017},
doi = {10.1109/CCGRID.2017.100},
isbn = {9781509066100},
keywords = {Cloud computing,Power estimation,Power meter,Power modeling,Power monitoring},
pages = {335--344},
title = {{Application-Agnostic Power Monitoring in Virtualized Environments}},
year = {2017}
}
@inproceedings{acar2016-beyondcpu,
abstract = {ICTs (Information and Communication Technologies) are responsible around 2{\%} of worldwide greenhouse gas emissions (Gartner, 2007). And according to the Intergovernmental Panel on Climate Change (IPPC) recent reports, CO2 emissions due to ICTs are increasing widely. For this reason, many works tried to propose various tools to estimate the energy consumption due to software in order to reduce carbon footprint. However, these studies, in the majority of cases, takes into account only the CPU and neglects all others components. Whereas, the trend towards high-density packaging and raised memory involve a great increased of power consumption caused by memory and maybe memory can become the largest power consumer in servers. In this paper, we model and then estimate the power consumed by CPU and memory due to the execution of a software. Thus, we perform several experiments in order to observe the behavior of each component. {\textcopyright} Copyright 2016 by SCITEPRESS - Science and Technology Publications, Lda. All rights reserved.},
author = {Acar, H and Alptekin, G I and Gelas, J.-P. and Ghodous, P},
booktitle = {SMARTGREENS 2016 - Proceedings of the 5th International Conference on Smart Cities and Green ICT Systems},
isbn = {9789897581847},
pages = {1--8},
title = {{Beyond CPU: Considering memory power consumption of software}},
year = {2016}
}
@techreport{cainc2016-ausdcenergy,
author = {{Current Analysis Inc}},
institution = {Current Analysis Inc},
pages = {10},
title = {{Delivering Energy Efficiency for Australian Data Centres}},
url = {http://info.metronode.com.au/rs/320-XKP-917/images/Energy Efficiency Data Centres Final.pdf},
year = {2016}
}
@inproceedings{singh2013-processenergyest,
author = {Singh, Vivek Kumar and Dutta, Kaushik and VanderMeer, Debra},
booktitle = {Green Computing and Communications (GreenCom), 2013 IEEE and Internet of Things (iThings/CPSCom), IEEE International Conference on and IEEE Cyber, Physical and Social Computing},
organization = {IEEE},
pages = {94--101},
title = {{Estimating the energy consumption of executing software processes}},
year = {2013}
}
@article{loken2010-scinet,
abstract = {SciNet, one of seven regional HPC consortia operating under the Compute Canada umbrella, runs Canada's first and third fastest computers (as of June 2010) in a state-of-the-art, highly energy-efficient datacentre with a Power Usage Effectiveness (PUE) design-point of 1.16. Power efficiency, computational "bang for the buck" and system capability for a handful of flagship science projects were important criteria in choosing the nature of the computers and the data centre itself. Here we outline some of the lessons learned in putting together the systems and the data centre that hosts Canada's fastest computer to date.},
author = {Loken, Chris and Gruner, Daniel and Groer, Leslie and Peltier, Richard and Bunn, Neil and Craig, Michael and Henriques, Teresa and Dempsey, Jillian and Yu, Ching Hsing and Chen, Joseph and Dursi, L. Jonathan and Chong, Jason and Northrup, Scott and Pinto, Jaime and Knecht, Neil and Zon, Ramses Van},
doi = {10.1088/1742-6596/256/1/012026},
issn = {17426596},
journal = {Journal of Physics: Conference Series},
number = {1},
pages = {1--35},
title = {{SciNet: Lessons learned from building a power-efficient top-20 system and data centre}},
volume = {256},
year = {2010}
}
@misc{ida2015-gdcip,
author = {iDA Singapore},
pages = {4},
publisher = {Infocomm Development Authority of Singapore},
title = {{Green Data Centre Innovation Programme}},
url = {https://www.imda.gov.sg/-/media/imda/files/inner/about-us/newsroom/media-releases/2015/0507{\_}gdcip/annexa.pdf?la=en},
year = {2015}
}
@techreport{greengrid2011-dcefficiency,
author = {{The Green Grid}},
institution = {The Green Grid},
pages = {14},
title = {{Recommendations for Measuring and Reporting Overall Data Centre Efficiency Version 2 - Measuring PUE for Data Centres}},
url = {https://www.thegreengrid.org/en/resources/library-and-tools/216},
year = {2011}
}
@techreport{techuk2013-dcpower,
author = {TechUK},
institution = {Information Technology Telecommunications And Electronics Association},
pages = {16},
title = {{Data Centres and Power: Fact or Fiction?}},
year = {2013}
}
@inproceedings{wieringa2012-tar,
abstract = {Current proposals for combining action research and design science start with a concrete problem in an organization, then apply an artifact to improve the problem, and finally reflect on lessons learned. The aim of these combinations is to reduce the tension between relevance and rigor. This paper proposes another way of using action research in design science, which starts with an artifact, and then tests it under conditions of practice by solving concrete problems with them. The aim of this way of using action research in design science is to bridge the gap between the idealizations made when designing the artifact and the concrete conditions of practice that occur in real-world problems. The paper analyzes the role of idealization in design science and compares it with the requirements of rigor and relevance. It then proposes a way of bridging the gap between idealization and practice by means of action research, called technical action research (TAR) in this paper. The core of TAR is that the researcher plays three roles, which must be kept logically separate, namely of artifact developer, artifact investigator, and client helper. Finally, TAR is compared to other approaches of using action research in design science, and with canonical action research.},
author = {Wieringa, R J and Morali, A},
booktitle = {Design Science Research in Information Systems. Advances in Theory and Practice 7th International Conference, DESRIST 2012, Las Vegas, USA},
doi = {10.1007/978-3-642-29863-9_17},
isbn = {978-3-642-29862-2},
issn = {0302-9743},
pages = {220--238},
pmid = {12581935},
title = {{Technical Action Research as a Validation Method in Information Systems Design Science}},
year = {2012}
}
@article{rogers2008-greenitpatterns,
author = {Rogers, Dan and Homann, Ulrich},
journal = {Microsoft Architecture Journal},
number = {1},
pages = {16--21},
title = {{Application Patterns for Green IT}},
volume = {18},
year = {2008}
}
@article{kitchenham2007-slr,
abstract = {The objective of this report is to propose comprehensive guidelines for systematic literature reviews appropriate for software engineering researchers, including PhD students. A systematic literature review is a means of evaluating and interpreting all available research relevant to a particular research question, topic area, or phenomenon of interest. Systematic reviews aim to present a fair evaluation of a research topic by using a trustworthy, rigorous, and auditable methodology. The guidelines presented in this report were derived from three existing guidelines used by medical researchers, two books produced by researchers with social science backgrounds and discussions with researchers from other disciplines who are involved in evidence-based practice. The guidelines have been adapted to reflect the specific problems of software engineering research. The guidelines cover three phases of a systematic literature review: planning the review, conducting the review and reporting the review. They provide a relatively high level description. They do not consider the impact of the research questions on the review procedures, nor do they specify in detail the mechanisms needed to perform meta-analysis.},
archivePrefix = {arXiv},
arxivId = {1304.1186},
author = {Kitchenham, Barbara and Charters, S},
doi = {10.1145/1134285.1134500},
eprint = {1304.1186},
isbn = {1595933751},
issn = {00010782},
journal = {Engineering},
pmid = {10853839},
title = {{Guidelines for performing Systematic Literature Reviews in Software Engineering}},
year = {2007}
}
@inproceedings{vanheesch2011-maturearch,
abstract = {Architecting is to a large extent a decision-making process. While many approaches and tools exist to support architects during the various activities of architecting, little guidance exists to support the reasoning part of decision-making. This is partly due to our limited understanding of how professional architects make decisions. We report on findings of a survey that we have conducted with 53 industrial software architects to find out how they reason in real projects. The results of the survey are interpreted with respect to the industrial context and the architecture literature. We derive reasoning best practices that can support especially inexperienced architects with optimizing their decision-making process.},
author = {van Heesch, Uwe and Avgeriou, Paris},
booktitle = {Proceedings - 9th Working IEEE/IFIP Conference on Software Architecture, WICSA 2011},
doi = {10.1109/WICSA.2011.42},
isbn = {9780769543512},
title = {{Mature architecting - A survey about the reasoning process of professional architects}},
year = {2011}
}
@article{falessi2011-archdecisionsurvey,
abstract = {The architecture of a software-intensive system can be defined as the set of relevant design decisions that affect the qualities of the overall system functionality; therefore, architectural decisions are eventually crucial to the success of a software project. The software engineering literature describes several techniques to choose among architectural alternatives, but it gives no clear guidance on which technique ismore suitable than another, and in which circumstances. As such, there is no systematic way for software engineers to choose among decision-making techniques for resolving tradeoffs in architecture design. In this article, we provide a comparison of existing decision-making techniques, aimed to guide architects in their selection. The results show that there is no “best” decision-making technique; however, some techniques are more susceptible to specific difficulties. Hence architects should choose a decision-making technique based on the difficulties that theywish to avoid. This article represents a first attempt to reason onmeta-decision-making, that is, the issue of deciding how to decide. Categories and Subject Descriptors: D.2.10 [Software Engineering]: Design—Methodologies General Terms: Design Additional KeyWords and Phrases: Decision-making, architecture, design decisions},
author = {Falessi, Davide and Cantone, Giovanni and Kazman, Rick and Kruchten, Philippe},
doi = {10.1145/1978802.1978812},
isbn = {0360-0300},
issn = {03600300},
journal = {ACM Computing Surveys},
pmid = {16481595},
title = {{Decision-making techniques for software architecture design}},
year = {2011}
}
@inproceedings{fernandez2015-qrprioritisation,
abstract = {Quality requirements prioritization is a complex multi-criteria decision making process that stakeholders face in any phase of software development. Several surveys have been carried out to identify the most important quality requirements considered in various domains and stakeholder perspectives. There is a lack of understanding, however, about how the perceived importance of these qualities can change during development. We conducted an empirical study for analyzing the evolvability of quality requirements prioritization from software architect viewpoint at different phases of a services-oriented design process. We found that interoperability and reliability emerge as the most stable quality requirements for the project in smart transportation domain, whereas usability and security were the least stable in comparison with other qualities identified by 19 teams along the project. These results can be used at project start to include the most relevant quality requirements, and in particular to prioritize those that should be "always there" (if stable) or those that demand specific attention (if unstable). {\&}copy; 2015 IEEE.},
author = {Condori-Fernandez, Nelly and Lago, Patricia},
booktitle = {5th International Workshop on Empirical Requirements Engineering, EmpiRE 2015 - Proceedings},
doi = {10.1109/EmpiRE.2015.7431305},
isbn = {9781509001163},
issn = {2329-6348},
keywords = {Quality requirements,prioritization,service design},
title = {{Can we know upfront how to prioritize quality requirements?}},
year = {2015}
}
@article{dayarathna2016-dcenergy,
abstract = {Data centers are critical, energy-hungry infrastructures that run large-scale Internet-based services. Energy consumption models are pivotal in designing and optimizing energy-efficient operations to curb excessive energy consumption in data centers. In this paper, we survey the state-of-the-art techniques used for energy consumption modeling and prediction for data centers and their components. We conduct an in-depth study of the existing literature on data center power modeling, covering more than 200 models. We organize these models in a hierarchical structure with two main branches focusing on hardware-centric and software-centric power models. Under hardware-centric approaches we start from the digital circuit level and move on to describe higher-level energy consumption models at the hardware component level, server level, data center level, and finally systems of systems level. Under the software-centric approaches we investigate power models developed for operating systems, virtual machines and software applications. This systematic approach allows us to identify multiple issues prevalent in power modeling of different levels of data center systems, including: i) few modeling efforts targeted at power consumption of the entire data center ii) many state-of-the-art power models are based on a few CPU or server metrics, and iii) the effectiveness and accuracy of these power models remain open questions. Based on these observations, we conclude the survey by describing key challenges for future research on constructing effective and accurate data center power models.},
author = {Dayarathna, M and Wen, Y and Fan, R},
doi = {10.1109/COMST.2015.2481183},
isbn = {1553-877X VO - 18},
issn = {1553-877X},
journal = {IEEE Communications Surveys {\&} Tutorials},
keywords = {Cloud Computing,Computational modeling,Data Center,Data center,Data models,Energy Consumption Modeling,Energy Efficiency,Energy consumption,Internet,Mathematical model,Power demand,Predictive models,Servers,cloud computing,computer centres,data center energy consumption modeling,data center power modeling,digital circuit level,energy consumption,energy consumption modeling,energy efficiency,energy-efficient operations,energy-hungry infrastructures,hardware component level,hardware-centric power models,hierarchical structure,large-scale Internet-based services,operating systems,operating systems (computers),power aware computing,server level,software-centric power models,telecommunication power management,virtual machines},
number = {1},
pages = {732--794},
title = {{Data Center Energy Consumption Modeling: A Survey}},
volume = {18},
year = {2016}
}
@inproceedings{svensson2011-qrprioritisation,
abstract = {Requirements prioritization is recognized as an important but challenging activity in software product development. For a product to be successful, it is crucial to find the right balance among competing quality requirements. Although literature offers many methods for requirements prioritization, the research on prioritization of quality requirements is limited. This study identifies how quality requirements are prioritized in practice at 11 successful companies developing software intensive systems. We found that ad-hoc prioritization and priority grouping of requirements are the dominant methods for prioritizing quality requirements. The results also show that it is common to use customer input as criteria for prioritization but absence of any criteria was also common. The results suggests that quality requirements by default have a lower priority than functional requirements, and that they only get attention in the prioritizing process if decision-makers are dedicated to invest specific time and resources on QR prioritization. The results of this study may help future research on quality requirements to focus investigations on industry-relevant issues.},
author = {Svensson, Richard Berntsson and Gorschek, Tony and Regnell, Bj{\"{o}}rn and Torkar, Richard and Shahrokni, Ali and Feldt, Robert and Aurum, Aybuke},
booktitle = {Proceedings of the 2011 IEEE 19th International Requirements Engineering Conference, RE 2011},
doi = {10.1109/RE.2011.6051652},
isbn = {9781457709234},
issn = {1090-705X},
keywords = {Empirical Study,Non-functional requirements,Product Management,Project Management,Quality Requirements,Requirements Prioritization},
title = {{Prioritization of quality requirements: State of practice in eleven companies}},
year = {2011}
}
@article{mohagheghi2017-managingqr,
abstract = {Context Eliciting, managing and implementing product quality requirements (in-short quality requirements) in a large organization can be challenging when many stakeholders are involved and projects run in parallel; sometimes with varying priorities with regards to quality. In this case from a public organization in Norway, the separation between business units and the IT-department and the legacy burden are additional factors that increase the complexity of requirement management. Objective This paper presents results and experiences from three years long work with quality requirements, starting from ad-hoc handling of quality requirements in separate projects to systematic work across projects with reusable sets of requirements and processes. Method We present how quality requirements are captured and classified, as well as changes to the agile software development process as a consequence of increasing focus on product quality. Results The ISO/IEC-25010:2011 standard is tailored for better context fit and is supported by concrete requirements and a methodology that covers the life cycle of software products in both greenfield and brownfield projects. In addition, the organization had to examine the current state of existing IT-capabilities in order to establish a quality baseline for future development, and develop shared vision and roadmaps for product quality. Conclusions In our experience, stakeholders prefer an iterative and lightweight approach in eliciting and refining quality requirements. The classification model and requirement lists are used as guidelines in requirement workshops. The developed terminology, updated templates and processes are reusable in projects and generalizable to different contexts, and are well adopted by the IT and business units.},
author = {Mohagheghi, Parastoo and Aparicio, Mario Ek},
doi = {10.1016/j.infsof.2017.04.002},
isbn = {0950-5849},
issn = {09505849},
journal = {Information and Software Technology},
keywords = {Agile,Experience report,Maintenance,Non-functional requirements,Product quality,Technical debt},
title = {{An industry experience report on managing product quality requirements in a large organization}},
year = {2017}
}
@inproceedings{noureddine2012-hotspots,
abstract = {GreenIT has emerged as a discipline concerned with the optimization of software solutions with regards to their energy consumption. In this domain, most of the state-of-the-art solutions concentrate on coarse-grained approaches to monitor the energy consumption of a device or a process. However, none of the existing solutions addresses in-process energy monitoring to provide in-depth analysis of a process energy consumption. In this paper, we therefore report on a fine-grained runtime energy monitoring framework we developed to help developers to diagnose energy hotspots with a better accuracy than the state-of-the-art. Concretely, our approach adopts a 2-layer architecture including OS-level and process-level energy monitoring. OS-level energy monitoring estimates the energy consumption of processes according to different hardware devices (CPU, network card). Process-level energy monitoring focuses on Java-based applications and builds on OS-level energy monitoring to provide an estimation of energy consumption at the granularity of classes and methods. We argue that this per-method analysis of energy consumption provides better insights to the application in order to identify potential energy hotspots. In particular, our preliminary validation demonstrates that we can monitor energy hotspots of Jetty web servers and monitor their variations under stress scenarios.},
author = {Noureddine, A and Bourdon, A and Rouvoy, R and Seinturier, L},
booktitle = {Automated Software Engineering (ASE), 2012 Proceedings of the 27th IEEE/ACM International Conference on},
doi = {10.1145/2351676.2351699},
isbn = {9781450312042},
keywords = {Java,energy consumption,file servers,green computi},
pages = {160--169},
title = {{Runtime monitoring of software energy hotspots}},
year = {2012}
}
@misc{bourdon2013-powerapi,
abstract = {Energy consumption by information and communication technologies (ICT) has been growing rapidly over recent years. Comparable to the civil aviation domain, the research community now considers ICT energy consumption as a major concern. Several studies report that energy consumption is an issue during all steps of a computer's life, from hardware assemblage, to usage, and dismantling. Research in the area of Green IT has proposed various approaches to save energy at the hardware and software levels. In the context of software, this challenge requires identification of new development methodologies that can help reduce the energy footprint. To tackle this challenge, we propose PowerAPI, a tool to quantify this energy consumption, by providing an application programming interface (API) that monitors, in real-time, the energy consumed at the granularity of a system process.},
author = {Bourdon, Aur{\'{e}}lien and Noureddine, Adel and Rouvoy, Romain and Seinturier, Lionel},
booktitle = {ERCIM News},
number = {92},
title = {{PowerAPI: A Software Library to Monitor the Energy Consumed at the Process-Level}},
year = {2013}
}
@inproceedings{jagroep2016-comparingreleases,
abstract = {In the quest for energy efficiency of Information and Com-munication Technology, so far research has mostly focused on the role of hardware. However, as hardware technol-ogy becomes more sophisticated, the role of software be-comes crucial. Recently, the impact of software on energy consumption has been acknowledged as significant by re-searchers in software engineering. In spite of that, measur-ing the energy consumption of software has proven to be a challenge, due to the large number of variables that need to be controlled to obtain reliable measurements. Due to cost and time constraints, many software product organizations are unable to effectively measure the energy consumption of software. This prevents them to be in control over the energy efficiency of their products. In this paper, we propose a software energy profiling meth-od to reliably compare the energy consumed by a software product across different releases, from the perspective of a software organization. Our method allows to attribute differences in energy consumption to changes in the soft-ware. We validate our profiling method through an empir-ical experiment on two consecutive releases of a commer-cial software product. We demonstrate how the method can be applied by organizations and provide an analysis of the software related changes in energy consumption. Our re-sults show that, despite a lack of precise measurements, en-ergy consumption differences between releases of a software product can be quantified down to the level of individual processes. Additionally, the results provide insights on how specific software changes might affect energy consumption.},
author = {Jagroep, Erik A. and van der Werf, Jan Martijn and Brinkkemper, Sjaak and Procaccianti, Giuseppe and Lago, Patricia and Blom, Leen and van Vliet, Rob},
booktitle = {Proceedings of the 38th International Conference on Software Engineering Companion - ICSE '16},
doi = {10.1145/2889160.2889216},
isbn = {9781450342056},
issn = {02705257},
pages = {523--532},
title = {{Software energy profiling: Comparing releases of a software product}},
year = {2016}
}
@article{noureddine2013-energyreview,
abstract = {Reducing the energy footprint of digital devices and software is a task challenging the research in Green IT. Researches have proposed approaches for energy management, ranging from reducing usage of software and hardware, compilators optimization, to server consolidation and software migration. However, optimizing the energy consumption requires knowledge of that said consumption. In particular, measuring the energy consumption of hardware and software is an important requirement for efficient energy strategies. In this review, we outline the different categories of ap- proaches in energy measurements, and provide insights into example of each category. We draw recommendations from our review on requirements on how to efficiently measure energy consumption of devices and software.},
author = {Noureddine, Adel and Rouvoy, Romain and Seinturier, Lionel},
doi = {10.1145/2553070.2553077},
issn = {01635980},
journal = {ACM SIGOPS Operating Systems Review},
number = {3},
pages = {42--49},
title = {{A review of energy measurement approaches}},
volume = {47},
year = {2013}
}
@article{procaccianti2013-cloudenergyefficiency,
abstract = {Cloud-based software is often considered as providing a greener, more energy-efficient solution. At the same time, it introduces more complexity and demands for new investments in cloud services, technologies, and competencies for migration, maintenance, and evolution of the underlying software architectures. To understand better the implications of cloud software architectures on energy efficiency, in this paper we present the preliminary results of a systematic literature review that investigates what kind of software architectures for cloud service provisioning allow to achieve energy-efficient solutions},
author = {Procaccianti, Giuseppe and Bevini, S. and Lago, P.},
isbn = {Conference item Procaccianti G., Bevini S., Lago P. (2013) $\backslash$r$\backslash$n Energy Efficiency in Cloud Software Architectures. In: 27th International Conference on Informatics for Environmental Protection (EnviroInfo 2013), University of Hamburg, Germany, September 2‒4, 2013. pp. 291-299},
journal = {27th International Conference on Informatics for Environmental Protection},
keywords = {()},
title = {{Energy Efficiency in Cloud Software Architectures}},
year = {2013}
}
@article{procaccianti2015-cloudenergy-litreview,
author = {Procaccianti, Giuseppe and Lago, Patricia and Bevini, Stefano},
journal = {Sustainable Computing: Informatics and Systems},
pages = {2--10},
publisher = {Elsevier},
title = {{A systematic literature review on energy efficiency in cloud software architectures}},
volume = {7},
year = {2015}
}
@inproceedings{lewis2016-foragingdm,
author = {Lewis, Grace A and Lago, Patricia and Avgeriou, Paris},
booktitle = {2016 13th Working IEEE/IFIP Conference on Software Architecture (WICSA)},
organization = {IEEE},
pages = {51--60},
title = {{A decision model for cyber-foraging systems}},
year = {2016}
}
@inproceedings{procaccianti2014-greentactics-wicsa,
author = {Procaccianti, Giuseppe and Lago, Patricia and Lewis, Grace A},
booktitle = {Software Architecture (WICSA), 2014 IEEE/IFIP Conference on},
organization = {IEEE},
pages = {41--44},
title = {{Green Architectural Tactics for the Cloud}},
year = {2014}
}
@article{procaccianti2016-twobestpractices,
author = {Procaccianti, Giuseppe and Fern{\'{a}}ndez, H{\'{e}}ctor and Lago, Patricia},
journal = {Journal of Systems and Software},
pages = {185--198},
publisher = {Elsevier},
title = {{Empirical evaluation of two best practices for energy-efficient software development}},
volume = {117},
year = {2016}
}
@article{jagroep2017-energyperspective,
author = {Jagroep, Erik and van der Werf, Jan Martijn and Brinkkemper, Sjaak and Blom, Leen and van Vliet, Rob},
journal = {Computing},
number = {6},
pages = {553--573},
publisher = {Springer},
title = {{Extending software architecture views with an energy consumption perspective}},
volume = {99},
year = {2017}
}
@inproceedings{lewis2015-foragingtactics,
abstract = {Mobile devices have become for many the preferred way of interacting with the Internet, social media and the enterprise. However, mobile devices still do not have the computing power or battery life that will allow them to perform effectively over long periods of time or for executing applications that require extensive communication or computation, or low latency. Cyber-foraging is a technique enabling mobile devices to extend their computing power and storage by offloading computation or data to more powerful servers located in the cloud or in single-hop proximity. This paper presents a catalog of architectural tactics for cyber-foraging that was derived from the results of a systematic literature review on architectures for cyber-foraging systems. Elements of the architectures identified in the primary studies were codified in the form of Architectural Tactics for Cyber- Foraging. These tactics will help architects extend their design reasoning towards cyber-foraging as a way to support the mobile applications of the present and the future.},
author = {Lewis, Grace A. and Lago, Patricia},
booktitle = {Proceedings of the 11th International ACM SIGSOFT Conference on Quality of Software Architectures - QoSA '15},
doi = {10.1145/2737182.2737188},
isbn = {9781450334709},
title = {{A Catalog of Architectural Tactics for Cyber-Foraging}},
year = {2015}
}
@inproceedings{jagroep2015-energyperspective,
author = {Jagroep, Erik A and van der Werf, Jan Martijn E M and Spauwen, Ruvar and Blom, Leen and van Vliet, Rob and Brinkkemper, Sjaak},
booktitle = {European Conference on Software Architecture},
organization = {Springer},
pages = {239--247},
title = {{An energy consumption perspective on software architecture}},
year = {2015}
}
@inproceedings{procaccianti2014-greentactics,
abstract = {Energy efficiency is a primary concern for the ICT sector. In particular, the widespread adoption of cloud computing technologies has drawn attention to the massive energy consumption of data centers. Although hardware constantly improves with respect to energy efficiency, this should also be a main concern for software. In previous work we analyzed the literature and elicited a set of techniques for addressing energy efficiency in cloud-based software architectures. In this work we codified these techniques in the form of Green Architectural Tactics. These tactics will help architects extend their design reasoning towards energy efficiency and to apply reusable solutions for greener software.},
author = {Procaccianti, Giuseppe and Lago, Patricia and Lewis, Grace A.},
booktitle = {Proceedings - 2014 IEEE 8th International Symposium on the Maintenance and Evolution of Service-Oriented and Cloud-Based Systems, MESOCA 2014},
doi = {10.1109/MESOCA.2014.12},
isbn = {9780769553061},
keywords = {Architectural Tactics,Cloud Computing,Energy Efficiency,Software Architecture},
title = {{A catalogue of green architectural tactics for the cloud}},
year = {2014}
}
@misc{iso-42010,
author = {{Technical Committee ISO/IEC JTC 1/SC 7 Software and systems engineering}},
pages = {37},
publisher = {International Standards Organisation (ISO)},
title = {{ISO/IEC 42010 Systems and Software Engineering-Recommended Practice for Architectural Description of Software-Intensive Systems}},
url = {https://www.iso.org/standard/50508.html},
year = {2011}
}
@misc{ebay2013-digitalefficiency,
author = {EBay},
booktitle = {EBay Tech Blog},
title = {{Digital Service Efficiency}},
url = {www.ebaytechblog.com/wp-content/uploads/2013/03/FINAL{\_}DSE-Solution-Paper.pdf},
year = {2013}
}
@inproceedings{chang1999-i3,
author = {Chang, Carl K and Kim, Seongwoon},
booktitle = {Computer Software and Applications Conference, 1999. COMPSAC'99. Proceedings. The Twenty-Third Annual International},
organization = {IEEE},
pages = {396--402},
title = {{I/sup 3: a Petri-net based specification method for architectural components}},
year = {1999}
}
@inproceedings{suvee2005-fusej,
author = {Suv{\'{e}}e, Davy and {De Fraine}, Bruno and Vanderperren, Wim},
booktitle = {Software-engineering Properties of Languages and Aspect Technologies Workshop@ AOSD2005},
organization = {Citeseer},
title = {{FuseJ: An architectural description language for unifying aspects and components}},
year = {2005}
}
@inproceedings{ubayashi2010-archface,
author = {Ubayashi, Naoyasu and Nomura, Jun and Tamai, Tetsuo},
booktitle = {Proceedings of the 32nd ACM/IEEE International Conference on Software Engineering-Volume 1},
organization = {ACM},
pages = {75--84},
title = {{Archface: a contract place where architectural design and code meet together}},
year = {2010}
}
@incollection{faucou2005-clara,
author = {Faucou, S{\'{e}}bastien and D{\'{e}}planche, Anne-Marie and Trinquet, Yvon},
booktitle = {Architecture Description Languages},
pages = {67--82},
publisher = {Springer},
title = {{An ADL centric approach for the formal design of real-time systems}},
year = {2005}
}
@inproceedings{kruger2004-serviceadl,
author = {Kruger, Ingolf Heiko and Mathew, Reena},
booktitle = {Software Architecture, 2004. WICSA 2004. Proceedings. Fourth Working IEEE/IFIP Conference on},
organization = {IEEE},
pages = {177--187},
title = {{Systematic development and exploration of service-oriented software architectures}},
year = {2004}
}
@incollection{canal1999-leda,
author = {Canal, Calos and Pimentel, Ernesto and Troya, Jos{\'{e}} M},
booktitle = {Software Architecture},
pages = {107--125},
publisher = {Springer},
title = {{Specification and refinement of dynamic software architectures}},
year = {1999}
}
@article{cassou2009-diaspec,
author = {Cassou, Damien and Bertran, Benjamin and Loriant, Nicolas and Consel, Charles},
institution = {ACM},
journal = {ACM Sigplan Notices},
number = {2},
pages = {137--146},
title = {{A generative programming approach to developing pervasive computing systems}},
volume = {45},
year = {2009}
}
@inproceedings{magableh2010-primitivec,
author = {Magableh, Basel and Barrett, Stephen},
booktitle = {Informatics and Systems (INFOS), 2010 The 7th International Conference on},
organization = {IEEE},
pages = {1--7},
title = {{Primitive component architecture description language}},
year = {2010}
}
@inproceedings{garcia2006-aspectualacme,
author = {Garcia, Alessandro and Chavez, Christina and Batista, Thais and Sant'Anna, Cl{\'{a}}udio and Kulesza, Uir{\'{a}} and Rashid, Awais and Lucena, Carlos},
booktitle = {European Workshop on Software Architecture},
organization = {Springer},
pages = {82--97},
title = {{On the modular representation of architectural aspects}},
year = {2006}
}
@article{amirat2009-c3,
author = {Amirat, Abdelkrim and Oussalah, Mourad},
journal = {The Journal of Object Technology},
number = {7},
pages = {107--130},
title = {{First-class connectors to support systematic construction of hierarchical software architecture}},
volume = {8},
year = {2009}
}
@inproceedings{su2010-acdl,
author = {Su, Guoxin and Ying, Mingsheng and Zhang, Chengqi},
booktitle = {European Conference on Software Architecture},
organization = {Springer},
pages = {8--23},
title = {{An ADL-approach to specifying and analyzing centralized-mode architectural connection}},
year = {2010}
}
@inproceedings{haber2011-montiarchhv,
author = {Haber, Arne and Rendel, Holger and Rumpe, Bernhard and Schaefer, Ina and {Van Der Linden}, Frank},
booktitle = {Software Product Line Conference (SPLC), 2011 15th International},
organization = {IEEE},
pages = {150--159},
title = {{Hierarchical variability modeling for software architectures}},
year = {2011}
}
@inproceedings{wang2012-adml,
author = {Wang, Zhuxiao and Peng, Hui and Guo, Jing and Zhang, Ying and Wu, Kehe and Xu, Huan and Wang, Xiaofeng},
booktitle = {International Conference on Intelligent Information Processing},
organization = {Springer},
pages = {157--166},
title = {{An architecture description language based on dynamic description logics}},
year = {2012}
}
@inproceedings{jing2008-ac2adl,
author = {Jing, Wen and Shi, Ying and LinLin, Zhang and YouCong, Ni},
booktitle = {Advanced Software Engineering and Its Applications, 2008. ASEA 2008},
organization = {IEEE},
pages = {147--152},
title = {{AC2-ADL: Architectural description of aspect-oriented systems}},
year = {2008}
}
@inproceedings{medvidovic1999-c2sadel,
author = {Medvidovic, Nenad and Rosenblum, David S and Taylor, Richard N},
booktitle = {Proceedings of the 21st international conference on Software engineering},
organization = {ACM},
pages = {44--53},
title = {{A language and environment for architecture-based software development and evolution}},
year = {1999}
}
@inproceedings{mei2002-abcadl,
author = {Mei, Hong and Chen, Feng and Wang, Qianxiang and Feng, Yaodong},
booktitle = {International Conference on Formal Engineering Methods},
organization = {Springer},
pages = {38--47},
title = {{ABC/ADL: An ADL supporting component composition}},
year = {2002}
}
@inproceedings{li2013-breeze,
author = {Li, Chen and Huang, Linpeng and Chen, Luxi and Yu, Chengyuan},
booktitle = {Computer Software and Applications Conference (COMPSAC), 2013 IEEE 37th Annual},
organization = {IEEE},
pages = {800--805},
title = {{Breeze/ADL: Graph grammar support for an xml-based software architecture description language}},
year = {2013}
}
@techreport{idc2016-cloudreport,
author = {Gantz, John F. and Miller, Pam},
institution = {International Data Corporation (IDC)},
title = {{The Salesforce Economy: Enabling 1.9 Million New Jobs and {\$}389 Billion in New Revenue Over the Next Five Years}},
year = {2016}
}
@inproceedings{mcveigh2006-backbone,
author = {McVeigh, Andrew and Kramer, Jeff and Magee, Jeff},
booktitle = {Proceedings of the 2006 conference on Specification and verification of component-based systems},
organization = {ACM},
pages = {49--56},
title = {{Using resemblance to support component reuse and evolution}},
year = {2006}
}
@techreport{eu2018-datacentreenergy,
author = {Acton, Mark and Bertoldi, Paolo and Booth, John and Newcombe, Liam and Rouyer, Andre and Tozer, Robert},
institution = {European Union Joint Research Centre},
title = {{2018 Best Practice Guidelines for the EU Code of Conduct on Data Centre Energy Efficiency}},
year = {2018}
}
@inproceedings{adjoyan2015-dsopl,
author = {Adjoyan, Seza and Seriai, Abdelhak-Djamel},
booktitle = {SEKE: Software Engineering and Knowledge Engineering},
title = {{An architecture description language for dynamic service-oriented product lines}},
year = {2015}
}
@inproceedings{nelson2013-ebaycasestudy,
author = {Nelson, Dean and On and Paquet, Raymond},
booktitle = {Gartner Data Center Conference},
title = {{How eBay's I{\&}O Organization Is Supporting Business Initiatives}},
year = {2013}
}
@book{brown2018-sad,
author = {Brown, Simon},
publisher = {Lean Pub},
title = {{Software Architecture for Developers, eBook}},
url = {https://softwarearchitecturefordevelopers.com},
year = {2018}
}
@article{hilton2017-darklaunch,
author = {Hilton, Adrian},
institution = {Google Inc},
journal = {Google Cloud Platform Blog},
title = {{CRE life lessons: What is a dark launch, and what does it do for me?}},
url = {https://cloudplatform.googleblog.com/2017/08/CRE-life-lessons-what-is-a-dark-launch-and-what-does-it-do-for-me.html},
year = {2017}
}
@misc{istio2018-mirroring,
author = {{Istio Authors}},
booktitle = {Istio 1.0 Documentation},
title = {{Mirroring}},
url = {https://istio.io/docs/tasks/traffic-management/mirroring/},
year = {2018}
}
@book{bachmann2011-documenting,
author = {Bachmann, Felix and Bass, Len and Garlan, David and Ivers, James and Little, Reed and Merson, Paulo and Nord, Robert and Stafford, Judith},
publisher = {Addison-Wesley Professional},
title = {{Documenting Software Architectures: Views and Beyond}},
year = {2011}
}
@article{kruchten1995-4plus1,
abstract = {This article presents a model for describing the architecture of software-intensive systems, based on the use of multiple, concurrent views. This use of multiple views allows to address separately the concerns of the various ‘stakeholders' of the architecture: end-user, developers, systems engineers, project managers, etc., and to handle separately the functional and non functional requirements. Each of the five views is described, together with a notation to capture it. The views are designed using an architecture-centered, scenario- driven, iterative development process.},
archivePrefix = {arXiv},
arxivId = {EEE Software},
author = {Kruchten, Philippe},
doi = {10.1145/216591.216611},
eprint = {EEE Software},
isbn = {0897917057},
issn = {07407459},
journal = {IEEE Software},
keywords = {object-oriented design,software architecture,software development process,view},
number = {6},
pages = {42--50},
pmid = {3651256673990163555},
title = {{Architectural blueprints–the” 4+ 1” view model of software architecture}},
volume = {12},
year = {1995}
}
@inproceedings{wang2012-soadl,
author = {Wang, Quan Yu and Ying, Shi and Jia, Xiang Yang and Lv, Guo Bin and Shuai, Yun},
booktitle = {Advanced Materials Research},
organization = {Trans Tech Publ},
pages = {3500--3509},
title = {{SOADL-EH: Service-Oriented Architecture Description Language Supporting Exception Handling}},
volume = {433},
year = {2012}
}
@inproceedings{chaudet2000-pispace,
author = {Chaudet, Christelle and Oquendo, Flavio},
booktitle = {Automated Software Engineering, 2000. Proceedings ASE 2000. The Fifteenth IEEE International Conference on},
organization = {IEEE},
pages = {245--248},
title = {{pi-SPACE: a formal architecture description language based on process algebra for evolving software systems}},
year = {2000}
}
@article{shaw1995-abstractions,
abstract = {Architectures for software use rich abstractions and idioms to describe system components, the nature of interactions among the components, and the patterns that guide the composition of components into systems. These abstractions are higher level than the elements usually supported by programming languages and tools. They capture packaging and interaction issues as well as computational functionality. Well-established (if informal) patterns guide the architectural design of systems. We sketch a model for defining architectures and present an implementation of the basic level of that model. Our purpose is to support the abstractions used in practice by software designers. The implementation provides a testbed for experiments with a variety of system construction mechanisms. It distinguishes among different types of components and different ways these components can interact. It supports abstract interactions such as data flow and scheduling on the same footing as simple procedure call. It can express and check appropriate compatibility restrictions and configuration constraints. It accepts existing code as components, incurring no runtime overhead after initialization. It allows easy incorporation of specifications and associated analysis tools developed elsewhere. The implementation provides a base for extending the notation and validating the model .},
author = {Shaw, M and DeLine, R and Klein, D V and Ross, T L and Young, D M and Zelesnik, G},
doi = {10.1109/32.385970},
issn = {00985589},
journal = {IEEE Transactions on Software Engineering},
keywords = {architectural abstraction,architecture description language,organization,software architecture,software engineering,software system},
month = {apr},
number = {4},
pages = {314--335},
title = {{Abstractions for software architecture and tools to support them}},
url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=385970},
volume = {21},
year = {1995}
}
@inproceedings{zhang2005-vadl,
author = {Zhang, Tao and Wang, Haipeng},
booktitle = {2nd International Software Product Lines Young Researchers Workshop (SPLYR 2005)},
title = {{vADL: A Variability-Supported Architecture Description Language for Specifying Product Line Architectures}},
year = {2005}
}
@article{alloui2001-zeta,
author = {Alloui, Ilham and Oquendo, Flavio},
journal = {Enterprise Information Systems III},
publisher = {Kluwer Academic Publishers Dordrecht, The Netherlands},
title = {{Supporting decentralised software-intensive processes using zeta component-based architecture description language}},
year = {2001}
}
@inproceedings{mohammad2008-tadl,
author = {Mohammad, Mubarak and Alagar, Vasu},
booktitle = {European Conference on Software Architecture},
organization = {Springer},
pages = {290--297},
title = {{TADL-an architecture description language for trustworthy component-based systems}},
year = {2008}
}
@misc{Oquendo2005,
author = {Oquendo, Prof Flavio},
title = {{Tutorial on ArchWare ADL – Version 2 ( {\$}\pi{\$}-ADL Tutorial )}},
year = {2005}
}
@inproceedings{perez2003-prisma,
author = {P{\'{e}}rez, Jennifer and Ramos, Isidro and Ja{\'{e}}n, Javier and Letelier, Patricio and Navarro, Elena},
booktitle = {Quality Software, 2003. Proceedings. Third International Conference on},
organization = {IEEE},
pages = {59--66},
title = {{Prisma: Towards quality, aspect oriented and dynamic software architectures}},
year = {2003}
}
@inproceedings{grahn1998-energystyles,
author = {Grahn, H{\aa}kan and Bosch, Jan},
booktitle = {Proceedings of the 1st international workshop on Software and performance},
organization = {ACM},
pages = {197--198},
title = {{Some initial performance characteristics of three architectural styles}},
year = {1998}
}
@techreport{iso30134-pue,
address = {Geneva, CH},
author = {{International Organization for Standardization}},
institution = {ISO},
keywords = {ISO/IEC 30134-2:2016},
mendeley-tags = {ISO/IEC 30134-2:2016},
title = {{Information technology -- Data centres -- Key performance indicators -- Part 2: Power usage effectiveness (PUE)}},
year = {2016}
}
@techreport{ipmi2013,
author = {{Intel Corporation} and {Hewlett Packard Company} and {NEC Corporation} and {Dell Inc}},
institution = {Intel Corporation},
pages = {644},
title = {{Intelligent Platform Management Interface Specification, v2.0}},
url = {https://www.intel.co.uk/content/www/uk/en/servers/ipmi/ipmi-second-gen-interface-spec-v2-rev1-1.html},
year = {2013}
}
@misc{collectd2018,
title = {{collectd Documentation}},
url = {https://collectd.org/documentation.shtml},
year = {2018}
}
@book{jemerov2017-kotlin,
author = {Jemerov, Dmitry and Isakova, Svetlana},
publisher = {Manning Publications Company},
title = {{Kotlin in Action}},
year = {2017}
}
@misc{nlyte2018,
author = {{Nlyte Software}},
institution = {Nlyte Software},
title = {{Nlyte Energy Optimizer Product Overview}},
url = {https://resources.nlyte.com/neo/nlyte-energy-optimizer},
year = {2018}
}
@techreport{dmtf2018-redfish,
author = {{Distributed Management Task Force}},
institution = {Distributed Management Task Force},
pages = {116},
title = {{Redfish Scalable Platforms Management API Specification}},
url = {https://www.dmtf.org/sites/default/files/standards/documents/DSP0266{\_}1.5.0.pdf},
year = {2018}
}
@misc{dynatrace2018,
title = {{Dynatrace Documentation}},
url = {https://www.dynatrace.com/support/doc},
year = {2018}
}
@misc{kubernetes2018,
title = {{Kubernetes Documentation}},
url = {https://kubernetes.io/docs},
year = {2018}
}
@misc{newrelic2018,
title = {{New Relic Documentation}},
url = {https://docs.newrelic.com/},
year = {2018}
}
@misc{appdynamics2018,
title = {{AppDynamics App iQ Platform Documentation}},
url = {https://docs.appdynamics.com/},
year = {2018}
}
@inproceedings{seo2008-energystyle,
abstract = {The selection of an architectural style for a given software system is an important factor in satisfying its quality requirements. In battery-powered environments, such as mobile and pervasive systems, efficiency with respect to energy consumption has increasingly been recognized as an important quality attribute. In this paper, we present a framework that (1) facilitates early estimation of the energy consumption induced by an architectural style in a distributed software system, and (2) consequently enables an engineer to use energy consumption estimates along with other quality attributes in determining the most appropriate style for a given distributed application. We have applied the framework on five distributed systems styles to date, and have evaluated it for precision and accuracy using a particular middleware platform that supports the implementation of those styles. In a large number of application scenarios, our framework exhibited excellent precision, in that it was consistently able to correctly rank the five styles and estimate the relative differences in their energy consumptions. Moreover, the framework has also proven to be accurate: its estimates were within 7{\%} of the different style implementations' actually measured energy consumptions. {\&}copy; 2008 IEEE.},
author = {Seo, Chiyoung and Edwards, George and Malek, Sam and Medvidovic, Nenad},
booktitle = {7th IEEE/IFIP Working Conference on Software Architecture, WICSA 2008},
doi = {10.1109/WICSA.2008.28},
isbn = {0769530923},
title = {{A framework for estimating the impact of a distributed software system's architectural style on its energy consumption}},
year = {2008}
}
@misc{opentracing2018-traces,
title = {{Open Tracing - What is a span?}},
url = {http://opentracing.io/documentation/{\#}what-is-a-trace},
urldate = {2018-07-23},
year = {2018}
}
@misc{cadvisor2018,
title = {{cAdvisor Home Page}},
url = {https://github.com/google/cadvisor},
urldate = {2018-07-23},
year = {2018}
}
@misc{jaeger2018,
title = {{Jaeger Home Page}},
url = {https://www.jaegertracing.io/},
urldate = {2018-07-23},
year = {2018}
}
@misc{telegraf2018,
title = {{Telegraf Documentation}},
url = {https://docs.influxdata.com/telegraf},
urldate = {2018-07-23},
year = {2018}
}
@misc{zipkin2018,
title = {{Zipkin Home Page}},
url = {https://zipkin.io/},
urldate = {2018-07-23},
year = {2018}
}
@techreport{sigelman2010-dapper,
author = {Sigelman, Benjamin H and Barroso, Luiz Andr{\'{e}} and Burrows, Mike and Stephenson, Pat and Plakal, Manoj and Beaver, Donald and Jaspan, Saul and Shanbhag, Chandan},
institution = {Google, Inc.},
title = {{Dapper, a Large-Scale Distributed Systems Tracing Infrastructure}},
url = {https://research.google.com/archive/papers/dapper-2010-1.pdf},
year = {2010}
}
@misc{influxdb2018,
title = {{InfluxDB Documentation}},
url = {https://docs.influxdata.com/influxdb},
urldate = {2018-07-23},
year = {2018}
}
@misc{prometheus2018,
title = {{Prometheus Home Page}},
url = {https://prometheus.io/},
urldate = {2018-07-23},
year = {2018}
}
@article{alvaro2017-tracing,
author = {Alvaro, Peter and Galwani, Sumit and Bailis, Peter},
journal = {Queue},
number = {1},
pages = {60},
publisher = {ACM},
title = {{Research for Practice: Tracing and Debugging Distributed Systems; Programming by Examples}},
volume = {15},
year = {2017}
}
@misc{docker2018,
title = {{Docker Home Page}},
url = {https://www.docker.com/},
urldate = {2018-07-23},
year = {2018}
}
@misc{rkt2018,
title = {{Rkt Home Page}},
url = {https://coreos.com/rkt/},
urldate = {2018-07-23},
year = {2018}
}
@misc{cloudfoundry2018,
title = {{Cloud Foundry Home Page}},
url = {https://www.cloudfoundry.org/},
urldate = {2018-07-23},
year = {2018}
}
@inproceedings{noureddine2016-jolinar,
abstract = {Monitoring energy consumption of applications is crucial for energy optimisation and improvements in software systems. With the recent emphasis on energy efficiency, it is vital that software engineers have an understanding of the energy consumed by the code they write. In this paper, we present Jolinar, a tool that bridges the gap between energy mea-surements and accessibility to software engineers and even end-users. The tool builds on top of recent energy models to provide an accurate, light and easy-to-use interface for en-ergy measurements. The target audience of Jolinar is both software engineers and non-technical end-users who want to monitor their applications' energy footprint. We show that end-users can use Jolinar's GUI to determine the energy consumed by the software they are using, and software en-gineers can use the tool to analyse energy consumption of systems to make energy-conscious decisions.},
author = {Noureddine, Adel and Islam, Syed and Bashroush, Rabih},
booktitle = {Proceedings of the 25th International Symposium on Software Testing and Analysis - ISSTA 2016},
doi = {10.1145/2931037.2948706},
isbn = {9781450343909},
keywords = {energy footprint,program analysis},
pages = {445--448},
title = {{Jolinar: analysing the energy footprint of software applications}},
year = {2016}
}
@book{evans2006_ddd,
abstract = {The most complicated aspect of large software projects is not the implementation, it is the real world domain that the software serves. Domain Driven Design is a vision and approach for dealing with highly complex domains that is based on making the domain itself the main focus of the project, and maintaining a software model that reflects a deep understanding of the domain. The vision was brought to the world by Eric Evans in his book "Domain Driven Design". Eric's work was based on 20 years of widely accepted best practices in the object community, as well as Eric's own insights. Domain Driven Design Quickly is a short, quick-readable summary and introduction to the fundamentals of DDD. A special interview with Eric Evans on the state of Domain Driven Design is also included.},
archivePrefix = {arXiv},
arxivId = {arXiv:1011.1669v3},
author = {Evans, Eric},
doi = {978-1-4116-0925-9},
eprint = {arXiv:1011.1669v3},
isbn = {1411609255},
issn = {00155713},
pmid = {12566760},
publisher = {Addison Wesley},
title = {{Domain Driven Design}},
year = {2006}
}
@misc{raml2018,
title = {{RESTful API Modeling Language}},
url = {https://github.com/raml-org/raml-spec},
year = {2018}
}
@misc{openapi2018,
keywords = {v3.0.1},
mendeley-tags = {v3.0.1},
title = {{OpenAPI Specification}},
url = {https://swagger.io/specification/},
year = {2018}
}
@book{newman2015_microservices,
abstract = {Distributed systems have become more fine-grained in the past 10 years, shifting from code-heavy monolithic applications to smaller, self-contained microservices. But developing these systems brings its own set of headaches. With lots of examples and practical advice, this book takes a holistic view of the topics that system architects and administrators must consider when building, managing, and evolving microservice architectures.Microservice technologies are moving quickly. Author Sam Newman provides you with a firm grounding in the concepts while diving into current solutions for modeling, integrating, testing, deploying, and monitoring your own autonomous services. You'll follow a fictional company throughout the book to learn how building a microservice architecture affects a single domain.Discover how microservices allow you to align your system design with your organization's goalsLearn options for integrating a service with the rest of your systemTake an incremental approach when splitting monolithic codebasesDeploy individual microservices through continuous integrationExamine the complexities of testing and monitoring distributed servicesManage security with user-to-service and service-to-service modelsUnderstand the challenges of scaling microservice architectures},
archivePrefix = {arXiv},
arxivId = {1606.04036},
author = {Newman, Sam},
booktitle = {O'Reilly},
doi = {10.1109/MS.2016.64},
eprint = {1606.04036},
isbn = {978-1-491-95035-7},
issn = {07407459},
keywords = {www.it-ebooks.info},
pmid = {15003161},
publisher = {O'Reilly},
title = {{Building Microservices: designing fine-grained systems}},
year = {2015}
}
@inproceedings{mazlami2017_microservices_monoliths,
author = {Mazlami, G and Cito, J and Leitner, P},
booktitle = {2017 IEEE International Conference on Web Services (ICWS)},
doi = {10.1109/ICWS.2017.61},
keywords = {Cloud computing,Clustering algorithms,Computer architecture,Couplings,DevOps,Industries,Tools,Web services,Web-based prototype,algorithmic recommendation,cloud computing,cloud computing infrastructure,coupling,domain-specific redundancy,elastic computing,extraction,formal models,graph-based clustering,informal migration patterns,microservice architectural style,microservice candidates,microservice extraction model,microservice-oriented architectures,microservice-specific metrics,microservices,mobile computing,monolithic code bases,monolithic legacy applications,monolithic software architectures,performance evaluation,service-oriented architecture},
month = {jun},
pages = {524--531},
title = {{Extraction of Microservices from Monolithic Software Architectures}},
year = {2017}
}
@misc{richardson2018_microservices,
author = {Richardson, Chris},
booktitle = {microservices.io},
title = {{Pattern: Microservice Architecture}},
url = {http://microservices.io/patterns/microservices.html},
year = {2018}
}
@misc{hitachi_drive_data_sheet,
author = {Hitachi},
title = {{Hitachi Ultrastar C10K1800 Hard Drive Data Sheet}},
url = {https://www.hgst.com/sites/default/files/resources/USC10K1800{\_}ds.pdf},
year = {2015}
}
@article{bashroush2018_hardwarerefresh,
author = {Bashroush, R},
doi = {10.1109/TSUSC.2018.2795465},
journal = {IEEE Transactions on Sustainable Computing},
keywords = {Cognition,Data centres,Energy consumption,Hardware,Market research,Mathematical model,Servers,energy efficiency,environmental impact,hardware refresh rate},
pages = {1},
title = {{A Comprehensive Reasoning Framework for Hardware Refresh in Data Centres}},
year = {2018}
}
@misc{windows_performance_monitor,
author = {Morrison, Blake},
booktitle = {Ask the Performance Team Blog},
title = {{Windows Performance Monitor Overview}},
url = {https://blogs.technet.microsoft.com/askperf/2014/07/17/windows-performance-monitor-overview/},
year = {2014}
}
@techreport{dc4cities2014_dcmetrics,
author = {ENEA},
institution = {DC4Cities Project},
pages = {77},
title = {{Description of Energy Metrics for Data Centres D7.1}},
url = {http://www.dc4cities.eu/en/wp-content/uploads/2014/12/D7.1-Description-of-Energy-Metrics-for-Datacentres.pdf},
year = {2014}
}
@misc{wikipedia_microservices,
booktitle = {Wikipedia},
title = {{Wikipedia - Microservices}},
url = {https://en.wikipedia.org/wiki/Microservices},
year = {2018}
}
@misc{unix_sar_command,
author = {Godard and Sebastien},
booktitle = {Unix man pages},
title = {{Unix sar(1) command manual page}},
url = {https://linux.die.net/man/1/sar},
urldate = {2018-07-16},
year = {2018}
}
@techreport{josey2004-ieee1003,
author = {Josey, Andrew and Cragun, Donald and Stoughton, Nicholas and Brown, Mark and Hughes, Cathy},
institution = {The IEEE and The Open Group},
title = {{The Open Group base specifications issue 6 IEEE Standard 1003.1}},
url = {http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/contents.html},
year = {2004}
}
@article{lange2009-specpower,
abstract = {To drive energy efficiency initiatives, SPEC established SPECpower{\_}ssj2008, the first industry-standard benchmark for measuring power and performance characteristics of computer systems.},
author = {Lange, Klaus Dieter},
doi = {10.1109/MC.2009.84},
isbn = {0018-9162 VO - 42},
issn = {00189162},
journal = {Computer},
keywords = {Benchmark testing,Benchmarks,Computers,Energy efficiency,Green IT,Industries,Power measurement,SPECpower{\_}ssj2008,Servers,Temperature sensors},
number = {3},
pages = {92----97},
title = {{Identifying shades of green: The SPECpower benchmarks}},
volume = {42},
year = {2009}
}
@misc{sunbird2018,
abstract = {In today's data center, being efficient with power and cooling resources is just as important as maintaining uptime. Power IQ{\textregistered} (PIQ) software provides the information and controls you need to fully utilize your existing infrastructure resources while alerting you to trouble before it causes downtime. PIQ software can be easily deployed as a standalone DCIM monitoring solution or with Sunbird's dcTrack{\textregistered} DCIM Operations to provide full asset and change management. PIQ functionality scales to meet enterprise needs, allowing you to securely monitor all your data centers and labs, including your CRACs, UPS, PDUs, RPPs, Meters, Branch Circuits, Racks, Rack PDUs, Environment Sensors, IT Devices, and Electronic Door Locks—all from a single web browser. PIQ is vendor neutral and automatically supports a number of devices and manufacturers (see back page). You can easily add support for any other manufacturers with our dynamic plugin capability},
address = {Somerset, NJ, USA},
author = {{Sunbird Software}},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Sunbird Software - 2018 - Power IQ DCIM Monitoring Software.pdf:pdf},
institution = {Sunbird Software},
title = {{Power IQ DCIM Monitoring Software}},
url = {https://www.sunbirddcim.com/sites/default/files/DS007{\_}Sunbird{\_}DataSheet{\_}PowerIQ6{\_}2.pdf},
year = {2018}
}
@misc{shapiro2015-datacentre-mythsrealities,
author = {Shapiro, Steven},
title = {{Myths and Realities About Designing High Availability Data Centers}},
url = {http://blog.morrisonhershfield.com/myths-realities-designing-high-availability-data-centers/},
year = {2015}
}
@misc{uptime2015-tierclassification,
author = {Institute, Uptime},
title = {{Tier Classification System}},
url = {http://uptimeinstitute.com/tiers},
urldate = {2018-07-13},
year = {2015}
}
@inproceedings{woods2017-archpriorisation,
author = {Woods, Eoin and Bashroush, Rabih},
booktitle = {European Conference on Software Architecture},
pages = {183--190},
publisher = {Springer},
title = {{A Model for Prioritization of Software Architecture Effort}},
year = {2017}
}
@book{koch1998-8020principle,
author = {Koch, Richard},
isbn = {978-0385491709},
pages = {277},
publisher = {Bantam Doubleday Dell Publishing Group},
title = {{The 80/20 principle: the secret to achieving more with less.}},
year = {1998}
}
@book{lapan2012-qualitativeresearch,
abstract = {Lapan, S., Quartaroli, ML, Riemer, F. (2012) “Introduction to Qualitative Research”},
author = {Lapan, Stephen and Quartaroli, MaryLynn and Riemer, Frances},
booktitle = {Qualitative research in practice: Examples for {\ldots}},
isbn = {978-0470548004},
pages = {560},
publisher = {John Wiley and Sons},
title = {{Qualitative research: An introduction to methods and designs.}},
year = {2012}
}
@inproceedings{hermann2008-reqprioritization,
abstract = {In early phases of the software cycle, requirements prioritization necessarily relies on the specified requirements and on predictions of benefit and cost of individual requirements. This paper presents results of a systematic review of literature, which investigates how existing methods approach the problem of requirements prioritization based on benefit and cost. From this review, it derives a set of under-researched issues which warrant future efforts and sketches an agenda for future research in this area.},
author = {Herrmann, A and Daneva, M},
booktitle = {Proc. 16th IEEE Int'l Conf. Requirements Eng.},
doi = {10.1109/RE.2008.48},
isbn = {0-7695-1980-6},
issn = {1089-6503},
keywords = {requirements prioritization,software},
pages = {125--134},
title = {{Requirements Prioritization Based on Benefit and Cost Prediction: An Agenda for Future Research}},
year = {2008}
}
@article{achimugu2014-reqprio-litreview,
abstract = {During requirements engineering, prioritization is performed to grade or rank requirements in their order of importance and subsequent implementation releases. It is a major step taken in making crucial decisions so as to increase the economic value of a system.$\backslash$nObjective$\backslash$nThe purpose of this study is to identify and analyze existing prioritization techniques in the context of the formulated research questions.$\backslash$nMethod$\backslash$nSearch terms with relevant keywords were used to identify primary studies that relate requirements prioritization classified under journal articles, conference papers, workshops, symposiums, book chapters and IEEE bulletins.$\backslash$nResults$\backslash$n73 Primary studies were selected from the search processes. Out of these studies; 13 were journal articles, 35 were conference papers and 8 were workshop papers. Furthermore, contributions from symposiums as well as IEEE bulletins were 2 each while the total number of book chapters amounted to 13.$\backslash$nConclusion$\backslash$nPrioritization has been significantly discussed in the requirements engineering domain. However, it was generally discovered that, existing prioritization techniques suffer from a number of limitations which includes: lack of scalability, methods of dealing with rank updates during requirements evolution, coordination among stakeholders and requirements dependency issues. Also, the applicability of existing techniques in complex and real setting has not been reported yet.},
author = {Achimugu, Philip and Selamat, Ali and Ibrahim, Roliana and Mahrin, Mohd Naz'ri},
doi = {10.1016/j.infsof.2014.02.001},
isbn = {0950-5849},
issn = {0950-5849},
journal = {Information and Software Technology},
number = {6},
pages = {568--585},
title = {{A systematic literature review of software requirements prioritization research}},
volume = {56},
year = {2014}
}
@inproceedings{islam2016-energysoftwarefeatures,
abstract = {With the proliferation of Software systems and the rise of paradigms such the Internet of Things, Cyber-Physical Systems and Smart Cities to name a few, the energy consumed by software applications is emerging as a major concern. Hence, it has become vital that software engineers have a better understanding of the energy consumed by the code they write. At software level, work so far has focused on measuring the energy consumption at function and application level. In this paper, we propose a novel approach to measure energy consumption at a feature level, cross-cutting multiple functions, classes and systems. We argue the importance of such measurement and the new insight it provides to non-traditional stakeholders such as service providers. We then demonstrate, using an experiment, how the measurement can be done with a combination of tools, namely our program slicing tool (PORBS) and energy measurement tool (Jolinar).},
author = {Islam, Syed and Noureddine, Adel and Bashroush, Rabih},
booktitle = {IEEE International Conference on Program Comprehension},
doi = {10.1109/ICPC.2016.7503726},
isbn = {9781509014286},
title = {{Measuring energy footprint of software features}},
year = {2016}
}
@article{koomey2011-trends-energy-efficiency,
abstract = {Moore's},
author = {Koomey, Jonathan G. and Berard, Stephen and Sanchez, Marla and Wong, Henry},
doi = {10.1109/MAHC.2010.28},
isbn = {1058-6180},
issn = {10586180},
journal = {IEEE Annals of the History of Computing},
keywords = {Moore's law,computer performance,electrical efficiency,history of computing,mobile computing,power usage},
pmid = {5440129},
title = {{Implications of historical trends in the electrical efficiency of computing}},
year = {2011}
}
@article{mills2013-digital-energyusage,
abstract = {The information economy is a blue‐whale economy with its energy uses mostly out of sight. Based on a mid‐range estimate, the world's Information‐Communications‐Technologies (ICT) ecosystem uses about 1,500 TWh of electricity annually, equal to all the electric generation of Japan and Germany combined ‐‐ as much electricity as was used for global illumination in 1985. The ICT ecosystem now approaches 10{\%} of world electricity generation. Or in other energy terms – the zettabyte era already uses about 50{\%} more energy than global aviation. Reduced to personal terms, although charging up a single tablet or smart phone requires a negligible amount of electricity, using either to watch an hour of video weekly consumes annually more electricity in the remote networks than two new refrigerators use in a year.1 And as the world continues to electrify, migrating towards one refrigerator per household, it also evolves towards several smartphones and equivalent per person. The growth in ICT energy demand will continue to be moderated by efficiency gains. But the historic rate of improvement in the efficiency of underlying ICT technologies started slowing around 2005, followed almost immediately by a new era of rapid growth in global data traffic, and in particular the emergence of wireless broadband for smartphones and tablets. The inherent nature of the mobile Internet, a key feature of the emergent Cloud architecture, requires far more energy than do wired networks. The remarkable and recent changes in technology mean that current estimates of global ICT energy use, most of which use pre‐iPhone era data, understate reality. Trends now promise faster, not slower, growth in ICT energy use. Future growth in electricity to power the global ICT ecosystem is anchored in just two variables, demand (how fast traffic grows), and supply (how fast technology efficiency improves): ? As costs keep plummeting, how fast do another billion people buy smartphones and join wireless broadband networks where they will use 1,000 times more data per person than they do today; how fast do another billion, or more, join the Internet at all; how fast do a trillion machines and devices join the Internet to fuel the information appetite of Big Data? ? Can engineers invent, and companies deploy, more efficient ICT hardware faster than data traffic grows? To estimate the amount of electricity used to fuel everything that produces, stores, transports, processes and displays zettabytes of data, one must account for the energy used by: ? Data centers that have become warehouse‐scale supercomputers unlike anything in history; ? Ubiquitous broadband wired and wireless communications networks; ? The myriad of end‐use devices from PCs to tablets and smart phones to digital TV, and, ? The manufacturing facilities producing all the ICT hardware. Hourly Internet traffic will soon exceed the annual traffic of the year 2000. And demand for data and bandwidth and the associated infrastructure are growing rapidly not just to enable new consumer products and video, but also to drive revolutions in everything from healthcare to cars, and from factories to farms. Historically, demand for bits has grown faster than the energy efficiency of using them. In order for worldwide ICT electric demand to merely double in a decade, unprecedented improvements in efficiency will be needed now. Electricity fuels the infrastructure of the world's ICT ecosystem ‐‐ the Internet, Big Data and the Cloud. Coal is the world's largest single current and future source of electricity. Hence the title of this paper.},
author = {{P. Mills}, Mark},
journal = {by Digital Power Group},
title = {{The cloud begins with coal: Big data, Big Networks, Big infrastructure, and Big power - An Overview of the Electricity use by the Global Digital Ecosystem}},
year = {2013}
}
@techreport{cisco2016-uksecprioritisation,
author = {Cisco},
institution = {Cisco Systems Inc},
pages = {11},
title = {{United Kingdom: Prioritising Security at Management and Board Levels}},
url = {https://www.cisco.com/c/dam/en/us/products/collateral/security/security-benchmark-study-uk.pdf},
year = {2016}
}
@article{ozkaya2008-qualityproperties,
author = {Ozkaya, Ipek and Bass, Len and Sangwan, Raghvinder S and Nord, Robert L},
journal = {IEEE Software},
number = {25-33},
title = {{Making practical use of quality attribute information}},
volume = {25},
year = {2008}
}
@misc{wikipedia-sitawareness,
author = {Wikipedia},
booktitle = {Wikipedia},
title = {{Situational Awareness}},
url = {https://en.wikipedia.org/wiki/Situation{\_}awareness},
urldate = {2018-06-23},
year = {2018}
}
@book{bass2012-sainp,
archivePrefix = {arXiv},
arxivId = {arXiv:1011.1669v3},
author = {Bass, Len and Clements, Paul and Kazman, Rick},
doi = {10.1024/0301-1526.32.1.54},
edition = {3},
eprint = {arXiv:1011.1669v3},
isbn = {0321154959},
issn = {03008495},
pages = {640},
pmid = {21301655},
publisher = {Addison Wesley},
title = {{Software Architecture in Practice}},
year = {2012}
}
@incollection{berander2005-reqpriorization,
abstract = {This chapter provides an overview of techniques for prioritization of requirements for software products. Prioritization is a crucial step towards making good decisions regarding product planning for single and multiple releases. Various aspects of functionality are considered, such as importance, risk, cost, etc. Prioritization decisions are made by stakeholders, including users, managers, developers, or their representatives. Methods are for combining individual prioritizations based on overall objectives and constraints. A range of different techniques and aspects are applied to an example to illustrate their use. Finally, limitations and shortcomings of current methods are pointed out, and open research questions in the area of requirements prioritization are discussed.},
author = {Berander, Patrik and Andrews, Anneliese},
booktitle = {Engineering and Managing Software Requirements},
doi = {10.1007/3-540-28244-0_4},
isbn = {9783540250432},
issn = {978-3-540-25043-2},
keywords = {Decision support,Requirements analysis,Requirements prioritization,Software product planning,Trade offs},
pages = {69--94},
publisher = {Springer Science and Business Media},
title = {{Requirements prioritization}},
year = {2005}
}
@article{kruchten2008-architectsdo,
abstract = {To be successful, a software architect-or a software architecture team, collectively-must strike a delicate balance between an external focus-both outwards: Listening to customers, users, watching technology, developing a long-term vision, and inwards: driving the development teams-and an internal, reflective focus: spending time to make the right design choices, validating them, and documenting them. Teams that stray too far away from this metastable equilibrium fall into some traps that we describe as antipatterns of software architecture teams. {\textcopyright} 2008 Elsevier Inc. All rights reserved.},
author = {Kruchten, Philippe},
doi = {10.1016/j.jss.2008.08.025},
isbn = {0164-1212},
issn = {01641212},
journal = {Journal of Systems and Software},
keywords = {Antipattern,Software architect,Software architecture,Time-management},
number = {12},
pages = {2413--2416},
title = {{What do software architects really do?}},
volume = {81},
year = {2008}
}
@incollection{matt1994-threatstovalidity,
abstract = {10. Matt, G.E., Cook, T.D.: . eds) T, pp. 503-520. Russell Sage Foundation, New York. 503-520 (1994)},
address = {New York, New York, USA},
author = {Matt, Georg E. and Cook, Thomas D.},
booktitle = {The Handbook of Research Synthesis},
editor = {Cooper, H and Hedges, L.V.},
pages = {503--520},
publisher = {Russell Sage Foundation},
title = {{Threats to the validity of research synthesis}},
year = {1994}
}
@book{rozanski2011-ssa2e,
author = {Rozanski, Nick and Woods, Eoin},
edition = {2},
isbn = {978-0321718334},
pages = {704},
publisher = {Addison Wesley},
title = {{Software Systems Architecture: working with stakeholders using viewpoints and perspectives}},
year = {2011}
}
@book{charmaz2006-groundedtheory,
abstract = {`Grounded theory is a highly influential way of working with qualitative data and Kathy Charmaz is a major player, both innovative and fluent. This book is a model student text: lively, carefully argued and full of vivid illustrations. Beginning students and professional researchers will find it to be required reading' - David Silverman, Professor Emeritus, Sociology Department, Goldsmiths College and Visiting Professor, Management Department, King's College, University of London Kathy Charmaz is one of the world's leading theorists and exponents of grounded theory. In this important and essential new textbook, she introduces the reader to the craft of using grounded theory in social research, and provides a clear, step-by-step guide for those new to the field.Using worked examples throughout, this book also maps out an alternative vision of grounded theory put forward by its founding thinkers, Glaser and Strauss. To Charmaz, grounded theory must move on from its positivist origins and must incorporate many of the methods and questions posed by constructivists over the past twenty years to become a more nuanced and reflexive practice.Essential reading for students, new researchers and seasoned social scientists alike, this book is one of those rare things, a textbook that is both accessible to those new to the field but also one that has important things to say about the nature of social enquiry itself.},
archivePrefix = {arXiv},
arxivId = {arXiv:1011.1669v3},
author = {Charmaz, Kathy},
booktitle = {Book},
doi = {10.1016/j.lisr.2007.11.003},
eprint = {arXiv:1011.1669v3},
isbn = {9780761973522},
issn = {07408188},
pages = {222},
pmid = {82},
publisher = {Sage},
title = {{Constructing grounded theory: a practical guide through qualitative analysis}},
year = {2006}
}
@inproceedings{poort2012-rcda,
abstract = {We propose to view architecting as a risk- and cost management discipline. This point of view helps architects identify the key concerns to address in their decision making, by providing a simple, relatively objective way to assess architectural significance. It also helps business stakeholders to align the architect's activities and results with their own goals. We examine the consequences of this point of view on the architecture process. The point of view is the basis of RCDA, the Risk- and Cost Driven Architecture approach. So far, more than 150 architects have received RCDA training. For a majority of the trainees, RCDA has a significant positive impact on their architecting work. {\textcopyright} 2012 Elsevier Inc. All rights reserved.},
author = {Poort, Eltjo R. and {Van Vliet}, Hans},
booktitle = {Journal of Systems and Software},
doi = {10.1016/j.jss.2012.03.071},
isbn = {0164-1212},
issn = {01641212},
keywords = {Cost management,Risk Management,Software architecture},
title = {{RCDA: Architecting as a risk- and cost management discipline}},
year = {2012}
}
@book{allen2015-gettingthingsdone,
author = {Allen, David},
isbn = {978-0349408941},
pages = {352},
publisher = {Piatkus},
title = {{Getting Things Done: The Art of Stress-free Productivity}},
year = {2015}
}
@article{delforge2014-datacentreenergy,
abstract = {Data centers have become the backbone of the U.S. economy, powering businesses, communications, and online consumer services and helping make our society more productive and efficient. All of our online activity—including email, social media, and conducting business—is delivered through data centers. Ranging from small computer server rooms to mammoth “server farms,” these data centers house an estimated 12 million computer servers for data processing, data storage devices, and networking machines. Data centers also are among the nation's largest and fastest-growing population of consumers of electricity. In 2013 alone, nearly 3 million computer rooms used enough electricity to power all of the households in New York City for two years, equivalent to the annual output of 34 large coal-fired power plants. While the data center industry has made progress in cutting energy waste, an analysis by the Natural Resources Defense Council in partnership with Anthesis finds up to 30 percent of servers are “comatose” and no longer needed, other machines are grossly underutilized, and a number of strategic and tactical barriers still remain. This report recommends steps to accelerate the pace and scale of energy savings across the industry, including the use and public disclosure of energy efficiency metrics. If},
author = {Delforge, Pierre},
journal = {Natural Resources Defense Council (NRDC)},
title = {{America's Data Centers Are Wasting Huge Amounts of Energy}},
year = {2014}
}
@misc{eurocommission2015-energyefficiency,
institution = {European Commission JRC Insitute for Energy and Transport},
title = {{The European Code of Conduct for Energy Efficiency in Data Centres}},
url = {http://iet.jrc.ec.europa.eu/energyefficiency/ict-codes-conduct/data- centres-energy-efficiency},
year = {2015}
}
@misc{greengrid2015-dcmm,
author = {Singh, Harkeeret},
title = {{The Green Grid Data Centre Maturity Model}},
url = {https://www.thegreengrid.org/en/resources/library-and-tools/438-Data-Center-Maturity-Model},
year = {2015}
}
@misc{evans2008-iotinfo,
author = {Evans, David},
booktitle = {Cisco Blogs},
title = {{The Internet of Things Infographic}},
url = {http://blogs.cisco.com/diversity/the-internet-of-things-infographic},
urldate = {2015-10-23},
year = {2008}
}
@inproceedings{diruscio2010-byadl,
abstract = {In order to deal with evolving needs and stakeholder concerns, next generation ADLs should support incremental extension and customization. In this direction we proposed byADL (Build Your ADL), a framework which allows software architects to (i) extend existent ADLs with domain specificities, new architectural views, or analysis aspects, (ii) integrate an ADL with development processes and methodologies, and (iii) customize an ADL. This paper presents the byADL tool and its features.},
author = {{Di Ruscio}, Davide and Malavolta, Ivano and Muccini, Henry and Pelliccione, Patrizio and Pierantonio, Alfonso},
booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
doi = {10.1007/978-3-642-15114-9_56},
isbn = {3642151132},
issn = {03029743},
title = {{ByADL: An MDE framework for building extensible architecture description languages}},
year = {2010}
}
@book{shaw1996-softwarearch,
abstract = {Good software developers often adopt one or several architectural patterns as strategies for system organization. But, although they use these patterns purposefully, they often use them informally and nearly unconsciously. This book organizes this substantial emerging "folklore" of system design - with its rich language of system description - and closes the gap between the useful abstractions (constructs and patterns) of system design and the current models, notations and tools. It identifies useful patterns clearly, gives examples, compares them, and evaluates their utility in various settings - allowing readers to develop a repertoire of useful techniques that goes beyond the single-minded current fads. Examines the ways in which architectural issues can impact software design; shows how to design new systems in principled ways using well-understood architectural paradigms; emphasizes informal descriptions, touching lightly on formal notations and specifications, and the tools that support them; explains how to understand and evaluate the design of existing software systems from an architectural perspective; and presents concrete examples of actual system architectures that can serve as models for new designs. For professional software developers looking for new ideas about system organization.},
author = {Shaw, Mary and Garlan, David},
isbn = {0131829572},
issn = {02756617},
publisher = {Prentice Hall},
title = {{Software Architecture: Perspectives on an Emerging Discipline}},
year = {1996}
}
@inproceedings{cuenot2010-east,
abstract = {Current trends in automotive embedded systems focus on how to manage the increasing software content, with a strong emphasis on standardization of the embedded software structure. The management of engineering information remains a critical challenge in order to support development and other stages of the life-cycle. System modelling based on an Architecture Description Language (ADL) is a way to keep these assets within one information structure. This paper presents the EAST-ADL2 modelling language, developed in the ITEA EAST-EEA project and further enhanced in the ATESST project (www.atesst.org). EAST-ADL2 supports comprehensive model-based development of embedded systems and provides dedicated constructs to facilitate variability and product line management, requirements engineering, representation of functional as well as software/hardware solutions, and timing and safety analysis.},
author = {Cuenot, Philippe and Frey, Patrick and Johansson, Rolf and L{\"{o}}nn, Henrik and Papadopoulos, Yiannis and Reiser, Mark Oliver and Sandberg, Anders and Servat, David and {Tavakoli Kolagari}, Ramin and T{\"{o}}rngren, Martin and Weber, Matthias},
booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
doi = {10.1007/978-3-642-16277-0_11},
isbn = {3642162762},
issn = {03029743},
title = {{The EAST-ADL architecture description language for automotive embedded software}},
year = {2010}
}
@misc{bashroush2006-flexibleadls,
abstract = {Architecture Description Languages (ADLs) have emerged in recent years as a tool for providing high-level descriptions of software systems in terms of their architectural elements and the relationships among them. Most of the current ADLs exhibit limitations which prevent their widespread use in industrial applications. In this paper, we discuss these limitations and introduce ALI, an ADL that has been developed to address such limitations. The ALI language provides a rich and flexible syntax for describing component interfaces, architectural patterns, and meta-information. Multiple graphical architectural views can then be derived from ALI's textual notation. Keywords: Software Architecture, Architecture Description Languages, Architectural Patterns.},
author = {Bashroush, Rabih and Spence, Ivor and Kilpatrick, Peter and Brown, John},
booktitle = {Software Architecture},
doi = {10.1007/11966104_16},
isbn = {978-3-540-69271-3},
keywords = {adl},
title = {{Towards More Flexible Architecture Description Languages for Industrial Applications}},
year = {2006}
}
@article{malavolta2013-industryadlneeds,
abstract = {Many times we are faced with the proliferation of definitions, concepts, languages and tools in certain (research) topics. But often there is a gap between what is provided by existing technologies, and what is needed by their users. The strengths, limitations and needs of the available technologies can be dubious. The same applies to software architectures, and specifically to languages designed to represent architectural models. Tens of different architectural languages have been introduced by the research and industrial communities in the last two decades. However, it is unclear if they fulfill the user's perceived needs in architectural description. As a way to plan for next generation languages for architectural description, this study analyzes practitioners' perceived strengths, limitations and needs associated to existing languages for software architecture modeling in industry.We run a survey by interviewing 48 practitioners from 40 different IT companies in 15 countries. Each participant is asked to fill in a questionnaire of 51 questions. By analyzing the data collected through this study, we have concluded that (a) whilst practitioners are generally satisfied with the design capabilities provided by the languages they use, they are dissatisfied with the architectural language analysis features and their abilities to define extra-functional properties; (b) architectural languages used in practice mostly originate from industrial development instead of from academic research; (c) more formality and better usability are required of an architectural language.},
author = {Malavolta, Ivano and Lago, Patricia and Muccini, Henry and Pelliccione, Patrizio and Tang, Antony},
doi = {10.1109/TSE.2012.74},
isbn = {0098-5589 VO - 39},
issn = {00985589},
journal = {IEEE Transactions on Software Engineering},
keywords = {ADL,Software architecture,architecture description languages,empirical study,survey},
number = {6},
pages = {869--891},
title = {{What industry needs from architectural languages: A survey}},
volume = {39},
year = {2013}
}
@article{luckham1995-rapideexample,
abstract = {Rapide is an event-based concurrent object-oriented language specifically designed for prototyping system architectures. Two principle design goals are (1) to provide constructs for defning executable prototypes of architectures and (2) to adopt an execution model in which the concurrency synchronization dataflow and timing properties of a prototype are explicitly represented. This paper describes the partially ordered event set (poset) execution model and outlines with examples some of the event-based features for defining communication architectures and relationships between architectures. Various features of Rapide are illustrated by excerpts from a prototype of the X/Open distributed transaction processing reference architecture.},
author = {Luckham, DC C and Kenney, JJ J and Augustin, L.M. M and Vera, J. and Bryan, D. and Mann, W.},
doi = {10.1109/32.385971},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Luckham et al. - 1995 - Specification and analysis of system architecture using Rapide.pdf:pdf},
issn = {00985589},
journal = {IEEE Transactions on Software Engineering},
keywords = {architecture,architecture definition languages,causality,concurrency,constraint-based specification,event patterns,formal constraints,partially ordered event sets,prototyping,rapide,simulation},
month = {apr},
number = {4},
pages = {336--354},
publisher = {Institute of Electrical and Electronics Engineers (IEEE)},
title = {{Specification and analysis of system architecture using Rapide}},
volume = {21},
year = {1995}
}
@techreport{feiler2000-realtime,
abstract = {This paper discusses a model-based architectural approach for improving predictability of performance in embedded real-time systems. This approach utilizes automated analysis of task and communication architectures to provide insight into schedulability and reliability during design. Automatic generation of a runtime executive that performs task dispatching and inter-task communication eliminates manual coding errors and results in a system that satisfies the specified execution behavior. The MetaH language and toolset supports this model-based approach. MetaH has been used by the U.S. Army in a pilot project applied to missile guidance systems. Reduced time and cost benefits that have been observed will be discussed as a case study. The paper closes by outlining the current state of commercial availability of such technology and efforts to develop standards, such as those put forth by the Society of Automotive Engineers (SAE); Avionics Systems Division (ASD); working group on Avionics Architecture Description Language (AADL); and the Object Management Group (OMG) Unified Modeling Language (UML) working group on real-time and performance support in UML.},
address = {Pittsburgh, Pennsylvania},
author = {Feiler, Peter H and Lewis, Bruce and Vestal, Steve},
doi = {10.21236/ada387086},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Feiler, Lewis, Vestal - 2000 - Improving Predictability in Embedded Real-Time Systems.pdf:pdf},
institution = {Software Engineering Institute, Carnegie Mellon University},
month = {dec},
number = {December},
pages = {CMU/SEI--2000--SR--011},
publisher = {Defense Technical Information Center},
title = {{Improving Predictability in Embedded Real-Time Systems}},
year = {2000}
}
@article{Malavolta2013,
author = {Malavolta, Ivano and Lago, Patricia and Muccini, Henry and Pelliccione, Patrizio and Tang, Antony},
doi = {10.1109/tse.2012.74},
journal = {IEEE Transactions on Software Engineering},
month = {jun},
number = {6},
pages = {869--891},
publisher = {Institute of Electrical and Electronics Engineers (IEEE)},
title = {{What Industry Needs from Architectural Languages: A Survey}},
volume = {39},
year = {2013}
}
@incollection{loques2004-crrio,
author = {Loques, Orlando and Sztajnberg, Alexandre},
booktitle = {Lecture Notes in Computer Science},
doi = {10.1007/978-3-540-24848-4_2},
pages = {18--34},
publisher = {Springer Berlin Heidelberg},
title = {{Customizing Component-Based Architectures by Contract}},
year = {2004}
}
@inproceedings{pinto2001-daop,
abstract = {The increasing complexity in the development of distributed system has promoted the appearance of new software technologies that complements compositional framework technology providing a high degree of separation of concerns. One of these approaches is aspect-oriented programming that introduces a new entity, the aspect, to model those features that cut across different components in the system, increasing its extensibility and configurability. Our goal is the application of this new technology to develop an aspect-oriented application framework to construct highly reusable collaborative virtual environments in short time.},
author = {Pinto, M and Fuentes, L and Troya, J.M. and Fayad, M.E.},
booktitle = {Proceedings of the IEEE Computer Society Workshop on Future Trends of Distributed Computing Systems},
doi = {10.1109/ftdcs.2001.969615},
publisher = {IEEE Comput. Soc},
title = {{Towards an aspect-oriented framework in the design of collaborative virtual environments}},
year = {2001}
}
@article{moody2009-notations,
abstract = {Visual notations form an integral part of the language of software engineering (SE). Yet historically, SE researchers and notation designers have ignored or undervalued issues of visual representation. In evaluating and comparing notations, details of visual syntax are rarely discussed. In designing notations, the majority of effort is spent on semantics, with graphical conventions largely an afterthought. Typically, no design rationale, scientific or otherwise, is provided for visual representation choices. While SE has developed mature methods for evaluating and designing semantics, it lacks equivalent methods for visual syntax. This paper defines a set of principles for designing cognitively effective visual notations: ones that are optimized for human communication and problem solving. Together these form a design theory, called the Physics of Notations as it focuses on the physical (perceptual) properties of notations rather than their logical (semantic) properties. The principles were synthesized from theory and empirical evidence from a wide range of fields and rest on an explicit theory of how visual notations communicate. They can be used to evaluate, compare, and improve existing visual notations as well as to construct new ones. The paper identifies serious design flaws in some of the leading SE notations, together with practical suggestions for improving them. It also showcases some examples of visual notation design excellence from SE and other fields.},
author = {Moody, Daniel},
doi = {10.1109/TSE.2009.67},
isbn = {978-1-60558-719-6},
issn = {00985589},
journal = {IEEE Transactions on Software Engineering},
keywords = {Analysis,Communication,Concrete syntax,Diagrams,Modeling,Visual syntax,Visualization},
month = {nov},
number = {6},
pages = {756--779},
publisher = {Institute of Electrical and Electronics Engineers (IEEE)},
title = {{The physics of notations: Toward a scientific basis for constructing visual notations in software engineering}},
url = {https://doi.org/10.1109{\%}2Ftse.2009.67},
volume = {35},
year = {2009}
}
@inproceedings{smolander1991-metaedit,
abstract = {Existing CASE tools are often rigid and do not support the users'$\backslash$nnative methodologies. To alleviate this, more flexible and customisable$\backslash$ntools called CASE shells are emerging. However, the customisation$\backslash$nof those tools is still cumbersome and error-prone, and demands several$\backslash$nconfiguration files that follow a rigid syntax of some metamodelling$\backslash$nlanguage(s). In order to make the customisation easier, we propose$\backslash$na graphical metamodelling editor, MetaEdit, with which the conceptual$\backslash$nstructures of the user methodology can be modelled easily using an$\backslash$neasy-to-grasp graphical notation. With MetaEdit, methodology models$\backslash$ncan be constructed with less effort and the configuration files for$\backslash$nthe CASE shell can be created (semi)automatically. The tool is flexible$\backslash$ni.e. its symbols and metamodel are user-definable. In consequence$\backslash$nit can be used as a simple CASE shell. MetaEdit is based on the Object-Property-Role-Relationship$\backslash$n(OPRR) data model. The paper presents the principles on which the$\backslash$neditor is built, describes its operation, and discusses its relations$\backslash$nto other research on metamodelling.},
author = {Smolander, Karl and Lyydnen, Kalle and Tahvanalnen, Veli-Pekka and Marttiin, Pentti},
booktitle = {International Conference on Advanced Information Systems Engineering},
doi = {10.1007/3-540-54059-8_85},
isbn = {978-3-540-54059-5},
issn = {0302-9743},
keywords = {1this research was ill,case-shells,computer aided software engineering,engineering,finland,metamodelling,methodology,part funded by the,technology development center of},
pages = {168--193},
publisher = {Springer Berlin Heidelberg},
title = {{MetaEdit - A Flexible Graphical Environment for Methodology Modelling}},
year = {1991}
}
@inproceedings{lankhorst2009-archimate,
abstract = {In current business practice, an integrated approach to business and IT is indispensable. In many enterprises, however, such an integrated view of the entire enterprise is still far from reality. To deal with these challenges, an integrated view of the enterprise is needed, enabling impact/change analysis covering all relevant aspects. This need sparked the development of the ArchiMate language, which was developed with the explicit intention of becoming an open standard, and as such has been designed such that it is extendable while still maintaining a clear and orthogonal structure. This paper is concerned with documenting some of the key design decisions and design principles underlying the ArchiMate language. ArchiMate is designed as an architecture description language (ADL) for enterprise architectures. We will start by discussing the challenges facing the design of an architecture description language. Consequently we discuss the way how the design principles of the ArchiMate language aim to tackle these challenges. We then continue with a discussion of the modelling concepts needed. In this, we make a distinction between concepts needed to model domains in general, the modelling of dynamic systems, and the modelling of enterprise architectures.},
author = {Lankhorst, M M and Proper, H A and Jonkers, H},
booktitle = {Lecture Notes in Business Information Processing},
doi = {10.1007/978-3-642-01862-6_30},
isbn = {9783642018619},
issn = {18651348},
pages = {367--380},
publisher = {Springer Berlin Heidelberg},
title = {{The architecture of the ArchiMate language}},
volume = {29 LNBIP},
year = {2009}
}
@incollection{Bashroush2009,
author = {Bashroush, R and Spence, I},
booktitle = {Information Systems Development},
doi = {10.1007/b137171_24},
pages = {227--237},
publisher = {Springer US},
title = {{An Extensible ADL for Service-Oriented Architectures}},
url = {https://doi.org/10.1007{\%}2Fb137171{\_}24},
year = {2009}
}
@inproceedings{Bashroush,
author = {Bashroush, R and Brown, T J and Spence, I and Kilpatrick, P},
booktitle = {29th Annual IEEE/NASA Software Engineering Workshop},
doi = {10.1109/sew.2005.17},
file = {:Users/eoin/Dropbox/Work/PhDWork/Rabih-Resources/SoftwareArchitecture/ADL SLR/ADLARS-Bashroush.pdf:pdf},
publisher = {IEEE},
title = {{ADLARS: An Architecture Description Language for Software Product Lines}}
}
@inproceedings{khare2001-xadl,
abstract = {In order to support architecture-centric tool integration within the ArchStudio 2.0 Integrated Development Environment (IDE), we adopted Extensible Markup Language (XML) to represent the shared architecture-in-progress. Since ArchStudio is an architectural style-based development environment that incorporates an extensive number of tools, including commercial off-the-shelf products, we developed a new, vendor-neutral, ADL-neutral interchange format called Extensible Architecture description Language (xADL), as well as a "vocabulary" specific to the C2 style (xC2). This paper outlines our vision for representing architectures as hypertext, the design rationale behind xADL and xC2, and summarizes our engineering experience with this strategy.},
author = {Khare, R and Guntersdorfer, M and Oreizy, P and Medvidovic, N and Taylor, R.N.},
booktitle = {Proceedings of the 34th Annual Hawaii International Conference on System Sciences},
doi = {10.1109/HICSS.2001.927248},
isbn = {0-7695-0981-9},
issn = {10603425},
pages = {9},
publisher = {IEEE Comput. Soc},
title = {{xADL: enabling architecture-centric tool integration with XML}},
year = {2001}
}
@article{batory1997-genvoca,
abstract = {GenVoca generators synthesize software systems by composing components from reuse libraries. GenVoca components are designed to export and import standardized interfaces, and thus be plug-compatible, interchangeable, and interoperable with other components. We examine two different but important issues in software system synthesis. First, not all syntactically correct compositions of components are semantically correct. We present simple, efficient, and domain-independent algorithms for validating compositions of GenVoca components. Second, components that export and import immutable interfaces are too restrictive for software system synthesis. We show that the interfaces and bodies of GenVoca components are subjective, i.e., they mutate and enlarge upon instantiation. This mutability enables software systems with customized interfaces to be composed from components with “standardized” interfaces},
author = {Batory, Don and Geraci, Bart J},
doi = {10.1109/32.585497},
issn = {00985589},
journal = {IEEE Transactions on Software Engineering},
keywords = {Compositon validation,Design rule checking,Genvoca,Software generators,Subjectivity},
number = {2},
pages = {67--82},
publisher = {Institute of Electrical and Electronics Engineers (IEEE)},
title = {{Composition validation and subjectivity in genvoca generators}},
url = {https://doi.org/10.1109{\%}2F32.585497},
volume = {23},
year = {1997}
}
@article{allen1996-wright,
author = {Allen, Robert and Garlan, David},
journal = {Technical Report CMU-CS-96-TBD, Carnegie Mellon University, School of Computer Science},
publisher = {Citeseer},
title = {{The Wright architectural specification language}},
year = {1996}
}
@article{shaw1996-unicon,
abstract = {The architecture of a software system shows how the system is realized by a collection of components together with the interactions among these components. Conventional design focuses the components, but the properties of the system depend critically on the character of the interactions. Although software designers have good informal abstractions for these interactions, these abstractions are poorly supported by the available languages and tools. As a result, the choice of interaction is often defaulted or made implicitly rather than deliberately chosen. Further, interactions are usually programmed in terms of underlying mechanisms rather than the designers' natural abstractions. UniCon supports a rich selection of abstractions for the connectors that mediate interactions among components. Connector implementation presents special challenges. The 'compiler' must produce and integrate not only the object code for components, but also a variety of other run-time products. The definition of a connector requires many connector-specific kinds of information in the compiler, graphical editor, and associated tools. Extending the set of connectors supported by UniCon requires this information to be provided by the connector designer and automatically integrated in the compiler. This paper describes the role of connector abstractions in software design, the connector abstractions currently supported by UniCon, and implementation issues associated with supporting an-open-ended collection of connectors.},
author = {Shaw, Mary and DeLine, Robert and Zelesnik, Gregory},
doi = {10.1109/CDS.1996.509340},
isbn = {0-8186-7395-8},
journal = {IEEE International Workshop on Configurable Distributed Systems -Proceedings},
keywords = {architectural abstraction,architecture description language,connectors,software architecture,software system organization,system configuration},
pages = {2--10},
publisher = {IEEE Comput. Soc. Press},
title = {{Abstractions and implementations for architectural connections}},
year = {1996}
}
@techreport{Allen1997,
author = {Allen, Robert J},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Allen - 1997 - A Formal Approach to Software Architecture.pdf:pdf},
institution = {Carnegie-Mellon Univ Pittsburgh Pa School Of Computer Science},
title = {{A Formal Approach to Software Architecture.}},
year = {1997}
}
@inproceedings{dunsire2005-abacus,
author = {Dunsire, K and ONeill, T and Denford, M and Leaney, J},
booktitle = {12th IEEE International Conference and Workshops on the Engineering of Computer-Based Systems (ECBS05)},
doi = {10.1109/ecbs.2005.66},
pages = {62--69},
publisher = {IEEE},
title = {{The ABACUS Architectural Approach to Computer-Based System and Enterprise Evolution}},
url = {https://doi.org/10.1109{\%}2Fecbs.2005.66},
year = {2005}
}
@article{Garlan2000,
author = {Garlan, David and Monroe, Robert T and Wile, David},
journal = {Foundations of component-based systems},
pages = {47--68},
title = {{Acme: Architectural description of component-based systems}},
volume = {68},
year = {2000}
}
@misc{sae2009-aadl,
author = {{SAE International}},
doi = {10.4271/as5506},
publisher = {SAE International},
title = {{Architecture Analysis {\&} Design Language (AADL)}},
year = {2009}
}
@inproceedings{lonn2004-east,
author = {Lonn, H},
booktitle = {"Software Engineering for Automotive Systems" Workshop W14S - 26th International Conference on Software Engineering},
doi = {10.1049/ic:20040338},
pages = {43--50},
publisher = {IEE},
title = {{FAR EAST: modeling an automotive software architecture using the EAST ADL}},
year = {2004}
}
@inproceedings{allen2002-rtsystems,
author = {Allen, Robert and Vestal, Steve and Cornhill, Dennis and Lewis, Bruce},
booktitle = {Proceedings of the third international workshop on Software and performance - WOSP 02},
doi = {10.1145/584395.584399},
publisher = {ACM Press},
title = {{Using an architecture description language for quantitative analysis of real-time systems}},
year = {2002}
}
@article{VanOmmering2000,
author = {van Ommering, R and van der Linden, F and Kramer, J and Magee, J},
doi = {10.1109/2.825699},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/van Ommering et al. - 2000 - The Koala component model for consumer electronics software.pdf:pdf},
journal = {Computer},
month = {mar},
number = {3},
pages = {78--85},
publisher = {Institute of Electrical and Electronics Engineers (IEEE)},
title = {{The Koala component model for consumer electronics software}},
url = {https://doi.org/10.1109{\%}5C{\%}5C{\%}2F2.825699},
volume = {33},
year = {2000}
}
@incollection{Cuenot2010,
author = {Cuenot, Philippe and Frey, Patrick and Johansson, Rolf and L{\"{o}}nn, Henrik and Papadopoulos, Yiannis and Reiser, Mark-Oliver and Sandberg, Anders and Servat, David and Kolagari, Ramin Tavakoli and T{\"{o}}rngren, Martin and Others},
booktitle = {Model-Based Engineering of Embedded Real-Time Systems},
pages = {297--307},
publisher = {Springer},
title = {11 the east-adl architecture description language for automotive embedded software},
year = {2010}
}
@inproceedings{DiRuscio2010,
author = {{Di Ruscio}, Davide and Malavolta, Ivano and Muccini, Henry and Pelliccione, Patrizio and Pierantonio, Alfonso},
booktitle = {European Conference on Software Architecture},
pages = {527--531},
title = {{ByADL: an MDE framework for building extensible architecture description languages}},
year = {2010}
}
@article{Wieman1991,
abstract = {We present a review of the use of diode lasers in atomic physics with an extensive list of references. We discuss the relevant characteristics of diode lasers and explain how to purchase and use them. We also review the various techniques that have been used to control and narrow the spectral outputs of diode lasers. Finally we present a number of examples illustrating the use of diode lasers in atomic physics experiments. Review of Scientific Instruments is copyrighted by The American Institute of Physics.},
author = {Wieman, Carl E and Hollberg, Leo},
journal = {Review of Scientific Instruments},
keywords = {Diode Laser},
month = {jan},
number = {1},
pages = {1--20},
title = {{Using Diode Lasers for Atomic Physics}},
url = {http://link.aip.org/link/?RSI/62/1/1},
volume = {62},
year = {1991}
}
@article{Arnold1998,
abstract = {Operating a laser diode in an extended cavity which provides frequency-selective feedback is a very effective method of reducing the laser's linewidth and improving its tunability. We have developed an extremely simple laser of this type, built from inexpensive commercial components with only a few minor modifications. A 780{\~{}}nm laser built to this design has an output power of 80{\~{}}mW, a linewidth of 350{\~{}}kHz, and it has been continuously locked to a Doppler-free rubidium transition for several days.},
author = {Arnold, A S and Wilson, J S and Boshier, M G},
journal = {Review of Scientific Instruments},
month = {mar},
number = {3},
pages = {1236--1239},
title = {{A Simple Extended-Cavity Diode Laser}},
url = {http://link.aip.org/link/?RSI/69/1236/1},
volume = {69},
year = {1998}
}
@article{Hawthorn2001,
abstract = {We have developed an enhanced Littrow configuration extended cavity diode laser (ECDL) that can be tuned without changing the direction of the output beam. The output of a conventional Littrow ECDL is reflected from a plane mirror fixed parallel to the tuning diffraction grating. Using a free-space Michelson wavemeter to measure the laser wavelength, we can tune the laser over a range greater than 10 nm without any alteration of alignment.},
author = {Hawthorn, C J and Weber, K P and Scholten, R E},
journal = {Review of Scientific Instruments},
month = {dec},
number = {12},
pages = {4477--4479},
title = {{Littrow Configuration Tunable External Cavity Diode Laser with Fixed Direction Output Beam}},
url = {http://link.aip.org/link/?RSI/72/4477/1},
volume = {72},
year = {2001}
}
@article{Nakagawa2018,
author = {Nakagawa, E.Y. and Capilla, R. and Woods, E. and Kruchten, P.},
doi = {10.1016/j.jss.2018.02.044},
issn = {01641212},
journal = {Journal of Systems and Software},
title = {{Sustainability and longevity of systems and architectures}},
volume = {140},
year = {2018}
}
@article{bashroush2016-datacentreenergy,
abstract = {{\textcopyright} 1984-2012 IEEE. Given environmentalism's rising tide and increasing energy prices and IT workloads, architects must determine whether they can continue designing systems without considering energy and power efficiency.},
author = {Bashroush, R. and Woods, E. and Noureddine, A.},
doi = {10.1109/MS.2016.53},
issn = {07407459},
journal = {IEEE Software},
keywords = {energy efficiency,green computing,software architect,software architecture,software design,software development,software engineering},
number = {2},
pages = {18----21},
title = {{Data center energy demand: What got us here won't get us there}},
volume = {33},
year = {2016}
}
@article{Woods2016a,
abstract = {{\textcopyright} 2016 IEEE. The emerging DevOps movement emphasizes development and operations staff working together as early as possible-sharing tools, processes, and practices that smooth the production path. This article is part of a theme issue on DevOps.},
author = {Woods, E.},
doi = {10.1109/MS.2016.86},
issn = {07407459},
journal = {IEEE Software},
keywords = {DevOps,operational viewpoint,production,project management,software architecture,software development,software engineering},
number = {3},
title = {{Operational: The Forgotten Architectural View}},
volume = {33},
year = {2016}
}
@article{Woods2015a,
abstract = {{\textcopyright} 1984-2012 IEEE. The metaphor 'architecting in the gaps' can help software development teams clearly understand the software architect's role and how architecture contributes to a system's overall efficiency.},
author = {Woods, E.},
doi = {10.1109/MS.2015.98},
issn = {07407459},
journal = {IEEE Software},
keywords = {software architecture,software design,software development,software engineering},
number = {4},
title = {{Architecting in the Gaps: A Metaphor for Architecture Work}},
volume = {32},
year = {2015}
}
@article{Woods2016b,
abstract = {{\textcopyright} 2016 IEEE. As software systems have evolved, so has software architecture, with practices growing to meet each era's new challenges. The next phase of evolution - intelligent connected systems - promises to be an exciting time for software architects.},
author = {Woods, E.},
doi = {10.1109/MS.2016.149},
issn = {07407459},
journal = {IEEE Software},
keywords = {Internet of Things,artificial intelligence,cloud,history of computing,software architect,software development,software engineering},
number = {6},
title = {{Software Architecture in a Changing World}},
volume = {33},
year = {2016}
}
@article{Woods2016,
abstract = {{\textcopyright} 1984-2012 IEEE. Architecture principles epitomize architecture's function: to clearly define the necessary constraints on a system's design without prescriptively defining all the design details. A good set of principles can provide context and justification for design decisions and can foster team collaboration and communication.},
author = {Woods, E.},
doi = {10.1109/MS.2016.88},
issn = {07407459},
journal = {IEEE Software},
keywords = {design,project management,software architecture,software development,software engineering},
number = {4},
title = {{Harnessing the power of architectural design principles}},
volume = {33},
year = {2016}
}
@article{Woods2017a,
abstract = {{\textcopyright} 1984-2012 IEEE. Should the people performing a system's architecture work also develop some of the system's production code? Involving architects in carefully selected implementation tasks, such as testing, refactoring, or architectural spikes, can yield positive returns on investment for both the architects and their teams.},
author = {Woods, E.},
doi = {10.1109/MS.2017.3571574},
issn = {07407459},
journal = {IEEE Software},
keywords = {coding,software,software architecture,software development,software engineering},
number = {5},
title = {{Should Architects Code?}},
volume = {34},
year = {2017}
}
@inproceedings{woods2017-archeffort,
abstract = {As part of our software architecture research and practice we have found that a common difficulty for new architects is knowing where to focus their effort to maximise their effectiveness. This led us to wonder whether successful experienced architects have reusable heuristics or guidelines that they follow to help them prioritise their work. To investigate this we have performed a study using semi-structured interviews to explore how experienced software architects prioritise their activities in order to maximise their effectiveness. From the primary data collected through the interviews we have synthesised a simple model that organises and explains the heuristics that we found to be common across a number of experienced software architects.},
author = {Woods, Eoin and Bashroush, Rabih},
booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
doi = {10.1007/978-3-319-65831-5_13},
isbn = {9783319658308},
issn = {16113349},
keywords = {Software architect effectiveness,Software architecture,Software architecture decision making},
pages = {183--190},
title = {{A model for prioritization of software architecture effort}},
volume = {10475 LNCS},
year = {2017}
}
@article{bashroush2017-archprinciples,
abstract = {Optimizing the energy consumption of today's Internet-scale systems will require a radical approach that considers the whole system. To address system-level energy efficiency, software architects can follow three simple design principles. A case study illustrates the possible savings. {\textcopyright} 2017 IEEE.},
author = {Bashroush, Rabih and Woods, Eoin},
doi = {10.1109/MS.2017.60},
issn = {07407459},
journal = {IEEE Software},
keywords = {Internet,cloud,datacenters,eBay,energy,energy efficiency,green computing,software architect,software development,software engineering},
number = {3},
pages = {14--17},
title = {{Architectural Principles for Energy-Aware Internet-Scale Applications}},
volume = {34},
year = {2017}
}
@inproceedings{Longshaw2005a,
author = {Longshaw, A and Woods, E},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Longshaw, Woods - 2005 - More Patterns for the Generation , Handling and Management of Errors.pdf:pdf},
title = {{More patterns for the generation, handling and management of errors}},
url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-84871381481{\&}partnerID=MN8TOARS},
year = {2005}
}
@inproceedings{Garlan2008,
author = {Garlan, D and Woods, E and Kruchten, P},
doi = {10.1109/WICSA.2008.4},
title = {{7th IEEE/IFIP Working Conference on Software Architecture, WICSA 2008: Message from the conference chairs}},
url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-49949119146{\&}partnerID=MN8TOARS},
year = {2008}
}
@book{Woods2011a,
author = {Woods, Eoin},
isbn = {978-0321718334},
month = {oct},
title = {{Software Systems Architecture}},
url = {http://www.amazon.co.uk/Software-Systems-Architecture-Stakeholders-Perspectives/dp/032171833X},
year = {2011}
}
@book{Woods2012a,
abstract = {The architect takes a high-profile role in many IT departments today. In fact, it can be quite difficult in some organizations to find a senior member of IT technical staff whose job title does not include the word "architect." However there is little consensus in the academic community or amongst practitioners as to the responsibilities of the many different types of architect we encounter - or indeed, what they should even be called. In this chapter, the authors propose a simple, widely applicable taxonomy of architects, namely enterprise architects, application architects, and infrastructure architects. The authors define distinguishing characteristics, their responsibilities, the stakeholders with whom they engage, and the tools and techniques they use. The chapter shows how this taxonomy can be applied to most, if not all, practicing architects in the information systems domain, and explains how it helps us understand how such architects work together to help deliver the organization's business goals. {\textcopyright} 2013, IGI Global.},
author = {Woods, E. and Rozanski, N.},
booktitle = {Aligning Enterprise, System, and Software Architectures},
doi = {10.4018/978-1-4666-2199-2.ch001},
isbn = {9781466621992},
pages = {1--22},
title = {{Relating enterprise, application, and infrastructure architects}},
year = {2012}
}
@book{Bicarregui1996,
abstract = {{\textcopyright} Springer-Verlag Berlin Heidelberg 1996. This paper reports on the experience gained in the MaFMeth project, which undertook a formal development with tool support for several parts of the life cycle from requirements capture through to C code generation. We explore the hypotheses that formal methods enable the early detection of faults in design by examining the development process in the light of the stages at which faults were introduced and discovered.},
author = {Bicarregui, J. and Dick, J. and Woods, E.},
booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
isbn = {9783540609735},
issn = {16113349 03029743},
pages = {60--73},
title = {{Quantitative analysis of an application of formal methods}},
volume = {1051},
year = {1996}
}
@article{Dick1997,
abstract = {This article describes the rigorous application of formal methods of software development to a system software development project within a conventional industrial software development environment. This project applied formal methods to a small part (one subsystem) of the development of a release of a system software product. The formal methods VDM and B were used to specify, design and implement the administration subsystem of a product that was otherwise developed along conventional lines. Support tools were used to assist with the use of both methods throughout the development lifecycle. Metrics for effort and quality were collected from the project and compared with historical metrics for similar projects to allow the impact of formal methods on cost and quality to be assessed. This article briefly outlines the product being developed and the subsystem to which formal methods were applied. The environment in which this development was performed and the particular approach used are described. The results of this industrial application of formal methods and the lessons learned by the project are discussed at some length. {\textcopyright} 1997 Elsevier Science B. V.},
author = {Dick, J. and Woods, E.},
issn = {09505849},
journal = {Information and Software Technology},
keywords = {Formal method,Process improvement,Software development},
number = {8},
pages = {551--560},
title = {{Lessons learned from rigorous system software development}},
volume = {39},
year = {1997}
}
@article{woods2015-adlcasestudy,
abstract = {{\textcopyright} 2014 Elsevier Inc. All rights reserved. An organisation that had developed a large information system wanted to embark on a programme that would involve large-scale evolution of it. As a precursor to this, it was decided to create a comprehensive architectural description to capture and understand the system's design. This undertaking faced a number of challenges, including a low general awareness of software modelling and software architecture practices. The approach taken by the software architects tasked with this project included the definition of a simple, very specific, architecture description language. This paper reports our experience of the project and a simple ADL that we created as part of it.},
author = {Woods, E. and Bashroush, R.},
doi = {10.1016/j.jss.2014.09.018},
issn = {01641212},
journal = {Journal of Systems and Software},
keywords = {Architecture description language,Industrial experience report,Software architecture discovery},
pages = {97--108},
title = {{Modelling large-scale information systems using ADLs - An industrial experience report}},
volume = {99},
year = {2015}
}
@article{Woods2014,
abstract = {{\textcopyright} 1984-2012 IEEE. This column discusses architectural descriptions and the process of representing and communicating designs and how UML is useful when creating architectural descriptions.},
author = {Woods, E.},
doi = {10.1109/MS.2014.139},
issn = {07407459},
journal = {IEEE Software},
keywords = {UML,architecture,modeling,software engineering},
number = {6},
pages = {30--33},
title = {{Harnessing UML for architectural description-The context view}},
volume = {31},
year = {2014}
}
@inproceedings{woods2012-adlcasestudy,
abstract = {An organisation that had developed a large Information System wanted to embark on a programme of significant evolution for the system. As a precursor to this, it was decided to create a comprehensive architectural description. This undertaking faced a number of challenges, including a low general awareness of software modelling and software architecture practices. The approach taken for this project included the definition of a simple, specific, architecture description language. This paper describes the experiences of the project and the ADL created as part of it. {\textcopyright} 2012 IEEE.},
author = {Woods, E. and Bashroush, R.},
booktitle = {Proceedings of the 2012 Joint Working Conference on Software Architecture and 6th European Conference on Software Architecture, WICSA/ECSA 2012},
doi = {10.1109/WICSA-ECSA.212.37},
isbn = {9780769548272},
keywords = {ADL,Description Language,Industrial Experience Report,Software Architecture Discovery,Software Architecture for Legacy Systems},
pages = {239--243},
title = {{Using an architecture description language to model a large-scale information system - An industrial experience report}},
year = {2012}
}
@article{Woods1995,
abstract = {Although widely used, UML has some serious limitations as an architecture description language. {\textcopyright} 1995 IEEE},
author = {Woods, E. and Emery, D.},
doi = {10.1109/12.392855},
issn = {00189340},
journal = {IEEE Transactions on Computers},
number = {7},
pages = {947--951},
title = {{Is UML Sufficient for Describing Architectures?}},
volume = {44},
year = {1995}
}
@article{Woods2014a,
abstract = {Many types of architects work in the software industry, but when we consider the breadth of their work and their primary expertise, we find that they can be organized into three major groups: enterprise architects, application architects, and infrastructure architects. Knowing which group an architect falls into helps in understanding their expertise and what to expect of them. {\textcopyright} 2014 IEEE.},
author = {Woods, E.},
doi = {10.1109/MS.2014.69},
issn = {07407459},
journal = {IEEE Software},
keywords = {application,architecture,enterprise,infrastructure,pragmatic architect,software},
number = {3},
pages = {10--13},
title = {{Return of the pragmatic architect}},
volume = {31},
year = {2014}
}
@inproceedings{Tekinerdogan2011,
abstract = {This paper summarizes the workshop on Architecture-Based Testing and System Validation which was organized in conjunction with the 9th Working IEEE/IFIP Conference on Software Architecture. The main goal of the workshop was to bring together researchers and practitioners both from the architecture design and software testing community to enable architecture-based software testing. {\textcopyright} 2011 IEEE.},
author = {Tekinerdogan, B. and Clements, P. and Muccini, H. and Chaudron, M. and Polini, A. and Woods, E.},
booktitle = {Proceedings - 9th Working IEEE/IFIP Conference on Software Architecture, WICSA 2011},
doi = {10.1109/WICSA.2011.53},
isbn = {9780769543512},
keywords = {Architecture-Based Testing,Software Architecture,Software testing,System Validation},
pages = {341},
title = {{Architecture-based testing and system validation: Workshop summary}},
year = {2011}
}
@inproceedings{Baroni2014,
abstract = {A previous study, run by some of the authors in collaboration with practitioners, has emphasized the need to improve architectural languages in order to (i) make them simple and intuitive enough to communicate effectively with project stakeholders, and (ii) enable formality and rigour to allow analysis and other automated tasks. Although a multitude of languages have been created by researchers and practitioners, they rarely address both of these needs. In order to reconcile these divergent needs, this paper presents an approach that (i) combines the rigorous foundations of model-driven engineering with the usability of semantic wikis, and (ii) enables continuous syncronization between them, this allows software architects to simultaneously use wiki pages for communication and models for model-based analysis and manipulation. In this paper we explain how we applied the approach to an industry-inspired case study using the Semantic Media Wiki wiki engine and a model-driven architecture description implemented within the Eclipse Modeling Framework. We also discuss how our approach can be generalized to other wiki-based and model-driven technologies. {\textcopyright} 2014 IEEE.},
author = {Baroni, A. and Muccini, H. and Malavolta, I. and Woods, E.},
booktitle = {Proceedings - Working IEEE/IFIP Conference on Software Architecture 2014, WICSA 2014},
doi = {10.1109/WICSA.2014.21},
isbn = {9781479934126},
keywords = {Architecture Description,Model-Driven Engineering,Wikis},
pages = {251--254},
title = {{Architecture description leveraging model driven engineering and semantic wikis}},
year = {2014}
}
@book{Woods2004,
abstract = {There has recently been an increase in interest, among information systems architecture practitioners, in using viewpoints for architectural definition and description. This has been caused by a number of factors including the publication of IEEE standard 1471 and the increasing adoption of RUP (and its "4+1" viewpoint set). This short experience report outlines the experiences that two software architects have had in evaluating and applying a number of viewpoint sets to information systems development. The strengths and weaknesses found with each viewpoint set are described and some general observations on viewpoint set use and definition are presented. {\textcopyright} Springer-Verlag 2004.},
author = {Woods, E.},
booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
issn = {03029743 16113349},
pages = {182--193},
title = {{Experiences using viewpoints for information systems architecture: An industrial experience report}},
volume = {3047},
year = {2004}
}
@article{Bicarregui1997,
abstract = {The use of formality in software development enables formal manipulation at the symbolic level and hence can yield new perspectives on the design which can be submitted to inspection and interactive or automatic analysis. We describe the experience of an industrial pilot project which undertook a formal development using VDM and B and employed a number of techniques for the analysis of the formal texts by animation, test case generation and proof. We assess the effectiveness of methodology and techniques adopted by measuring the introduction and detection of faults. {\textcopyright} 1997 Elsevier Science B.V.},
author = {Bicarregui, J. and Dick, J. and Matthews, B. and Woods, E.},
issn = {01676423},
journal = {Science of Computer Programming},
keywords = {Animation,B,Formal methods,Formal specification,Proof,Test case generation,Testing,VDM},
number = {1-2},
pages = {53--78},
title = {{Making the most of formal specification through animation, testing and proof}},
volume = {29},
year = {1997}
}
@article{Woods2015,
abstract = {{\textcopyright} 1984-2012 IEEE. Difficulties frequently arise when agile development teams and software architects work together. By adopting practices aligned with the 'agile manifesto,' software architects can work constructively with agile teams and significantly contribute to a project's success.},
author = {Woods, E.},
doi = {10.1109/MS.2015.119},
issn = {07407459},
journal = {IEEE Software},
keywords = {agile teams,software architecture,software design,software development,software engineering},
number = {5},
pages = {24--26},
title = {{Aligning Architecture Work with Agile Teams}},
volume = {32},
year = {2015}
}
@article{Woods2010a,
abstract = {UML, used to capture class and component structures, data models, and other aspects of software behavior, is assessed for its use in describing software architecture. UML does not allow architects to describe the constructs that they commonly use to design software-intensive systems and does not express various concerns that architects must take into account. UML needs to have first-class support for describing servers, clients, runtime containers, message buses, and services. Other important features missing from UML include concurrency primitives and error handling, which is one of the most important considerations for many software systems is the ability to detect and recover from errors. UML establishes a resource budget for a component or subsystem, a common technique for performance management.},
author = {Woods, E. and Emery, D.},
doi = {10.1109/MS.2010.145},
issn = {07407459},
journal = {IEEE Software},
keywords = {UML,Unified Modeling Language,software development,stakeholders},
number = {6},
pages = {54+56},
title = {{Is UML sufficient for describing architectures?}},
volume = {27},
year = {2010}
}
@inproceedings{Longshaw2005,
abstract = {As systems become more complex it is increasingly difficult to anticipate and handle error conditions in a system. The developers of the system must ensure that errors do not cause problems for the users of the system. In a previous paper [Longshaw 2004] a collection of patterns for such distributed error handling was explored. As this collection was refined, two new patterns emerged: Hide Technical Details from Users and Unique Error Identifier. This paper retains the same context and but is focused on obtaining feedback specifically on these new additions.},
address = {Irsee, Germany},
author = {Longshaw, Andy and Woods, Eoin},
booktitle = {Tenth European Conference on Pattern Languages of Programs (EuroPLoP 2005)},
editor = {Longshaw, Andy and Zdun, Uwe},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Longshaw, Woods - 2005 - More Patterns for the Generation , Handling and Management of Errors.pdf:pdf},
pages = {517--530},
publisher = {UVK - Universitaetsverlag Konstanz},
title = {{More Patterns for the Generation , Handling and Management of Errors}},
year = {2005}
}
@inproceedings{Woods2009,
abstract = {A common requirement when describing the architecture of a software system is the ability to define the environment of a system, in terms of its external dependencies. In a view-based architectural description approach (such as “4+1” or “Rozanski and Woods”) this need is met by adding a Context view containing this information to the architectural description and ideally defining a corresponding Context viewpoint to guide and standardise such views. This short paper explains the benefits of adding a Context view to architectural descriptions and provides an outline definition of the corresponding viewpoint to explain their content and how they are developed.},
address = {Cambridge},
author = {Woods, Eoin and Rozanski, Nick},
booktitle = {2009 Joint Working IEEE/IFIP Conference on Software Architecture {\&} European Conference on Software Architecture (WICSA2009)},
doi = {10.1109/WICSA.2009.5290673},
editor = {Oquendo, Flavio and Poort, Eltjo and Stafford, Judith},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Woods, Rozanski - 2009 - The system context architectural viewpoint.pdf:pdf},
isbn = {978-1-4244-4984-2},
month = {sep},
pages = {333--336},
publisher = {IEEE},
title = {{The system context architectural viewpoint}},
url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=5290673},
year = {2009}
}
@inproceedings{woods2005-perspectives,
abstract = {A crucial aspect of the software architect's role is to ensure that a system based on their architecture will exhibit the quality properties (performance, security, availability and so on) that are important to their stakeholders. A proven approach to help guide an architect through the process of designing an architecture is to use architectural views, based on formal viewpoint definitions (such as those in the well known "4+1" set). However, a practical problem we have found when using existing viewpoint sets is the lack of guidance relating to system qualities (as opposed to system structures) that they provide. To address this problem, we identified a complimentary concept, called the architectural perspective [15], to provide an architect with practical guidance as to how to ensure that their system exhibits the right set of quality properties. This paper reviews the idea of the architectural perspective and relates a specific experience of applying them to the architectural definition of an enterprise integration project for a financial markets organisation, explaining the strengths and weaknesses we found in the approach.},
address = {Pittsburgh, PA, USA},
author = {Woods, Eoin and Rozanski, Nick},
booktitle = {5th Working IEEE/IFIP Conference on Software Architecture (WICSA'05)},
doi = {10.1109/WICSA.2005.74},
editor = {Nord, Robert and Medvidovic, Nenad and Krikhaar, Ren{\'{e}} and Stafford, Judith and Bosch, Jan},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Woods, Rozanski - 2005 - Using Architectural Perspectives.pdf:pdf},
isbn = {0-7695-2548-2},
pages = {25--35},
publisher = {IEEE},
title = {{Using Architectural Perspectives}},
year = {2005}
}
@article{Woods2012,
abstract = {Scenario based architectural assessment is a well-established approach for assessing architectural designs. However scenario-based methods are not always usable in an industrial context, where in our experience, they can be perceived as complicated and expensive to use. In this paper we explore why this may be the case and define a simpler technique called TARA, which has been designed for use in situations where scenario based methods are unlikely to be successful. The method is illustrated through an experience report that explains how it was applied to the assessment of two quantitative financial analysis systems, and its strengths, weaknesses and relationship to other methods are briefly discussed.},
author = {Woods, Eoin},
doi = {10.1016/j.jss.2012.04.055},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Woods - 2012 - Industrial architectural assessment using TARA.pdf:pdf},
issn = {01641212},
journal = {Journal of Systems and Software},
keywords = {assessment methods,case study,software architecture},
month = {sep},
number = {9},
pages = {2034--2047},
title = {{Industrial architectural assessment using TARA}},
url = {http://linkinghub.elsevier.com/retrieve/pii/S0164121212001264},
volume = {85},
year = {2012}
}
@incollection{Woods2011,
abstract = {Historically a system's requirements and its architectural design have been viewed as having a simple relationship where the requirements drove the architecture and the architecture was designed in order to meet the requirements. In contrast, our experience is that a much more dynamic relationship can be achieved between these key activities within the system design lifecycle, that allows the architecture to constrain the requirements to an achievable set of possibilities, frame the requirements making their implications clearer, and inspire new requirements from the capabilities of the system's architecture. In this article, we describe this relationship, illustrate it with a case study drawn from our experience and present some lessons learned that we believe will be valuable for other software architects.},
address = {Berlin, Heidelberg},
author = {Woods, Eoin and Rozanski, Nick},
booktitle = {Relating Software Requirements and Architectures},
doi = {10.1007/978-3-642-21001-3},
editor = {Avgeriou, Paris and Grundy, John and Hall, Jon G. and Lago, Patricia and Mistr{\'{i}}k, Ivan},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Woods, Rozanski - 2011 - How Software Architecture can Frame, Constrain and Inspire System Requirements.pdf:pdf},
isbn = {978-3-642-21000-6},
pages = {333--352},
publisher = {Springer Berlin Heidelberg},
title = {{How Software Architecture can Frame, Constrain and Inspire System Requirements}},
url = {http://www.springerlink.com/index/10.1007/978-3-642-21001-3},
year = {2011}
}
@inproceedings{Longshaw2004,
abstract = {As systems become more complex it is increasingly difficult to anticipate and handle error conditions in a system. The developers of the system must ensure that errors do not cause problems for the users of the system. To do so, they should Keep Exceptions Exceptional, Hide Technical Details from Users and encapsulate the system in a Big Outer Try Block. The administrators must be informed when an error occurs and must be given sufficient information about what happened, where it happened and why it happened. If a system has Split Domain and Technical Errors and its components only Log Unexpected Errors then the level of error information can stay manageable. If distributed systems Log at Distribution Boundaries then the overall error information in the system can be reduced and the consequences of individual errors can be tied together using a Unique Error Identifier},
address = {Irsee, Germany},
author = {Longshaw, Andy and Woods, Eoin},
booktitle = {9th European Conference on Pattern Languages of Programms (EuroPLoP 2004)},
editor = {Marquardt, Klaus and Sch{\"{u}}tz, Dietmar},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Longshaw, Woods - 2004 - Patterns for Generation, Handling and Management of Errors.pdf:pdf},
pages = {27--52},
publisher = {UVK - Universitaetsverlag Konstanz},
title = {{Patterns for Generation, Handling and Management of Errors}},
url = {http://www.blueskyline.com/ErrorPatterns/ErrorPatternsPaper.pdf},
year = {2004}
}
@inproceedings{woodshilliard2005-adlsinpractice,
abstract = {This short document reports the content and results of the "Architecture Description Languages in Practice" working group held on 9th and 10th November 2005 at the WICSA 5 conference, in Pittsburgh, Pennsylvania, USA.},
address = {Pittsburgh, PA, USA},
author = {Woods, Eoin and Hilliard, Rich},
booktitle = {5th Working IEEE/IFIP Conference on Software Architecture (WICSA'05)},
doi = {10.1109/WICSA.2005.15},
editor = {Nord, Robert and Medvidovic, Nenad and Krikhaar, Ren{\'{e}} and Stafford, Judith and Bosch, Jan},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Woods, Hilliard - 2005 - Architecture Description Languages in Practice Session Report.pdf:pdf},
isbn = {0-7695-2548-2},
pages = {243--246},
publisher = {IEEE},
title = {{Architecture Description Languages in Practice Session Report}},
year = {2005}
}
@unpublished{woods2005-adlandarchs,
author = {Woods, Eoin},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Woods - 2005 - Architecture Description Languages and Information Systems Architects Never the Twain Shall Meet.pdf:pdf},
institution = {IFIP Working Group 2.10 on Software Architecture},
title = {{Architecture Description Languages and Information Systems Architects : Never the Twain Shall Meet ?}},
year = {2005}
}
@inproceedings{Woods2010,
abstract = {This paper proposes a research challenge to narrow the gap between the architecture and implementation of a software system. We discuss the situation today, where little of a system's architecture and design is directly represented in the source code of its implementation and explore why this is a problem and the benefits that might flow from narrowing this gap. We then discuss how the situation could be improved by the creation of technologies that allow the design and architecture of a system to be directly related to its source code and outline the requirements that we believe that any such technology would need to fulfill. Finally, we consider the likely results of widespread application of such a technology and the benefits that would follow.},
address = {Copenhagen},
author = {Woods, Eoin and Rozanski, Nick},
booktitle = {Fourth European Conference on Software Architecture Companion Volume - ECSA '10},
doi = {10.1145/1842752.1842767},
editor = {Babar, M. Ali and Gorton, Ian},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Woods, Rozanski - 2010 - Unifying software architecture with its implementation.pdf:pdf},
isbn = {9781450301794},
pages = {55--58},
publisher = {ACM Press},
title = {{Unifying software architecture with its implementation}},
url = {http://portal.acm.org/citation.cfm?doid=1842752.1842767},
year = {2010}
}
@article{Mouratidis2010,
author = {Mouratidis, Haralambos and Kolp, Manuel and Giorgini, Paolo and Faulkner, Stephane},
doi = {10.3233/WIA-2010-0182},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Unknown - 2010 - An Architectural Description Language for Secure Multi-Agent Systems.pdf:pdf},
issn = {1570-1263},
journal = {Web Intelligence and Agent Systems},
keywords = {Architectural Description Language,BDI agent model,Multi-Agent Systems,security,software architecture},
month = {jan},
number = {1},
pages = {99--122},
title = {{An architectural description language for secure Multi-Agent Systems}},
volume = {8},
year = {2010}
}
@article{Allen1996,
author = {Allen, Robert and Garlan, David},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Allen, Garlan - 1996 - A Case Study in Architectural Modelling The AEGIS System.pdf:pdf},
isbn = {0-8186-7361-3},
month = {mar},
pages = {6},
title = {{A Case Study in Architectural Modelling: The AEGIS System}},
year = {1996}
}
@inproceedings{Gorlick,
author = {Gorlick, M. and Quilici, A.},
booktitle = {Proceedings of 1994 IEEE Symposium on Visual Languages},
doi = {10.1109/VL.1994.363631},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Gorlick, Quilici - 1994 - Visual programming-in-the-large versus visual programming-in-the-small.pdf:pdf},
isbn = {0-8186-6660-9},
keywords = {Aerospace electronics,Aerospace testing,Automatic testing,Documentation,Error correction,Information analysis,Instruments,Programming environments,Software engineering,System testing,arbitrary objects,automatic component discovery,hierarchically organized networks,intelligent error correction,interconnected components,scaling problems,visual languages,visual mechanism,visual programming,visual programming research,visual programming-in-the-large,visual programming-in-the-small,visual software engineering environment,zooming},
language = {English},
pages = {137--144},
publisher = {IEEE Comput. Soc. Press},
title = {{Visual programming-in-the-large versus visual programming-in-the-small}},
url = {http://ieeexplore.ieee.org/xpls/abs{\_}all.jsp?arnumber=363631' escapeXml='false'/{\%}3E}
}
@inproceedings{boucke2007-xadl,
abstract = {Experience with building an architecture for an industrial Automatic Guided Vehicle Transportation System (AGVTS) shows that several essential concerns crosscut the architectural views. To cope with this, a stronger separation proved to be necessary, i.e. using different views for different concerns. In practice this was difficult, since the support for relations between views is very limited. This makes separation of concerns in views hard, thereby increasing maintenance overhead and reducing reuse capabilities. Our claim is that specifying compositions of views is as important as specifying the views itself. This paper extends a representative architectural description language (xADL) which support for composing structural views, by introducing three relations, namely refinement, mapping, and unification. Improving separation of concerns in views and their explicit composition enhances architecture understandability and changeability. The feasibility of the relations is assessed by redesigning the AGVTS architecture. Based on a real maintenance scenario, we investigate to what extent these explicit compositions lead (or not) to enhanced architectural changeability for evolving the distribution strategy in the AGVTS system.},
address = {Vancouver, Canada},
author = {Bouck{\'{e}}, N and Garcia, A and Holvoet, T},
booktitle = {10th international conference on Early aspects: current challenges and future directions, LNCS 4765},
editor = {Moreira, Ana and Grundy, John},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Bouck{\'{e}}, Garcia, Holvoet - 2007 - Composing Structural Views in xADL.pdf:pdf},
pages = {115--138},
publisher = {Springer-Verlag},
title = {{Composing Structural Views in xADL}},
year = {2007}
}
@inproceedings{allen1996-aegis,
abstract = {Software architecture is receiving increasingly attention as a critical design level for software systems. However, the current practice of architectural description is largely informal and ad hoc, with the consequence that architectural documents serve as a poor communication mechanism, are difficult to analyze, and may have very little relationship to the implemented system. In an attempt to address these problems several researchers have experimented with formalisms for architectural specification and modelling. One such formalism is WRIGHT. In this paper we show how WRIGHT can be used to provide insight into an architectural design by modelling a prototype implementation of part of the AEGIS Weapons System.},
author = {Allen, Robert and Garlan, D},
booktitle = {8th International Workshop on Software Specification and Design (IWSSD 96)},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Allen, Garlan - 1996 - A Case Study in Architectural Modelling The AEGIS System.pdf:pdf},
number = {March},
pages = {6--15},
title = {{A Case Study in Architectural Modelling : The AEGIS System}},
year = {1996}
}
@phdthesis{Coyette2003,
author = {Coyette, Adrien},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Coyette - 2003 - The SkwyRL-Agent Architectural Framework Developing An E-Business Application.pdf:pdf},
pages = {143},
school = {UNIVERSITE CATHOLIQUE DE LOUVAIN},
title = {{The SkwyRL-Agent Architectural Framework : Developing An E-Business Application}},
type = {BSc (Licenci{\'{e}} en Sciences des Gestion)},
year = {2003}
}
@article{mouratidis2010-skwyrladl,
abstract = {Multi-Agent Systems (MAS) architectures are gaining popularity for building open, distributed, and evolving information systems. Unfortunately, despite considerable work in the fields of software architecture and MAS during the last decade, few research efforts have aimed at defining languages for designing and formalising secure agent architectures. This paper proposes a novel Architectural Description Language (ADL) for describing Belief-Desire-Intention (BDI) secure MAS. We specify each element of our ADL using the Z specification language and we employ two example case studies: one to assist us in the description of the proposed language and help readers of the article to better understand the fundamentals of the language; and one to demonstrate its applicability.},
author = {Mouratidis, Haralambos and Kolp, Manuel and Giorgini, Paolo and Faulkner, Stephane},
doi = {10.3233/WIA-2010-0182},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Unknown - 2010 - An Architectural Description Language for Secure Multi-Agent Systems.pdf:pdf},
issn = {1570-1263},
journal = {Web Intelligence and Agent Systems},
keywords = {BDI agent model,Multi-Agent Systems,architectural description language,security,software architecture},
month = {jan},
number = {1},
pages = {99--122},
title = {{An architectural description language for secure Multi-Agent Systems}},
volume = {8},
year = {2010}
}
@misc{coyette-skwrladl,
author = {Coyette, Adrien and Do, Tung and Faulkner, St{\'{e}}phane and Kolp, Manuel},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Coyette et al. - Unknown - SKwyRL Social Architectures for Agent Software Engineering.pdf:pdf},
keywords = {presentation-slides},
title = {{SKwyRL : Social Architectures for Agent Software Engineering}}
}
@phdthesis{klein2000-model,
abstract = {This dissertation is devoted to the topic of architecture modeling for software systems. The architecture describes the structural composition of a system from components and relation- ships between these components. Thereby, it provides a basis for the system's realization on technical as well as on organizational level.},
author = {Klein, Peter},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Klein - 2000 - Architecture Modeling of Distributed and Concurrent Software Systems.pdf:pdf},
school = {heinisch-Westfälischen Technischen Hochschule Aachen},
title = {{Architecture Modeling of Distributed and Concurrent Software Systems}},
type = {PhD},
volume = {82},
year = {2000}
}
@inproceedings{desilva2011-rationale,
abstract = {Besides structural and behavioural properties, rationale plays a crucial role in defining the architecture of a software system. However, unlike other architectural features, rationale often remains unspecified and inaccessible to tools. Existing approaches for recording rationale are not widely adopted. This paper proposes a simple model for capturing rationales as part of an architecture specification and attaching them to elements in the architecture. The bi-directional links between rationales and elements enable forward and backward traceability. We describe a textual architecture description language named Grasp that implements this model, and illustrate its capabilities using an example.},
annote = {10.1007/978-3-642-23798-0{\_}34},
author = {de Silva, Lakshitha and Balasubramaniam, Dharini},
booktitle = {5th European Conferene on Software Architecture (ECSA 2011), LNCS 6903},
doi = {10.1007/978-3-642-23798-0_34},
editor = {Crnkovic, Ivica and Gruhn, Volker and Book, Matthias},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/de Silva, Balasubramaniam - 2011 - A Model for Specifying Rationale Using an Architecture Description Language.pdf:pdf},
isbn = {978-3-642-23797-3},
pages = {319--327},
publisher = {Springer Berlin / Heidelberg},
series = {Lecture Notes in Computer Science},
title = {{A Model for Specifying Rationale Using an Architecture Description Language}},
volume = {6903},
year = {2011}
}
@phdthesis{desilva2009-oslo,
abstract = {The architecture of a software system is crucial for studying the behaviour of the system and analysing the impact of changes made to the software. Besides descriptions of the structural organization of the system, an architecture also includes rationale for the various design choices made while constructing the system. Architecture rationale helps understand the intent of its designers which is imperative for maintaining the system. However, unlike the structural aspects of a software system, architecture rationale is often undocumented or inaccessible to tools. A number of formal approaches have been proposed to capture rationale though none have been widely adopted due their complexity. This work presents an approach to capture architecture rationale as part of the architecture modelling process. A conceptual framework was developed to associate design rationale to structural elements of an architecture. The framework models a bi- directional association between design rationale and architecture elements that provides forward and backward traceability. Consequently, an architecture description language (ADL) based on the conceptual framework was designed using the M-Grammar notation available as part of the Microsoft ―Oslo‖ Platform. A compiler that validates and executes architectures specified using the new ADL was developed along with a visualizer tool to renders an architecture using graphical notations. Finally, we evaluated the effectiveness of the conceptual model and the ADL for capturing architecture rationale. The expressiveness of the M-Grammar notation was also evaluated as part of this work.},
author = {Silva, Lakshitha De},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Silva - 2009 - A Rationale-based Architecture Description Language using the “ Oslo ” Modelling Platform.pdf:pdf},
number = {August},
pages = {62},
school = {University of St Andrews},
title = {{A Rationale-based Architecture Description Language using the “ Oslo ” Modelling Platform}},
year = {2009}
}
@article{loques2004,
abstract = {This paper presents a comprehensive approach to describe, deploy and adapt component-based applications having dynamic non-functional requirements. The approach is centered on high-level contracts associated to architectural descriptions, which allow the non-functional requirements to be handled separately during the system design process. This helps to achieve separation of concerns facilitating the reuse of modules that implement the application in other systems. Besides specifying non-functional requirements, contracts are used at runtime to guide configuration adaptations required to enforce these requirements. The infrastructure required to manage the contracts follows an architectural pattern, which can be directly mapped to specific components included in a support- ing reflective middleware. This allows designers to write a contract and to follow standard recipes to insert the extra code required to its enforcement in the supporting middleware.},
author = {Loques, Orlando and Sztajnberg, Alexandre and Curty, Romulo and Ansaloni, Sidney},
doi = {10.1007/BF03192350},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Loques et al. - 2004 - A contract-based approach to describe and deploy non-functional adaptations in software architectures.pdf:pdf},
issn = {0104-6500},
journal = {Journal of the Brazilian Computer Society},
keywords = {contracts,dynamic configuration adaptation,middleware,non-functional requirements,separation of concerns,software architectures},
month = {feb},
number = {1},
pages = {5--20},
title = {{A contract-based approach to describe and deploy non-functional adaptations in software architectures}},
volume = {10},
year = {2004}
}
@inproceedings{zhang2009-xyzadl,
abstract = {Web services are emerged as a popular application for implementing large-scale distributed, reactive systems. Web service composition is the hotspot research in the field of Web services. Because the validity is a key requirement in the description of Web service composition, a formal language XYZ/ADL is introduced which describe the composition from the view of architecture. In this paper, we define a mapping from XYZ/ADL to a more practical approach of Web service composition BPEL4WS which is difficult to verify the validity of the composition. First, define the conversion of XYZ/E to BPEL4WS, analyze the similarity between the design elements in XYZ/ADL and activities in BPEL4WS, and then do the conversion of XYZ/ADL to BPEL4WS.},
address = {Xiamen},
author = {Zhang, Guang-quan and Rong, Mei and Wei, Hui},
booktitle = {2009 WRI World Congress on Software Engineering (WCSE09)},
doi = {10.1109/WCSE.2009.389},
file = {:Users/eoin/Dropbox/Work/PhDWork/ADL-LitReview/ADL-Papers/ZYZADL-Zhang-WS-Composition.pdf:pdf},
isbn = {978-0-7695-3570-8},
keywords = {web service composition,web services},
pages = {185--188},
publisher = {IEEE},
title = {{Description and Analysis for Web Service Composition Based on XYZ/ADL}},
year = {2009}
}
@inproceedings{zhang2011-mismatchdetection,
abstract = {The behaviour mismatch analysis is absolutely necessary for guaranteeing the correct composition of web services. In order to improve the reliability of the Web service composition, we present a mismatch detection method which can capture incompatible behavior and timed conflict among multiple asynchronous services. In this paper, we use software architecture description language XYZ/ADL based on temporal logic to describe Web service composition and use XYZ/RE to express the relative timed constraints. Additionally, we also set up a timed asynchronous service model TASM which can depict asynchronous interacting behavior and timed properties. In particular, the model satisfies the specification of model check UPPAAL. We convert XYZ/ADL description to TASM, and give the definition of compatibility. Then we use UPPAAL to realize mismatch detection of asynchronous Web services. Finally an example is demonstrated to illustrate how the approach we proposed works.},
address = {Jeju Island},
author = {Zhang, Guang-quan and Shi, Hui-juan and Rong, Mei},
booktitle = {2011 IEEE Asia-Pacific Services Computing Conference},
doi = {10.1109/APSCC.2011.44},
editor = {Lee, Changhoon and Hsu, Robert C. H. and Zhang, Jia},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Zhang, Shi, Rong - 2011 - Mismatch Detection of Asynchronous Web Services with Timed Constraints.pdf:pdf},
isbn = {978-1-4673-0206-7},
keywords = {asynchronous web services,mismatch detection,timed constraints,uppaal,xyz},
month = {dec},
number = {1},
pages = {251--258},
publisher = {IEEE},
title = {{Mismatch Detection of Asynchronous Web Services with Timed Constraints}},
year = {2011}
}
@article{zhu2003-xyzadl,
abstract = {The architecture description language (ADL) is the foundation of software development based on software architecture. An ADL supporting stepwise refinement can make it more convenient that a good design leads to a good implementation. The architecture description language XYZ/ADL can support the stepwise transition from higher-level architectures to lower-level architectures, because it is based on the temporal logic language (TLL) XYZ/E, which can represent both dynamic semantics and static semantics under a unified logical framework. In this paper, the framework and syntax of XYZ/ADL is presented and its underlying semantics is explained using XYZ/E, and how to describe software architecture and software architecture style using XYZ/ADL is introduced.},
author = {Zhu, Xue-Yang and Tang, Zhi-Song},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Zhu, Tang - 2003 - A temporal logic- based software architecture description language XYZADL.pdf:pdf},
journal = {Journal of Software},
keywords = {architecture description language,chinese-language,software architecture,specification,temporal logic language XYZ/E},
mendeley-tags = {chinese-language},
number = {4},
pages = {713--720},
title = {{A temporal logic- based software architecture description language XYZ/ADL}},
volume = {14},
year = {2003}
}
@techreport{Zhu,
abstract = {The architecture description language (ADL) is the foundation of software development based on software architecture. It is desirable that an ADL can represent both high-level abstract specification and the concrete implementation, thereby provides premise for the smooth transition from specification to implementation. In this aspect, the ADL XYZ/ADL has its built-in advantage, because it is based on the temporal logic language XYZ/E, which can represent both dynamic semantics and static semantics of systems with a unified logical framework. In this paper, the concept framework and syntax of XYZ/ADL is presented and its underlying semantic is explained using XYZ/E, and how to describe software architecture using XYZ/ADL is illustrated.},
author = {Zhu, Xue-Yang and Tang, Zhi-Song},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Zhu, Tang - Unknown - Formalising Software Architecture Description with Temporal Logic.pdf:pdf},
keywords = {Software architecture,XYZ/E,architecture description language,specification,temporal logic},
number = {2},
title = {{Formalising Software Architecture Description with Temporal Logic}}
}
@inproceedings{dashofy2002-xadlinfa,
abstract = {Research and experimentation in software architectures over the past decade have yielded a plethora of software architecture description languages (ADLs). Continuing innovation indicates that it is reasonable to expect more new ADLs, or at least ADL features. This research process is impeded by the difficulty and cost associated with developing new notations. An architect in need of a unique set of modeling features must either develop a new architecture description language from scratch or undertake the daunting task of modifying an existing language. In either case, it is unavoidable that a significant effort will be expended in building or adapting tools to support the language. To remedy this situation, we have developed an infrastructure for the rapid development of new architecture description languages. Key aspects of the infrastructure are its XML-based modular extension mechanism, its base set of reusable and customizable architectural modeling constructs, and its equally important set of flexible support tools. This paper introduces the infrastructure and demonstrates its value in the context of several real-world applications.},
author = {Dashofy, Eric M and Taylor, Richard N},
booktitle = {24th International Conference on Software Engineering (ICSE2002)},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Dashofy, Taylor - 2002 - An Infrastructure for the Rapid Development of XML-based Architecture Description Languages.pdf:pdf},
pages = {266--276},
publisher = {ACM Press},
title = {{An Infrastructure for the Rapid Development of XML-based Architecture Description Languages}},
year = {2002}
}
@inproceedings{dashofy2001-xadl,
abstract = {Software architecture research focuses on models of software architectures as specified in architecture description languages (ADLs). As research progresses in specific areas of software architectures, more and more architectural information is created. Ideally, this information can be stored in the model. An extensible modeling language is crucial to experimenting with and building tools for novel modeling constructs that arise from evolving research. Traditional ADLs typically support a small set of modeling constructs very well, but adapt to others poorly. XML provides an ideal platform upon which to develop an extensible modeling language for software architectures. Previous XML-based ADLs successfully leveraged XML's large base of off-the-shelf tool support, but did not take advantage of its extensibility. To give software architecture researchers more freedom to explore new possibilities and modeling techniques, while maximizing reuse of tools and modeling constructs, we have developed xADL 2.0, a highly extensible XML-based ADL. xADL 2.0 supports run-time and design time modeling, architecture configuration management and model-based system instantiation. Additionally, xADL 2.0 has a set of extensible infrastructure tools that support the creation, manipulation, and sharing of xADL 2.0 documents},
author = {Dashofy, E.M. and van der Hoek, A. and Taylor, R.N.},
booktitle = {2001 Working IEEE/IFIP Conference on Software Architecture (WICSA 2001)},
doi = {10.1109/WICSA.2001.948416},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Dashofy, van der Hoek, Taylor - 2001 - A highly-extensible, XML-based architecture description language.pdf:pdf},
isbn = {0-7695-1360-3},
pages = {103--112},
publisher = {IEEE Comput. Soc},
title = {{A highly-extensible, XML-based architecture description language}},
year = {2001}
}
@article{dashofy2005-xadl,
abstract = {Research over the past decade has revealed that modeling software architecture at the level of components and connectors is useful in a growing variety of contexts. This has led to the development of a plethora of notations for representing software architectures, each focusing on different aspects of the systems being modeled. In general, these notations have been developed without regard to reuse or extension. This makes the effort in adapting an existing notation to a new purpose commensurate with developing a new notation from scratch. To address this problem, we have developed an approach that allows for the rapid construction of new architecture description languages (ADLs). Our approach is unique because it encapsulates ADL features in modules that are composed to form ADLs. We achieve this by leveraging the extension mechanisms provided by XML and XML schemas. We have defined a set of generic, reusable ADL modules called xADL 2.0, useful as an ADL by itself, but also extensible to support new applications and domains. To support this extensibility, we have developed a set of reflective syntax-based tools that adapt to language changes automatically, as well as several semantically-aware tools that provide support for advanced features of xADL 2.0. We demonstrate the effectiveness, scalability, and flexibility of our approach through a diverse set of experiences. First, our approach has been applied in industrial contexts, modeling software architectures for aircraft software and spacecraft systems. Second, we show how xADL 2.0 can be extended to support the modeling features found in two different representations for modeling product-line architectures. Finally, we show how our infrastructure has been used to support its own development. The technical contribution of our infrastructure is augmented by several research contributions: the first decomposition of an architecture description language into modules, insights about how to develop new language modules and a process for integrating them, and insights about the roles of different kinds of tools in a modular ADL-based infrastructure.},
author = {Dashofy, Eric M and van der Hoek, Andr{\'{e}} and Taylor, Richard N},
doi = {10.1145/1061254.1061258},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Dashofy, Hoek, Taylor - 2005 - A comprehensive approach for the development of modular software architecture description languages.pdf:pdf},
issn = {1049331X},
journal = {ACM Transactions on Software Engineering and Methodology},
month = {apr},
number = {2},
pages = {199--245},
title = {{A comprehensive approach for the development of modular software architecture description languages}},
volume = {14},
year = {2005}
}
@article{allen1997-formalconn,
abstract = {As software systems become more complex, the overall system structure—or software architecture—becomes a central design problem. An important step toward an engineering discipline of software is a formal basis for describing and analyzing these designs. In the article we present a formal approach to one aspect of architectural design: the interactions among components. The key idea is to define architectural connectors as explicit semantic entities. These are specified as a collection of protocols that characterize each of the participant roles in an interaction and how these roles interact. We illustrate how this scheme can be used to define a variety of common architectural connectors. We further provide a formal semantics and show how this leads to a system in which architectural compatibility can be checked in a way analogous to type-checking in programming languages.},
author = {Allen, Robert and Garlan, David},
doi = {10.1145/258077.258078},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Allen, Garlan - 1997 - A formal basis for architectural connection.pdf:pdf},
issn = {1049331X},
journal = {ACM Transactions on Software Engineering and Methodology},
month = {jul},
number = {3},
pages = {213--249},
title = {{A formal basis for architectural connection}},
volume = {6},
year = {1997}
}
@phdthesis{allen1997-wright,
abstract = {As software systems become more complex, the overall system structure—or software architecture—becomes a central design problem. A system's architecture provides a model of the system that suppresses implementation detail, allowing the architect to concentrate on the analyses and decisions that are most crucial to structuring the system to satisfy its requirements. Unfortunately, current representations of software architecture are informal and ad hoc. While architectural concepts are often embodied in infrastructure to support specific architectural styles and in the initial conceptualization of a system configuration, the lack of an explicit, independently-characterized architecture or architectural style significantly limits the benefits of software architectural design in current practice. In this dissertation, I show that an Architecture Description Language based on a formal, abstract model of system behavior can provide a practical means of describing and analyzing software architectures and architectural styles. This dissertation demonstrates this claim through WRIGHT, an architectural description language based on the formal description of the abstract behavior of architectural com- ponents and connectors. WRIGHT provides a practical formal basis for the description of both architectural configurations and of architectural styles. It is distinguished by the use of explicit, independent connector types as interaction patterns, the ability to describe the abstract behavior of components using a CSP-like notation, the characterization of styles using predicates over system instances, and a collection of static checks to determine the consistency and completeness of an architectural specification. We introduce techniques to support the analysis of large-scale systems, and demonstrate WRIGHT's expressiveness and practicality through three case studies.},
author = {Allen, Robert J.},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Allen - 1997 - A Formal Approach to Software Architecture.pdf:pdf},
number = {May},
pages = {248},
school = {Carnegie Mellon University},
title = {{A Formal Approach to Software Architecture}},
year = {1997}
}
@inproceedings{Gorlick1991,
abstract = {The authors discuss the architectural features of weaves, their implementation, and their use in a variety of applications. Weaves are networks of concurrently executing tool fragments that communicate by passing objects. Weaves are distinguished from other dataflow styles by their emphasis on instrumentation, continuous observability, and dynamic rearrangement: basic low-overhead instrumentation is inserted automatically, executing weaves can be observed at any time by means of sophisticated analysis agents, without degrading the performance of the weave, and weaves can be dynamically snipped and spliced without interrupting the data flow.},
address = {Austin, TX},
author = {Gorlick, M.M. and Razouk, R.R.},
booktitle = {13th International Conference on Software Engineering},
doi = {10.1109/ICSE.1991.130620},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Gorlick, Razouk - 1991 - Using weaves for software construction and analysis.pdf:pdf},
isbn = {0-8186-2140-0},
keywords = {data flow,incremental development,instrumentation,object-,oriented,parallel execution,performance analysis,software,streams,threads},
pages = {23--34},
publisher = {IEEE Comput. Soc. Press},
title = {{Using weaves for software construction and analysis}},
year = {1991}
}
@inproceedings{Gorlick1994,
abstract = {Visual programming research has largely focused on the issues of visual programming-in-the-small. However, entirely different concerns arise when one is programming-in-the-large. We present a visual software engineering environment that allows users to construct visually programs consisting of hierarchically organized networks of components that process streams of arbitrary objects. We discuss the problems that occur when trying to construct systems consisting of thousands of interconnected components, examine how this environment deals with some of the problems specific to visual programming-in-the-large, and show why our initial solutions failed to scale successfully. Finally, we argue that a single visual mechanism called “zooming” addresses these scaling problems and, when suitably augmented, can also support automatic component discovery and intelligent error correction},
author = {Gorlick, Michael and Quilici, Alex},
booktitle = {1994 IEEE Symposium on Visual Languages},
doi = {10.1109/VL.1994.363631},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Gorlick, Quilici - 1994 - Visual programming-in-the-large versus visual programming-in-the-small.pdf:pdf},
isbn = {0-8186-6660-9},
keywords = {Aerospace electronics,Aerospace testing,Automatic testing,Documentation,Error correction,Information analysis,Instruments,Programming environments,Software engineering,System testing,arbitrary objects,automatic component discovery,hierarchically organized networks,intelligent error correction,interconnected components,scaling problems,visual languages,visual mechanism,visual programming,visual programming research,visual programming-in-the-large,visual programming-in-the-small,visual software engineering environment,zooming},
language = {English},
pages = {137--144},
publisher = {IEEE Comput. Soc. Press},
title = {{Visual programming-in-the-large versus visual programming-in-the-small}},
url = {http://ieeexplore.ieee.org/xpls/abs{\_}all.jsp?arnumber=363631' escapeXml='false'/{\%}3E http://ieeexplore.ieee.org/xpls/abs{\_}all.jsp?arnumber=363631},
year = {1994}
}
@inproceedings{robbins1998-adlintegration,
abstract = {Software architecture descriptions are high-level models of software systems. Some researchers have proposed special- purpose architectural notations that have a great deal of expressive power but are not well integrated with common development methods. Others have used mainstream development methods that are accessible to developers, but lack semantics needed for extensive analysis. We describe an approach to combining the advantages of these two ways of modeling architectures. We present two examples of extending UML, an emerging standard design notation, for use with two architecture description languages, C2 and Wright. Our approach suggests a practical strategy for bringing architectural modeling into wider use, namely by incorporating substantial elements of architectural models into a standard design method.},
address = {Kyoto, Japan},
author = {Robbins, JE and Medvidovic, Nenad},
booktitle = {20th international conference on Software engineering (ICSE1998)},
file = {:Users/eoin/Downloads/00671120.pdf:pdf},
isbn = {0818683686},
keywords = {architecture,constraint languages,description languages,incremental,object-oriented design,software architecture},
pages = {209--218},
publisher = {IEEE Computer Society},
title = {{Integrating architecture description languages with a standard design method}},
year = {1998}
}
@article{shaw1995-abstractions,
abstract = {Architectures for software use rich abstractions and idioms to describe system components, the nature of interactions among the components, and the patterns that guide the composition of components into systems. These abstractions are higher level than the elements usually supported by programming languages and tools. They capture packaging and interaction issues as well as computational functionality. Well-established (if informal) patterns guide the architectural design of systems. We sketch a model for defining architectures and present an implementation of the basic level of that model. Our purpose is to support the abstractions used in practice by software designers. The implementation provides a testbed for experiments with a variety of system construction mechanisms. It distinguishes among different types of components and different ways these components can interact. It supports abstract interactions such as data flow and scheduling on the same footing as simple procedure call. It can express and check appropriate compatibility restrictions and configuration constraints. It accepts existing code as components, incurring no runtime overhead after initialization. It allows easy incorporation of specifications and associated analysis tools developed elsewhere. The implementation provides a base for extending the notation and validating the model .},
author = {Shaw, M. and DeLine, R. and Klein, D.V. and Ross, T.L. and Young, D.M. and Zelesnik, G.},
doi = {10.1109/32.385970},
file = {::},
issn = {00985589},
journal = {IEEE Transactions on Software Engineering},
keywords = {architectural abstraction,architecture description language,organization,software architecture,software engineering,software system},
month = {apr},
number = {4},
pages = {314--335},
title = {{Abstractions for software architecture and tools to support them}},
url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=385970},
volume = {21},
year = {1995}
}
@techreport{vestal1993-fouradls,
author = {Vestal, Steve},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Vestal - 1993 - A Cursory Overview and Comparison of Four Architecture Description Languages.pdf:pdf},
institution = {Honeywell Technology Center},
title = {{A Cursory Overview and Comparison of Four Architecture Description Languages}},
year = {1993}
}
@article{medvidovic2000-adlcomparison,
abstract = {Software architectures shift the focus of developers from lines-of-code to coarser-grained architectural elements and their overall interconnection structure. Architecture description languages (ADLs) have been proposed as modeling notations to support architecture-based development. There is, however, little consensus in the research community on what is an ADL, what aspects of an architecture should be modeled in an ADL, and which of several possible ADLs is best suited for a particular problem. Furthermore, the distinction is rarely made between ADLs on one hand and formal specification, module interconnection, simulation and programming languages on the other. This paper attempts to provide an answer to these questions. It motivates and presents a definition and a classification framework for ADLs. The utility of the definition is demonstrated by using it to differentiate ADLs from other modeling notations. The framework is used to classify and compare several existing ADLs, enabling us, in the process, to identify key properties of ADLs. The comparison highlights areas where existing ADLs provide extensive support and those in which they are deficient, suggesting a research agenda for the future},
author = {Medvidovic, Nenad and Taylor, RN},
doi = {10.1109/32.825767},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Medvidovic, Taylor - 2000 - A Classification and Comparison Framework for Software Architecture Description Languages.pdf:pdf},
journal = {IEEE Transactions on Software Engineering},
number = {1},
pages = {70--93},
title = {{A Classification and Comparison Framework for Software Architecture Description Languages}},
volume = {26},
year = {2000}
}
@article{medvidovic1997-adlclassification,
abstract = {Software architectures shift developers' focus from lines-of-code to coarser-grained architectural elements and their interconnection structure. Architec- ture description languages (ADLs) have been proposed as modeling notations to support architecture-based development. There is, however, little consensus in the research community on what is an ADL, what aspects of an architecture should be modeled in an ADL, and which ADL is best suited for a particular problem. Fur- thermore, the distinction is rarely made between ADLs on one hand and formal specification, module interconnection, simulation, and programming languages on the other. This paper attempts to provide an answer to these questions. It motivates and presents a definition and a classification framework for ADLs. The utility of the definition is demonstrated by using it to differentiate ADLs from other modcling notations. The framework is used to classify and compare several existing ADLs.},
author = {Medvidovic, Nenad and Taylor, Richard N.},
doi = {10.1145/267896.267903},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Medvidovic, Taylor - 1997 - A framework for classifying and comparing architecture description languages.pdf:pdf},
issn = {01635948},
journal = {ACM SIGSOFT Software Engineering Notes},
keywords = {architecture description languages,classification,comparison,definition,software architecture},
month = {nov},
number = {6},
pages = {60--76},
title = {{A framework for classifying and comparing architecture description languages}},
volume = {22},
year = {1997}
}
@inproceedings{medvidovic1997-adldomains,
abstract = {Software architectures shift the focus of developers from lines-of-code to coarser-grained elements and their interconnection structure. Architecture description languages (ADLs) have been proposed as domain-specific languages for the domain of software architecture. There is still little consensus in the research community on what problems are most important to address in a study of software architecture, what aspects of an architecture should be modeled in an ADL, or even what an ADL is. To shed light on these issues, we provide a framework of architectural domains, or areas of concern in the study of software architectures. We evaluate existing ADLs with respect to the framework and study the relationship between architectural and application domains. One conclusion is that, while the architectural domains perspective enables one to approach architectures and ADLs in a new, more structured manner, further understanding of architectural domains, their tie to application domains, and their specific influence on ADLs is needed.},
address = {Santa Barbara, California},
author = {Medvidovic, Nenad and Rosenblum, David S.},
booktitle = {Conference on Domain-Specific Languages on Conference on Domain-Specific Languages (DSL97)},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Medvidovic, Rosenblum - 1997 - Domains of concern in software architectures and architecture description languages.pdf:pdf},
isbn = {0897918673},
keywords = {architectural domain,architecture description language,domain,domain-specific language,software architecture},
pages = {16},
publisher = {ACM Press},
title = {{Domains of concern in software architectures and architecture description languages}},
year = {1997}
}
@inproceedings{kamal2007-adlpatterns,
abstract = {Architecture patterns provide solutions to recurring design problems at the architecture level. In order to model patterns during software architecture design, one may use a number of existing Architecture Description Languages (ADLs), including the UML, a generic language but also a de facto industry standard. Unfortunately, there is little explicit support offered by such languages to model architecture patterns, mostly due to the inherent variability that patterns entail. In this paper, we analyze the support that few selected languages offer in modeling a limited set of architecture patterns with respect to four specific criteria: syntax, visualization, variability, and extensibility. The results highlight the strengths and weaknesses of the selected ADLs for modeling architecture patterns in software design.},
address = {Luxembourg},
author = {Kamal, Ahmad Waqas and Avgeriou, Paris},
booktitle = {4th International Workshop on Rapid Integration of Software Engineering techniques (RISE07)},
editor = {Guelfi, Nicolas},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Kamal, Avgeriou - 2007 - An Evaluation of ADLs on Modeling Patterns for Software Architecture.pdf:pdf},
keywords = {ADLs,Architecture Patterns,Modeling,Software Architecture,UML.},
publisher = {Springer-Verlag},
title = {{An Evaluation of ADLs on Modeling Patterns for Software Architecture}},
year = {2007}
}
@techreport{fuxman2000-adlsurvey,
abstract = {In the last few years, a considerable number of architecture description languages (ADLs) have been proposed for describing and reasoning about software architectures. In this work, we classify and compare several ADLs placing emphasis on their features for formal modelling and analysis.},
author = {Fuxman, Arel D.},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Fuxman - 2000 - A Survey of Architecture Description Languages.pdf:pdf},
institution = {Dept of Computer Science, University of Toronto},
pages = {CSRG--407},
title = {{A Survey of Architecture Description Languages}},
url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.26.7113 http://www.cs.toronto.edu/{~}chechik/courses99/csc2108/projects/index.html http://www.cs.toronto.edu/pub/reports/csrg/407/},
year = {2000}
}
@inproceedings{Faulkner2003,
abstract = {Multi-Agent Systems, Architectural Description Language, BDI Agent Model, System Architecture This paper identifies the foundations for an architectural description language (ADL) to specify multi-agent system architectures for information systems. We propose a set of system architectural concepts based on the BDI agent model and existing classical ADLs. We then conceptualize SKwyRL-ADL, aimed at capturing a "core" set of structural and behavioral concepts, including relationships that are fundamental in architecture description for BDI-MAS. We partially apply our ADL on a peer-to-peer document sharing example.},
address = {Angers, France},
author = {Faulkner, S and Kolp, Manuel},
booktitle = {5th International Conference on Enterprise Information Systems (ICEIS 03)},
editor = {Camp, Olivier and Piattini, Mario},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Faulkner, Kolp - 2003 - Towards an agent architectural description language for information systems.pdf:pdf},
keywords = {adl,architectural description language,based on,bdi agent model,description language,foundations for an architectural,multi-agent systems,of system architectural concepts,system architecture,system architectures for information,systems,this paper identifies the,to specify multi-agent,we propose a set},
pages = {59--66},
publisher = {Kluwer},
title = {{Towards an agent architectural description language for information systems}},
year = {2003}
}
@inproceedings{clements1996-adlsurvey,
abstract = {Architecture Description Languages (ADLs) are emerging as viable tools for formally representing the architectures of systems. While growing in number, they vary widely in terms of the abstractions they support and analysis capabilities they provide. Further, many languages not originally designed as ADLs serve reasonably well at representing and analyzing software architectures. This paper summarizes a taxonomic survey of ADLs that is in progress. The survey characterizes ADLs in terms of (a) the classes of systems they support; (b) the inherent properties of the languages themselves; and (c) the process and technology support they provide to represent, refine, analyze, and build systems from an architecture. Preliminary results allow us to draw conclusions about what constitutes an ADL, and how contemporary ADLs differ from each other.},
author = {Clements, Paul C},
booktitle = {8th International Workshop on Software Specification and Design (IWSSD 96)},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Clements - 1996 - A Survey of Architecture Description Languages.pdf:pdf},
month = {mar},
pages = {16--25},
publisher = {IEEE Computer Society},
title = {{A Survey of Architecture Description Languages}},
year = {1996}
}
@article{moriconi1995-archrefinement,
abstract = {method is presented for the stepwise refinement of an abstract architecture into a relatively correct lower level architecture that is intended to implement it. A refinement step involves the application of a predefined refinement pattern that provides a routine solution to a standard architectural design problem. A pattern contains an abstract architecture schema and a more detailed schema intended to implement it. The two schemas usually contain very different architectural concepts (from different architectural styles). Once a refinement pattern is proven correct, instances of it can be used without proof in developing specific architectures. Individual refinements are compositional, permitting incremental development and local reasoning. A special correctness criterion is defined for the domain of software architecture, as well as an accompanying proof technique. A useful syntactic form of correct composition is defined. The main points are illustrated by means of familiar architectures for a compiler. A prototype implementation of the method has been used successfully in a real application.},
author = {Moriconi, M. and Qian, X. and Riemenschneider, R.a.},
doi = {10.1109/32.385972},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Moriconi, Qian, Riemenschneider - 1995 - Correct architecture refinement.pdf:pdf},
issn = {00985589},
journal = {IEEE Transactions on Software Engineering},
keywords = {Software architecture,composition.,formal methods,hierarchy,refinement patterns,relative correctness,stepwise refinement},
month = {apr},
number = {4},
pages = {356--372},
title = {{Correct architecture refinement}},
volume = {21},
year = {1995}
}
@techreport{moriconi1997-sadl,
author = {Moriconi, Mark and Riemenschneider, R A},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Moriconi, Riemenschneider - 1997 - Introduction to SADL 1 .0 A Language for Specifying Software Architecture Hierarchies.pdf:pdf},
institution = {Computer Science Laboratory, SRI International},
pages = {SRI--CSL--97--01},
title = {{Introduction to SADL 1 .0: A Language for Specifying Software Architecture Hierarchies}},
year = {1997}
}
@article{Luckham1995,
abstract = {Rapide is an event-based concurrent object-oriented language specifically designed for prototyping system architectures. Two principle design goals are (1) to provide constructs for defning executable prototypes of architectures and (2) to adopt an execution model in which the concurrency synchronization dataflow and timing properties of a prototype are explicitly represented. This paper describes the partially ordered event set (poset) execution model and outlines with examples some of the event-based features for defining communication architectures and relationships between architectures. Various features of Rapide are illustrated by excerpts from a prototype of the X/Open distributed transaction processing reference architecture.},
author = {Luckham, DC and Kenney, JJ and Augustin, L.M. and Vera, J. and Bryan, D. and Mann, W.},
doi = {10.1109/32.385971},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Luckham et al. - 1995 - Specification and analysis of system architecture using Rapide.pdf:pdf},
issn = {00985589},
journal = {IEEE Transactions on Software Engineering},
keywords = {architecture,architecture definition languages,causality,concurrency,constraint-based specification,event patterns,formal constraints,partially ordered event sets,prototyping,rapide,simulation},
month = {apr},
number = {4},
pages = {336--354},
title = {{Specification and analysis of system architecture using Rapide}},
volume = {21},
year = {1995}
}
@misc{Oquendo2005,
author = {Oquendo, Prof Flavio},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Oquendo - 2005 - Tutorial on ArchWare ADL – Version 2 ( $\pi$-ADL Tutorial ).pdf:pdf},
title = {{Tutorial on ArchWare ADL – Version 2 ( $\pi$-ADL Tutorial )}},
year = {2005}
}
@article{luckham1995-rapide,
abstract = {This paper discusses general requirements for architecture definition languages, and describes the syntax and semantics of the subset of the Rapide language that is designed to satisfy these requirements. Rapide is a concurrent event-based simulation language for defining and simulating the behavior of system architectures. Rapide is intended for modelling the architectures of concurrent and distributed systems, both hardware and software in order to represent the behavior of distributed systems in as much detail as possible. Rapide is designed to make the greatest possible use of event-based modelling by producing causal event simulations. When a Rapide model is executed it produces a simulation that shows not only the events that make up the model's behavior, and their timestamps, but also which events caused other events, and which events happened independently. The architecture definition features of Rapide are described: event patterns, interfaces, architectures and event pattern mappings. The use of these features to build causal event models of both static and dynamic architectures is illustrated by a series of simple examples from both software and hardware. Also we give a detailed example of the use of event pattern mappings to define the relationship between two architectures at different levels of abstraction. Finally, we discuss briefly how Rapide is related to other event-based languages.},
author = {Luckham, DC and Vera, James},
doi = {10.1109/32.464548},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Luckham, Vera - 1995 - An event-based architecture definition language.pdf:pdf},
issn = {00985589},
journal = {IEEE Transactions on Software Engineering},
keywords = {architecture,architecture de nition languages,causal-,concur-,event patterns,formal constraints,par-,prototyping,rapide,rency,simulation,tially ordered event sets},
number = {9},
pages = {717--734},
title = {{An event-based architecture definition language}},
volume = {21},
year = {1995}
}
@article{Oquendo2006,
abstract = {Software systems have become increasingly complex and are often used in highly dynamic, distributed and mobile environments. Formal development of such software systems in order to guarantee their completeness and correctness is a large research challenge. This article presents the $\pi$-Method, a novel formal method that has been designed in the ArchWare European Project to address model-driven development of safe software systems. It is a well-founded theoretically method relying on formal foundations: its formal language for architecture description is based on the $\pi$-calculus, for architecture analysis on the $\mu$-calculus, and for architecture transformation and refinement on the rewriting logic. The $\pi$-Method, like formal methods such as B, FOCUS, VDM, and Z, aims to provide full support for formal development of software systems. However, unlike these methods that do not provide any architectural support, the $\pi$-Method has been built from scratch to formally support architecture-centric component-based model-driven development. Furthermore, a major impetus behind defining formal languages and method is that their formality renders them suitable to be manipulated by software tools. Indeed, a comprehensive toolset supporting formal model-driven engineering has been developed.},
author = {Oquendo, Flavio},
doi = {10.1145/1127878.1127885},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Oquendo - 2006 - $\pi$-Method a model-driven formal method for architecture-centric software engineering.pdf:pdf},
issn = {01635948},
journal = {ACM SIGSOFT Software Engineering Notes},
keywords = {analysis languages,archi- lution process,architecture description languages,architecture transformation,architecture why architecture-centric,component-based software,emerged as an important,engineering,formal methods,model-driven development,refinement software architecture has,subdiscipline,tecture-centric software engineering},
month = {may},
number = {3},
pages = {1--13},
title = {{$\pi$-Method: a model-driven formal method for architecture-centric software engineering}},
volume = {31},
year = {2006}
}
@article{Oquendo2004,
abstract = {A key aspect of the design of any software system is its architecture. An architecture description, from a runtime perspective, should provide a formal specification of the architecture in terms of components and connectors and how they are composed together. Further, a dynamic or mobile architecture description must provide a specification of how the architecture of the software system can change at runtime. Enabling specification of dynamic and mobile architectures is a large challenge for an Architecture Description Language (ADL). This article describes $\pi$-ADL, a novel ADL that has been designed in the ArchWare European Project to address specification of dynamic and mobile architectures. It is a formal, well-founded theoretically language based on the higher-order typed $\pi$-calculus. While most ADLs focus on describing software architectures from a structural viewpoint, $\pi$-ADL focuses on formally describing architectures encompassing both the structural and behavioural viewpoints. The $\pi$-ADL design principles, concepts and notation are presented. How $\pi$-ADL can be used for specifying static, dynamic and mobile architectures is illustrated through case studies. The $\pi$-ADL toolset is outlined.},
author = {Oquendo, Flavio},
doi = {10.1145/986710.986728},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Oquendo - 2004 - $\pi$-ADL an Architecture Description Language based on the higher-order typed $\pi$-calculus for specifying dynamic and mobi.pdf:pdf},
issn = {01635948},
journal = {ACM SIGSOFT Software Engineering Notes},
keywords = {an adl,architecture description languages,behaviours of,describe changing structures and,dynamic architectures,for describing dynamic and,languages,mobile architectures,must be able to,specification software architectures from,structural and behavioural viewpoints,$\pi$- indeed},
month = {may},
number = {3},
pages = {1--14},
title = {{$\pi$-ADL: an Architecture Description Language based on the higher-order typed $\pi$-calculus for specifying dynamic and mobile software architectures}},
volume = {29},
year = {2004}
}
@inproceedings{gruhn2005-conmoto,
abstract = {In this paper we motivate an Architecture Description Language (ADL) for mobile distributed systems based on the $\pi$-calculus. Different from other approaches, the non-functional properties, which are essential when mobile architectures are described, are treated in a flexible manner by inserting logical formulae for expressing and checking non-functional properties into $\pi$-calculus processes. A formal example is given to illustrate the approach before the constituents of the ADL are sketched.},
address = {Pisa},
author = {Gruhn, Volker and Schafer, Clemens},
booktitle = {2nd European Workshop on Software Architecture (EWSA 2005)},
editor = {Morrison, Ron and Oquendo, Flavio},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Gruhn, Schafer - 2005 - Architecture Description for Mobile Distributed Systems.pdf:pdf},
isbn = {978-3-540-26275-6},
keywords = {LNCS 3527},
mendeley-tags = {LNCS 3527},
pages = {239--246},
publisher = {Springer Berlin / Heidelberg},
title = {{Architecture Description for Mobile Distributed Systems}},
year = {2005}
}
@inproceedings{oquendo2004-archware,
address = {St Andrews, Scotland},
author = {Oquendo, Flavio and Warboys, Brian and Morrison, Ron and Dindeleux, Régis and Gallo, Ferdinando and Garavel, Hubert and Occhipinti, Carmen},
booktitle = {EWSA 2004, LNCS 3047},
doi = {10.1007/978-3-540-24769-2_23},
editor = {Oquendo, Flavio and Warboys, Brian and Morrison, Ron},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Oquendo et al. - 2004 - ARCHWARE Architecting Evolvable Software.pdf:pdf},
pages = {257--271},
title = {{ARCHWARE: Architecting Evolvable Software}},
year = {2004}
}
@article{oquendo2004-piadl,
abstract = {A key aspect of the design of any software system is its architecture. An architecture description, from a runtime perspective, should provide a formal specification of the architecture in terms of components and connectors and how they are composed together. Further, a dynamic architecture description must provide a specification of how the architecture of the software system can change at runtime. Enabling specification of dynamic architectures is a large challenge for an Architecture Description Language (ADL). This paper presents how $\pi$-ADL, a novel ADL that has been designed in the ArchWare European Project, can be used for specifying dynamic architectures through a case study. While most ADLs focus on describing software architectures from a structural viewpoint, $\pi$-ADL focuses on formally describing architectures encompassing both the structural and behavioural viewpoints. The $\pi$-ADL toolset is outlined.},
author = {Oquendo, Flavio},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Oquendo - 2004 - Formally Describing Dynamic Software Architectures with $\pi$-ADL.pdf:pdf},
journal = {World Scientific and Engineering Transactions on Systems},
month = {jun},
number = {8},
pages = {673--679},
title = {{Formally Describing Dynamic Software Architectures with $\pi$-ADL}},
volume = {3},
year = {2004}
}
@incollection{klein2010-model,
author = {Klein, Peter},
booktitle = {Graph transformations and model-driven engineering},
file = {:Users/eoin/Dropbox/Work/PhDWork/ADL-LitReview/ADL-Papers/MoDeL-Klein-LNCS-5765.pdf:pdf},
pages = {249--273},
publisher = {Springer-Verlag},
title = {{The architecture description language model}},
year = {2010}
}
@misc{Vestal2004,
abstract = {The increasing complexity of embedded systems is driving development of improved architectural modeling and analysis approaches that make building systems faster, less expensive, and more predictable. Honeywell's MetaH was the first comprehensive toolset to tackle the issues of integrated modeling, analysis, system integration and verification. Today, MetaH is both the foundation of the SAE AADL (Architecture Analysis and Design Language)—an emerging standard language for specifying embedded computer system architectures including both functional and non-functional behaviors and properties—and the primary AADL toolset. It accepts specifications written in AADL and performs a variety of verification, modeling, analysis, and code generation activities. AADL allows the architecture of a real-time, safety-critical embedded system to be specified as an assembly of communicating components, where component functional interfaces and timing and safety behaviors and properties can be precisely defined. MetaH includes tools to perform schedulability analysis, reliability analysis, partition isolation analysis, and compliance checking of source code against AADL specifications. MetaH also automatically configures a middleware layer integrating all components, and generates and verifies a hybrid automata model of core middleware scheduling and security code.},
author = {Vestal, Steve},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Vestal - 2004 - The MetaH AADL Toolset.pdf:pdf},
pages = {2},
title = {{The MetaH AADL Toolset}},
url = {http://www.honeywell.com/sites/docs/DKRHVMR134XK8DQRHFA5JVOVUZQ23EN0K.pdf},
year = {2004}
}
@article{smeda2005-madl2,
abstract = {The techniques of meta-modeling and meta-levels have become a mature concept and have been largely used to solve real problems in programming languages, distributed environments, knowledge representation, or data bases. In this article it is shown how the same techniques can be applied in component-based software architecture. It also shown the need to propose mechanisms of reflexivity within the domain of software architecture meta-modeling. The outcome of this is a meta-meta-architecture with a minimal core whose finality is to define meta-components, meta-connectors and meta-architectures. Call this meta-meta-architecture MADL (Meta Architecture Description Language).},
author = {Smeda, Adel and Khammaci, Tahar and Oussalah, Mourad},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Smeda, Khammaci, Oussalah - 2005 - Meta Architecting Towards a New Generation of Architecture Description Languages.pdf:pdf},
journal = {Journal of Computer Science},
keywords = {architecture description languages,component-based systems,software architecture},
number = {4},
pages = {454--460},
title = {{Meta Architecting : Towards a New Generation of Architecture Description Languages}},
volume = {1},
year = {2005}
}
@article{binns1996-metah,
author = {Binns, Pam and Englehart, Matt and Jackson, Mike and Vestal, Steve},
doi = {10.1142/S0218194096000107},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Binns et al. - 1996 - DOMAIN-SPECIFIC SOFTWARE ARCHITECTURES FOR GUIDANCE, NAVIGATION AND CONTROL.pdf:pdf},
issn = {0218-1940},
journal = {International Journal of Software Engineering and Knowledge Engineering},
month = {jun},
number = {02},
pages = {201--227},
title = {{Domain Specific Software Architectures for Guidance, Navigation and Control}},
volume = {06},
year = {1996}
}
@inproceedings{smeda2005-madl,
abstract = {As the concept of meta-classes was introduced in order to permit the manipulation of classes, we introduce the concept of meta-components, meta-connectors, and meta- architectures to permit the manipulation and the redefinition of architectural elements (structural and behavioral). In this article we present a meta-meta- architecture called MADL (Meta Architecture Description Language) to abstract the notions of architectures (components, connectors, architectures), hence to facilitate their manipulation, reuse, and evolution; and also to ease (hence encourage) the transformation and comparison among ADLs.},
address = {Mt. Pleasant, MI, USA},
author = {Smeda, Adel and Oussalah, Mourad and Khammaci, Tahar},
booktitle = {Third ACIS Int'l Conference on Software Engineering Research, Management and Applications (SERA'05)},
doi = {10.1109/SERA.2005.50},
editor = {Malloy, Brian},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Smeda, Oussalah, Khammaci - 2005 - MADL Meta Architecture Description Language.pdf:pdf},
isbn = {0-7695-2297-1},
keywords = {architecture description languages,architectures,component,component-based software architecture,connectors,meta-modeling},
pages = {152--159},
publisher = {IEEE},
title = {{MADL: Meta Architecture Description Language}},
year = {2005}
}
@article{vanommering2000-koala,
abstract = {Most consumer electronics today contain embedded software. In the early days, developing CE software presented relatively minor challenges, but in the past several years three significant problems have arisen: size and complexity of the software in individual products; the increasing diversity of products and their software; and the need for decreased development time. The question of handling diversity and complexity in embedded software at an increasing production speed becomes an urgent one. The authors present their belief that the answer lies not in hiring more software engineers. They are not readily available, and even if they were, experience shows that larger projects induce larger lead times and often result in greater complexity. Instead, they believe that the answer lies in the use and reuse of software components that work within an explicit software architecture. The Koala model, a component-oriented approach detailed in this article, is their way of handling the diversity of software in consumer electronics. Used for embedded software in TV sets, it allows late binding of reusable components with no additional overhead},
author = {van Ommering, R. and van der Linden, F. and Kramer, J. and Magee, J.},
doi = {10.1109/2.825699},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/van Ommering et al. - 2000 - The Koala component model for consumer electronics software.pdf:pdf},
issn = {00189162},
journal = {Computer},
month = {mar},
number = {3},
pages = {78--85},
title = {{The Koala component model for consumer electronics software}},
volume = {33},
year = {2000}
}
@inproceedings{asikainen2004-koala,
abstract = {An approach for modelling configurable software product families (CSPFs) and for automated configuring of product individuals using the models is presented. It is based on a similar approach for configuring physical products. The conceptual foundation and syntax of the Koalish modelling language used for this purpose are defined. The language extends Koala, a component model and architecture description language, with explicit variation modelling mecha- nisms. Koalish is further provided a formal semantics by defining a translation from it to Weight Constraint Rule Language (WCRL), a form of logic pro- grams. This allows using an existing inference tool for WCRL, smodels, to im- plement the reasoning needed in the configurator. The configurator is able to construct all valid product individuals, with respect to a Koalish model of a CSPF, that satisfy a given set of requirements. The implemented functionality of the configurator has been tested using small-scale toy examples, for which it performs adequately.},
author = {Asikainen, Timo and Soininen, Timo and M{\"{a}}nnist{\"{o}}, Tomi},
booktitle = {Software Product Family Engineering, LNCS 3014},
doi = {10.1007/978-3-540-24667-1_28},
editor = {Linden, Frank},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Asikainen, Soininen, M{\"{a}}nnist{\"{o}} - 2004 - A Koala-based approach for modelling and deploying configurable software product families.pdf:pdf},
pages = {225--249},
publisher = {Springer Berlin Heidelberg},
title = {{A Koala-based approach for modelling and deploying configurable software product families}},
url = {http://www.springerlink.com/index/nhekwtmm45g4gtll.pdf},
year = {2004}
}
@article{poizat2006-kadl,
abstract = {Component Based Software Engineering has now emerged as a discipline for system development. After years of battle between component platforms, the need for means to abstract away from specific implementation details is now recognized. This paves the way for model driven approaches (such as MDE) but also for the more older Architectural Description Language (ADL) paradigm. In this paper we present KADL, an ADL based on the Korrigan formal language which supports the following features: integration of fully formal behaviours and data types, expressive component compo- sition mechanisms through the use of modal logic, specification readability through graphical notations, and dedicated architectural analysis techniques.},
author = {Poizat, Pascal and Royer, JC},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Poizat, Royer - 2006 - A Formal Architectural Description Language based on Symbolic Transition Systems and Modal Logic.pdf:pdf},
journal = {Journal of Universal Computer Science},
keywords = {abstract data,architectural description language,category,component based software engineering,graphical notations,mixed formal specifications,modal logic glue,symbolic transition systems,types,verification},
number = {12},
pages = {1741--1782},
title = {{A Formal Architectural Description Language based on Symbolic Transition Systems and Modal Logic}},
volume = {12},
year = {2006}
}
@article{Choppy2001,
abstract = {This paper presents an environment to support the use of specification for mixed systems, i.e. systems with both dynamic (behaviour, communication, concurrency) and static (data type) aspects. We provide an open and extensible environment based on the KORRIGAN specification model. This model uses a hierarchy of view concepts to specify data types, behaviours and compositions in a uniform way. The key notion behind a view is the symbolic transition system. A good environment supporting such a model needs to interface with existing languages and tools. At the core of our environment is the CLIS library which is devoted to the representation of our view concepts and existing specification languages. Our environment is implemented using the object-oriented language PYTHON. It provides an integration process for new tools, a specification library, a parser library, LOTOS generation and object-oriented code generation for KORRIGAN specifications.},
author = {Choppy, C and Poizat, P and Royer, JC},
doi = {10.3217/jucs-007-01-0019},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Choppy, Poizat, Royer - 2001 - The Korrigan Environment.pdf:pdf},
journal = {Journal of Universal Computer Science},
number = {1},
pages = {19--36},
title = {{The Korrigan Environment}},
volume = {7},
year = {2001}
}
@techreport{poizat2007-kadl,
abstract = {This report presents the cash-point case study and mainly describes its specifications with the KADL ADL. The language is a mixed of state transition diagrams, abstract datatype and modal logic. We emphasize the need for abstract and formal descriptions especially communication architectures. We also gives some proofs done using our specific tool based on symbolic transition systems. Last we discuss previous specifications for this case study.},
author = {Poizat, Pascal and Royer, Jean-claude},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Poizat, Royer - 2007 - KADL Specification of The Cash Point Case Study.pdf:pdf},
institution = {IBISC},
keywords = {Abstract Data Type,Architectural Description Language,Cash Point Case Study,Component Based Software Engineering,Symbolic Transition Systems,Verification},
number = {00},
pages = {00.0},
title = {{KADL Specification of The Cash Point Case Study}},
year = {2007}
}
@inproceedings{Ng1995,
abstract = {This paper describes work on the application of visual techniques to the design and construction of parallel and distributed programs. In particular, it looks at how the software architectural view can be effectively utilised to provide a common framework for integrating the various software development activities, ranging from early, informal program design to the evolution of the running program. A prototype visual programming environment-the Software Architect's Assistant-has been built for the design and development of Regis distributed programs. It provides the user with automated, intelligent assistance throughout the software design process. Facilities provided include the display of integrated graphical and textual views, a flexible mechanism for recording design information and the automatic generation of program code and formatted reports from design diagrams. Software reuse is also supported through the use of component libraries. Support for graphical monitoring and management of running programs, currently provided by a complementary tool, will be integrated into the environment to provide a complete solution for visual distributed programming.},
address = {Wailea, HI},
author = {Ng, Keng and Kramer, Jeff and Magee, Jeff and Dulay, Naranker},
booktitle = {Twenty-Eighth Hawaii International Conference on System Sciences},
doi = {10.1109/HICSS.1995.375454},
editor = {Mudge, Trevor and Shriver, Bruce and El-Rewini, Hesham and Nunamaker, J. F. and Sprague, Ralph and {Lawrence Hunter}},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Ng et al. - 1995 - The Software Architect's Assistant-a visual environment for distributed programming.pdf:pdf},
isbn = {0-8186-6935-7},
pages = {254--263},
publisher = {IEEE Computer Society Press},
title = {{The Software Architect's Assistant-a visual environment for distributed programming}},
url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=375454},
volume = {2},
year = {1995}
}
@inproceedings{zheng2010-dpdadl,
abstract = {Architecture description language (ADL) provides a linguistic approach to represent software architecture. Usually, it has to develop a new ADL for a particular domain. Some domains are difficult to develop the ADLs, e.g. data processing domain (DPD). Since the products of these domains can apply to many different areas as a sub module, which complicates the architecture abstraction. This paper shows the development of our ADL for data processing domain. It has domain independence meta model concept, and it supports variability description and the code generation rules have been indicated too. Our data processing product line can be described by this ADL and generate product code, which will improve the productivity.},
author = {Zheng, Li and Wu, Zhanwei and Zhang, Chao and Yang, Fang},
booktitle = {2010 Seventh International Conference on Information Technology},
doi = {10.1109/ITNG.2010.25},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Zheng et al. - 2010 - Developing an Architecture Description Language for Data Processing Product Line.pdf:pdf},
isbn = {978-1-4244-6270-4},
keywords = {adl,dsm,mda,software architecture,software product line},
pages = {944--949},
publisher = {IEEE},
title = {{Developing an Architecture Description Language for Data Processing Product Line}},
year = {2010}
}
@article{magee1996-darwin,
author = {Magee, Jeff and Kramer, Jeff},
doi = {10.1145/250707.239104},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Magee, Kramer - 1996 - Dynamic structure in software architectures.pdf:pdf},
isbn = {0897917979},
issn = {01635948},
journal = {ACM SIGSOFT Software Engineering Notes},
month = {nov},
number = {6},
pages = {3--14},
title = {{Dynamic structure in software architectures}},
volume = {21},
year = {1996}
}
@inproceedings{magee1995-darwin,
address = {Essen, Germany},
author = {Magee, Jeff and Dulay, Naranker and Eisenbach, Susan and Kramer, Jeff},
booktitle = {5th European Software Engineering Conference (ESEC1995)},
doi = {10.1.1.25.7933},
editor = {Sch{\"{a}}fer, Wilhelm and Botella, Pere},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Magee et al. - 1995 - Specifying Distributed Software Architectures(2).pdf:pdf},
keywords = {LNCS6093},
pages = {137--153},
publisher = {Springer-Verlag},
title = {{Specifying Distributed Software Architectures}},
url = {http://dl.acm.org/citation.cfm?id=651497},
year = {1995}
}
@article{Magee1995,
author = {Magee, J and Dulay, N and Eisenbach, S and Kramer, J},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Magee et al. - 1995 - Specifying Distributed Software Architectures.pdf:pdf},
journal = {Software Engineering—ESEC' {\ldots}},
title = {{Specifying Distributed Software Architectures}},
url = {http://www.springerlink.com/index/y258t4315265m232.pdf},
year = {1995}
}
@inproceedings{magee1994-regis,
abstract = {Regis is a programming environment aimed at supporting the development and execution of parallel and distributed programs. It embodies a constructive approach to the development of programs based on separating program structure from communication and computation. The emphasis is on constructing programs from multiple parallel computational components which cooperate to achieve the overall goal. The environment is designed to easily accommodate multiple communication mechanisms and primitives. Both the computational and communication elements of Regis programs are programmed in the object oriented programming language C++. The elements are combined into parallel and distributed programs using the configuration language Darwin. The paper describes programming in Regis through a set of small example programs.},
author = {Magee, J. and Dulay, N. and Kramer, J.},
booktitle = {2nd International Workshop on Configurable Distributed Systems},
doi = {10.1109/IWCDS.1994.289940},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Magee, Dulay, Kramer - 1994 - A constructive development environment for parallel and distributed programs.pdf:pdf},
isbn = {0-8186-5390-6},
keywords = {communication,distributed programming,inter-process,parallel programming,parallel programming language,software development},
pages = {4--14},
publisher = {IEEE},
title = {{A constructive development environment for parallel and distributed programs}},
url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=289940},
year = {1994}
}
@inproceedings{pinto2003-daopadl,
abstract = {Architecture description languages deal with the description, analysis and reuse of software architectures. This paper describes DAOP-ADL, a component- and aspect-based language to specify the architecture of an application in terms of components, aspects and a set of plug-compatibility rules between them. With the aim of connecting the specification of the application architecture to the implementation, we describe our language using XML and XML Schemas. The DAOP-ADL language was designed to be interpreted by DAOP, our own dynamic component- and aspect-oriented platform. DAOP provides a composition mechanism that plugs aspects into components dynamically at runtime. The software architect will use the DAOP-ADL language at design time to describe the architecture of the application. Later this architectural information is loaded into the DAOP platform, which needs it to establish the dynamic connections between autonomous components and aspects. Therefore, the use of DAOP-ADL closes the gap between design and implementation of component- and aspect-based applications.},
address = {Erfurt, Germany},
author = {Pinto, Monica and Fuentes, Lidia and Troya, Jose-Maria},
booktitle = {2nd international conference on Generative programming and component engineering (GPCE '03)},
editor = {Pfenning, Frank and Smaragdakis, Yannis},
file = {:Users/eoin/Dropbox/Work/PhDWork/ADL-LitReview/ADL-Papers/DAOP-ADL-PintoEtAl.pdf:pdf},
pages = {118--137},
publisher = {Springer-Verlag},
title = {{DAOP-ADL : An Architecture Description Language for Dynamic Component and Aspect-Based Development}},
year = {2003}
}
@misc{Vulgarakis,
author = {Vulgarakis, Aneta},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Vulgarakis - Unknown - Component Models Overview.ppt:ppt},
title = {{Component Models Overview}}
}
@article{rademaker2005-cbabel,
author = {Rademaker, Alexandre and Braga, Christiano and Sztajnberg, Alexandre},
doi = {10.1016/j.entcs.2005.03.018},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Rademaker, Braga, Sztajnberg - 2005 - A Rewriting Semantics for a Software Architecture Description Language.pdf:pdf},
issn = {15710661},
journal = {Electronic Notes in Theoretical Computer Science},
month = {may},
pages = {345--377},
title = {{A Rewriting Semantics for a Software Architecture Description Language}},
volume = {130},
year = {2005}
}
@article{Braga2004,
abstract = {Software architecture description languages (ADL) allow a software designer to focus on high- level aspects of an application by abstracting from the details of the components that compose an architecture. It is precisely this abstraction that makes ADLs suitable for verification using model checking techniques. ADLs are, in a way, domain-specific languages for aspects such as coordination, distribution and quality-of-service. The CBabel ADL defines the concept of contracts that precisely captures these architecture-level aspects. In this paper we propose a rewriting semantics for CBabel, that is, a formal semantics for CBabel specified in rewriting logic, a unifying formalism for concurrency models that has interesting properties as a logic and semantic framework due to its unified view of computation and proof. Using the Maude system, a high-performance implementation of rewriting logic, we formally verify the producer-consumer-buffer problem using model checking and state search.},
author = {Braga, Christiano and Sztajnberg, Alexandre},
doi = {10.1016/j.entcs.2004.04.010},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Braga, Sztajnberg - 2004 - Towards a Rewriting Semantics for a Software Architecture Description Language.pdf:pdf},
issn = {15710661},
journal = {Electronic Notes in Theoretical Computer Science},
keywords = {architecture description languages,model checking,rewriting semantics},
month = {may},
pages = {149--168},
title = {{Towards a Rewriting Semantics for a Software Architecture Description Language}},
volume = {95},
year = {2004}
}
@inproceedings{medvidovic1996-c2,
abstract = {Software architectures are multi-dimensional entities that can be fully understood only when viewed and analyzed at four different levels of abstraction: (1) internal functionality of a component, (2) the interface(s) exported by the component to the rest of the system, (3) interconnection of architectural elements in an architecture, and (4) rules of the architectural style. This paper presents the characteristics of each of the four levels of architectural abstraction, outlines the kinds of analyses that need to be performed at each level, and discusses the kinds of formal notations that are suitable at each level. We use the pipe-and-filter and Chiron-2 (C2) architectural styles as illustrations. In particular, we present formal models of C2 at the last three levels of abstraction as a first step in enabling a C2 design environment to perform the necessary analyses of architectures. We discuss the benefits of the formal definitions and our experience to date. 1 Keywords Software architectures, architectural styles, formalism, architecture definition languages, interface definition languages},
author = {Medvidovic, Nenad and Taylor, Richard N. and Whitehead, E. James},
booktitle = {California Software Symposium},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Medvidovic, Taylor, Whitehead - 1996 - Formal modeling of software architectures at multiple levels of abstraction.pdf:pdf},
keywords = {architectural styles,architecture definition languages,formalism,interface definition,software architectures},
pages = {28--40},
title = {{Formal modeling of software architectures at multiple levels of abstraction}},
year = {1996}
}
@inproceedings{medvidovic1996-dynadls,
address = {New York, New York, USA},
author = {Medvidovic, Nenad},
booktitle = {Joint proceedings of the second international software architecture workshop (ISAW-2) and international workshop on multiple perspectives in software development (Viewpoints '96) on SIGSOFT '96 workshops -},
doi = {10.1145/243327.243340},
editor = {Wolf, Alexander L. and Finkelstein, Anthony and Spanoudakis, George and Vidal, Laura},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Medvidovic - 1996 - ADLs and dynamic architecture changes.pdf:pdf},
isbn = {0897918673},
pages = {24--27},
publisher = {ACM Press},
title = {{ADLs and dynamic architecture changes}},
year = {1996}
}
@techreport{medvidovic2000-archintegn,
abstract = {Software architecture research has yielded a variety of powerful techniques for assisting in the design, implementation, and long-term evolution of complex, heterogeneous, distributed, multi-user applications. Since software development environments are themselves applications with these characteristics, it is natural to examine the effectiveness of an architectural approach to constructing and changing them. We report on our experience in creating a family of related environments in this manner. The environments encompass a range of services and include commercial off-the-shelf products as well as custom-built tools. The particular architectural approach adopted is fully reflexive: the environments are used in their own construction and evolution. We also report on some engineering experiences, in particular with our use of XML as the vehicle for supporting a common and extensible representation of architectural models, including the model of the environment itself. Generally applicable lessons from the experience are described.},
author = {Medvidovic, Nenad and Oreizy, Peyman and Taylor, RN and Khare, Rohit and Guntersdorfer, Michael},
doi = {10.1.1.224.7230},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Medvidovic et al. - 2000 - An Architecture-Centered Approach to Software Environment Integration.pdf:pdf},
institution = {Center for Software Engineering, University of Southern California},
keywords = {off-the-shelf reuse,software architectures,software environments,tool integration,xml},
pages = {Technical Report USC--CSE--00--516},
title = {{An Architecture-Centered Approach to Software Environment Integration}},
year = {2000}
}
@article{Medvidovic1996b,
abstract = {Software architectures enable large-scale software development. Component reuse and substitutability, two key aspects of large-scale development, must be planned for during software design. Object-oriented (OO) type theory supports reuse by structuring inter-component relationships and verifying those relationships through type checking in an architecture definition language (ADL). In this paper, we identify the issues and discuss the ramifications of applying OO type theory to the C2 architectural style. This work stems from a series of experiments that were conducted to investigate component reuse and substitutability in C2. We also discuss the limits of applicability of OO typing to C2 and how we addressed them in the C2 ADL.},
author = {Medvidovic, Nenad and Oreizy, Peyman and Robbins, Jason E. and Taylor, Richard N.},
doi = {10.1145/250707.239106},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Medvidovic et al. - 1996 - Using object-oriented typing to support architectural design in the C2 style.pdf:pdf},
issn = {01635948},
journal = {ACM SIGSOFT Software Engineering Notes},
keywords = {and,architectural styles,cussion of component compositionality,dis-,it allows us to,link much of the,object-oriented typing,reusability,reuse,soft-,software architectures,tionships via type checking,ware design},
month = {nov},
number = {6},
pages = {24--32},
title = {{Using object-oriented typing to support architectural design in the C2 style}},
volume = {21},
year = {1996}
}
@article{malavolta2010-modeltransformation,
author = {Malavolta, I. and Muccini, H. and Pelliccione, P. and Tamburri, D.a.},
doi = {10.1109/TSE.2009.51},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Malavolta et al. - 2010 - Providing Architectural Languages and Tools Interoperability through Model Transformation Technologies.pdf:pdf},
issn = {0098-5589},
journal = {IEEE Transactions on Software Engineering},
month = {jan},
number = {1},
pages = {119--140},
title = {{Providing Architectural Languages and Tools Interoperability through Model Transformation Technologies}},
volume = {36},
year = {2010}
}
@inproceedings{ruscio2010-byadl,
address = {Cape Town, South Africa},
author = {Ruscio, Davide Di and Malavolta, Ivano},
booktitle = {32nd ACM/IEEE International Conference on Software Engineering},
editor = {Kramer, Jeff and Bishop, Judith},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Ruscio, Malavolta - 2010 - Developing next generation ADLs through MDE techniques.pdf:pdf},
isbn = {9781605587196},
keywords = {adl,metamodeling,model driven,software architecture},
pages = {85--94},
publisher = {ACM},
title = {{Developing next generation ADLs through MDE techniques}},
year = {2010}
}
@inproceedings{bashroush2008-ali,
author = {Bashroush, Rabih and Spence, Ivor and Kilpatrick, Peter and Brown, T. John and Gilani, Wasif and Fritzsche, Mathias},
booktitle = {15th Annual IEEE International Conference and Workshop on the Engineering of Computer Based Systems (ECBS 2008)},
doi = {10.1109/ECBS.2008.55},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Bashroush et al. - 2008 - ALI An Extensible Architecture Description Language for Industrial Applications.pdf:pdf},
isbn = {978-0-7695-3141-0},
month = {mar},
pages = {297--304},
publisher = {Ieee},
title = {{ALI: An Extensible Architecture Description Language for Industrial Applications}},
year = {2008}
}
@article{garlan1994-aesop,
abstract = {As the design of software architectures emerges as a discipline within software engineering, it will become increasingly important to support architectural description and analysis with tools and environments. In this paper we describe a system for developing architectural design environments that exploit architectural styles to guide software architects in producing specific systems. The primary contributions of this research are: (a) a generic object model for representing architectural designs; (b) the characterization of architectural styles as specializations of this object model; and (c) a toolkit for creating an open architectural design environment from a description of a specific architectural style. We use our experience in implementing these concepts to illustrate how style-oriented architectural design raises new challenges for software support environments.},
author = {Garlan, David and Allen, Robert and Ockerbloom, John},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Garlan, Allen, Ockerbloom - 1994 - Exploiting style in architectural design environments.pdf:pdf},
journal = {ACM SIGSOFT Software Engineering Notes},
number = {Issue 5},
pages = {175 -- 188},
title = {{Exploiting style in architectural design environments}},
volume = {Volume 19},
year = {1994}
}
@inproceedings{bashroush2005-adlars,
abstract = {Software Product Line (SPL) Engineering has emerged to become a mature domain for maximizing reuse within the context of a family of related software products. Within the process of SPL, the variability and commonality among the different products within the scope of a family is captured and modeled into a systems feature model. Currently, there are no Architecture Description Languages (ADLs) that support the relationship between the feature model domain and the system architecture domain, leaving a gap which significantly increases the complexity of analyzing the systems architecture and insuring that it complies with its set feature model and variability requirements. In this paper we present ADLARS, an Architecture Description Language that supports the relationship between the systems feature model and the architectural structures in an attempt to alleviate the aforementioned problem. The link between the two spaces also allows the automatic generation of product architectures from the family reference architecture.},
author = {Bashroush, R. and Brown, T.J. and Spence, I. and Kilpatrick, P.},
booktitle = {29th Annual IEEE/NASA Software Engineering Workshop},
doi = {10.1109/SEW.2005.17},
file = {:Users/eoin/Dropbox/Work/PhDWork/Rabih-Resources/SoftwareArchitecture/ADL SLR/ADLARS-Bashroush.pdf:pdf},
isbn = {0-7695-2306-4},
pages = {163--173},
publisher = {Ieee},
title = {{ADLARS: An Architecture Description Language for Software Product Lines}},
year = {2005}
}
@inproceedings{garlan1997-acme,
abstract = {Numerous architectural description languages (ADLs) have been developed, each providing complementary capabilities for architectural development and analysis. Unfortunately, each ADL and supporting toolset operates in isolation, making it difficult to integrate those tools and share architectural descriptions. ACME is being developed as a joint effort of the software architecture research community as a common interchange format for architecture design tools. ACME provides a structural framework for characterizing architectures, together with annotation facilities for additional ADL-specific information. This scheme permits subsets of ADL tools to share architectural information that is jointly understood, while tolerating the presence of information that falls outside their common vocabulary. In this paper we describe ACME's key features, rationale, and technical innovations.},
address = {Toronto, Ontario},
author = {Garlan, David and Monroe, R and Wile, D},
booktitle = {CASCON '97 Proceedings of the 1997 conference of the Centre for Advanced Studies on Collaborative research},
editor = {Johnson, J. Howard},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Garlan, Monroe, Wile - 1997 - ACME An Architecture Description Interchange Language.pdf:pdf},
pages = {169--183},
publisher = {IBM Press},
title = {{ACME : An Architecture Description Interchange Language}},
year = {1997}
}
@techreport{feiler2006-aadl,
abstract = {In November 2004, the Society of Automotive Engineers (SAE) released the aerospace standard AS5506, named the Architecture Analysis {\&} Design Language (AADL). The AADL is a modeling language that supports early and repeated analyses of a system's architecture with respect to performance-critical properties through an extendable notation, a tool framework, and precisely defined semantics. The language employs formal modeling concepts for the description and analysis of application system architectures in terms of distinct components and their interactions. It includes abstractions of software, computational hardware, and system components for (a) specifying and analyzing real-time embedded and high dependability systems, complex systems of systems, and specialized performance capability systems and (b) mapping of software onto computational hardware elements. The AADL is especially effective for model-based analysis and specification of complex real- time embedded systems. This technical note is an introduction to the concepts, language structure, and application of the AADL.},
address = {Pittsburgh, Pennsylvania},
author = {Feiler, Peter H and Gluch, David P and Hudak, John J},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Feiler, Gluch, Hudak - 2006 - The Architecture Analysis {\&} Design Language ( AADL ) An Introduction.pdf:pdf},
institution = {Software Engineering Institute, Carnegie Mellon University},
number = {CMU/SEI-2006-TN-011},
pages = {CMU/SEI--2006--TN--011},
title = {{The Architecture Analysis {\&} Design Language ( AADL ): An Introduction}},
year = {2006}
}
