@techreport{feiler2006-aadl,
abstract = {In November 2004, the Society of Automotive Engineers (SAE) released the aerospace standard AS5506, named the Architecture Analysis {\&} Design Language (AADL). The AADL is a modeling language that supports early and repeated analyses of a system's architecture with respect to performance-critical properties through an extendable notation, a tool framework, and precisely defined semantics. The language employs formal modeling concepts for the description and analysis of application system architectures in terms of distinct components and their interactions. It includes abstractions of software, computational hardware, and system components for (a) specifying and analyzing real-time embedded and high dependability systems, complex systems of systems, and specialized performance capability systems and (b) mapping of software onto computational hardware elements. The AADL is especially effective for model-based analysis and specification of complex real- time embedded systems. This technical note is an introduction to the concepts, language structure, and application of the AADL.},
address = {Pittsburgh, Pennsylvania},
author = {Feiler, Peter H and Gluch, David P and Hudak, John J},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Feiler, Gluch, Hudak - 2006 - The Architecture Analysis {\&} Design Language ( AADL ) An Introduction.pdf:pdf},
institution = {Software Engineering Institute, Carnegie Mellon University},
number = {CMU/SEI-2006-TN-011},
pages = {CMU/SEI--2006--TN--011},
title = {{The Architecture Analysis {\&} Design Language ( AADL ): An Introduction}},
url = {http://www.sei.cmu.edu/library/abstracts/reports/06tn011.cfm},
year = {2006}
}
@inproceedings{garlan1997-acme,
abstract = {Numerous architectural description languages (ADLs) have been developed, each providing complementary capabilities for architectural development and analysis. Unfortunately, each ADL and supporting toolset operates in isolation, making it difficult to integrate those tools and share architectural descriptions. ACME is being developed as a joint effort of the software architecture research community as a common interchange format for architecture design tools. ACME provides a structural framework for characterizing architectures, together with annotation facilities for additional ADL-specific information. This scheme permits subsets of ADL tools to share architectural information that is jointly understood, while tolerating the presence of information that falls outside their common vocabulary. In this paper we describe ACME's key features, rationale, and technical innovations.},
address = {Toronto, Ontario},
author = {Garlan, David and Monroe, R and Wile, D},
booktitle = {CASCON '97 Proceedings of the 1997 conference of the Centre for Advanced Studies on Collaborative research},
editor = {Johnson, J. Howard},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Garlan, Monroe, Wile - 1997 - ACME An Architecture Description Interchange Language.pdf:pdf},
pages = {169--183},
publisher = {IBM Press},
title = {{ACME : An Architecture Description Interchange Language}},
url = {http://dl.acm.org/citation.cfm?id=782017},
year = {1997}
}
@inproceedings{bashroush2005-adlars,
abstract = {Software Product Line (SPL) Engineering has emerged to become a mature domain for maximizing reuse within the context of a family of related software products. Within the process of SPL, the variability and commonality among the different products within the scope of a family is captured and modeled into a systems feature model. Currently, there are no Architecture Description Languages (ADLs) that support the relationship between the feature model domain and the system architecture domain, leaving a gap which significantly increases the complexity of analyzing the systems architecture and insuring that it complies with its set feature model and variability requirements. In this paper we present ADLARS, an Architecture Description Language that supports the relationship between the systems feature model and the architectural structures in an attempt to alleviate the aforementioned problem. The link between the two spaces also allows the automatic generation of product architectures from the family reference architecture.},
author = {Bashroush, R. and Brown, T.J. and Spence, I. and Kilpatrick, P.},
booktitle = {29th Annual IEEE/NASA Software Engineering Workshop},
doi = {10.1109/SEW.2005.17},
file = {:Users/eoin/Dropbox/Work/PhDWork/Rabih-Resources/SoftwareArchitecture/ADL SLR/ADLARS-Bashroush.pdf:pdf},
isbn = {0-7695-2306-4},
pages = {163--173},
publisher = {Ieee},
title = {{ADLARS: An Architecture Description Language for Software Product Lines}},
url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=1521204},
year = {2005}
}
@article{garlan1994-aesop,
abstract = {As the design of software architectures emerges as a discipline within software engineering, it will become increasingly important to support architectural description and analysis with tools and environments. In this paper we describe a system for developing architectural design environments that exploit architectural styles to guide software architects in producing specific systems. The primary contributions of this research are: (a) a generic object model for representing architectural designs; (b) the characterization of architectural styles as specializations of this object model; and (c) a toolkit for creating an open architectural design environment from a description of a specific architectural style. We use our experience in implementing these concepts to illustrate how style-oriented architectural design raises new challenges for software support environments.},
author = {Garlan, David and Allen, Robert and Ockerbloom, John},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Garlan, Allen, Ockerbloom - 1994 - Exploiting style in architectural design environments.pdf:pdf},
journal = {ACM SIGSOFT Software Engineering Notes},
number = {Issue 5},
pages = {175 -- 188},
title = {{Exploiting style in architectural design environments}},
url = {http://dl.acm.org/citation.cfm?id=195404},
volume = {Volume 19},
year = {1994}
}
@inproceedings{bashroush2008-ali,
author = {Bashroush, Rabih and Spence, Ivor and Kilpatrick, Peter and Brown, T. John and Gilani, Wasif and Fritzsche, Mathias},
booktitle = {15th Annual IEEE International Conference and Workshop on the Engineering of Computer Based Systems (ECBS 2008)},
doi = {10.1109/ECBS.2008.55},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Bashroush et al. - 2008 - ALI An Extensible Architecture Description Language for Industrial Applications.pdf:pdf},
isbn = {978-0-7695-3141-0},
month = {mar},
pages = {297--304},
publisher = {Ieee},
title = {{ALI: An Extensible Architecture Description Language for Industrial Applications}},
url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=4492411},
year = {2008}
}
@inproceedings{ruscio2010-byadl,
address = {Cape Town, South Africa},
author = {Ruscio, Davide Di and Malavolta, Ivano},
booktitle = {32nd ACM/IEEE International Conference on Software Engineering},
editor = {Kramer, Jeff and Bishop, Judith},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Ruscio, Malavolta - 2010 - Developing next generation ADLs through MDE techniques.pdf:pdf},
isbn = {9781605587196},
keywords = {adl,metamodeling,model driven,software architecture},
pages = {85--94},
publisher = {ACM},
title = {{Developing next generation ADLs through MDE techniques}},
url = {http://ieeexplore.ieee.org/xpls/abs{\_}all.jsp?arnumber=6062076},
year = {2010}
}
@article{malavolta2010-modeltransformation,
author = {Malavolta, I. and Muccini, H. and Pelliccione, P. and Tamburri, D.a.},
doi = {10.1109/TSE.2009.51},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Malavolta et al. - 2010 - Providing Architectural Languages and Tools Interoperability through Model Transformation Technologies.pdf:pdf},
issn = {0098-5589},
journal = {IEEE Transactions on Software Engineering},
month = {jan},
number = {1},
pages = {119--140},
title = {{Providing Architectural Languages and Tools Interoperability through Model Transformation Technologies}},
url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=5204094},
volume = {36},
year = {2010}
}
@techreport{medvidovic2000-archintegn,
abstract = {Software architecture research has yielded a variety of powerful techniques for assisting in the design, implementation, and long-term evolution of complex, heterogeneous, distributed, multi-user applications. Since software development environments are themselves applications with these characteristics, it is natural to examine the effectiveness of an architectural approach to constructing and changing them. We report on our experience in creating a family of related environments in this manner. The environments encompass a range of services and include commercial off-the-shelf products as well as custom-built tools. The particular architectural approach adopted is fully reflexive: the environments are used in their own construction and evolution. We also report on some engineering experiences, in particular with our use of XML as the vehicle for supporting a common and extensible representation of architectural models, including the model of the environment itself. Generally applicable lessons from the experience are described.},
author = {Medvidovic, Nenad and Oreizy, Peyman and Taylor, RN and Khare, Rohit and Guntersdorfer, Michael},
doi = {10.1.1.224.7230},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Medvidovic et al. - 2000 - An Architecture-Centered Approach to Software Environment Integration.pdf:pdf},
institution = {Center for Software Engineering, University of Southern California},
keywords = {off-the-shelf reuse,software architectures,software environments,tool integration,xml},
pages = {Technical Report USC--CSE--00--516},
title = {{An Architecture-Centered Approach to Software Environment Integration}},
url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.224.7230},
year = {2000}
}
@article{Medvidovic1996b,
abstract = {Software architectures enable large-scale software development. Component reuse and substitutability, two key aspects of large-scale development, must be planned for during software design. Object-oriented (OO) type theory supports reuse by structuring inter-component relationships and verifying those relationships through type checking in an architecture definition language (ADL). In this paper, we identify the issues and discuss the ramifications of applying OO type theory to the C2 architectural style. This work stems from a series of experiments that were conducted to investigate component reuse and substitutability in C2. We also discuss the limits of applicability of OO typing to C2 and how we addressed them in the C2 ADL.},
author = {Medvidovic, Nenad and Oreizy, Peyman and Robbins, Jason E. and Taylor, Richard N.},
doi = {10.1145/250707.239106},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Medvidovic et al. - 1996 - Using object-oriented typing to support architectural design in the C2 style.pdf:pdf},
issn = {01635948},
journal = {ACM SIGSOFT Software Engineering Notes},
keywords = {and,architectural styles,cussion of component compositionality,dis-,it allows us to,link much of the,object-oriented typing,reusability,reuse,soft-,software architectures,tionships via type checking,ware design},
month = {nov},
number = {6},
pages = {24--32},
title = {{Using object-oriented typing to support architectural design in the C2 style}},
url = {http://portal.acm.org/citation.cfm?doid=250707.239106},
volume = {21},
year = {1996}
}
@inproceedings{medvidovic1996-dynadls,
address = {New York, New York, USA},
author = {Medvidovic, Nenad},
booktitle = {Joint proceedings of the second international software architecture workshop (ISAW-2) and international workshop on multiple perspectives in software development (Viewpoints '96) on SIGSOFT '96 workshops -},
doi = {10.1145/243327.243340},
editor = {Wolf, Alexander L. and Finkelstein, Anthony and Spanoudakis, George and Vidal, Laura},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Medvidovic - 1996 - ADLs and dynamic architecture changes.pdf:pdf},
isbn = {0897918673},
pages = {24--27},
publisher = {ACM Press},
title = {{ADLs and dynamic architecture changes}},
url = {http://portal.acm.org/citation.cfm?doid=243327.243340},
year = {1996}
}
@article{Braga2004,
abstract = {Software architecture description languages (ADL) allow a software designer to focus on high- level aspects of an application by abstracting from the details of the components that compose an architecture. It is precisely this abstraction that makes ADLs suitable for verification using model checking techniques. ADLs are, in a way, domain-specific languages for aspects such as coordination, distribution and quality-of-service. The CBabel ADL defines the concept of contracts that precisely captures these architecture-level aspects. In this paper we propose a rewriting semantics for CBabel, that is, a formal semantics for CBabel specified in rewriting logic, a unifying formalism for concurrency models that has interesting properties as a logic and semantic framework due to its unified view of computation and proof. Using the Maude system, a high-performance implementation of rewriting logic, we formally verify the producer-consumer-buffer problem using model checking and state search.},
author = {Braga, Christiano and Sztajnberg, Alexandre},
doi = {10.1016/j.entcs.2004.04.010},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Braga, Sztajnberg - 2004 - Towards a Rewriting Semantics for a Software Architecture Description Language.pdf:pdf},
issn = {15710661},
journal = {Electronic Notes in Theoretical Computer Science},
keywords = {architecture description languages,model checking,rewriting semantics},
month = {may},
pages = {149--168},
title = {{Towards a Rewriting Semantics for a Software Architecture Description Language}},
url = {http://linkinghub.elsevier.com/retrieve/pii/S1571066104050194},
volume = {95},
year = {2004}
}
@inproceedings{medvidovic1996-c2,
abstract = {Software architectures are multi-dimensional entities that can be fully understood only when viewed and analyzed at four different levels of abstraction: (1) internal functionality of a component, (2) the interface(s) exported by the component to the rest of the system, (3) interconnection of architectural elements in an architecture, and (4) rules of the architectural style. This paper presents the characteristics of each of the four levels of architectural abstraction, outlines the kinds of analyses that need to be performed at each level, and discusses the kinds of formal notations that are suitable at each level. We use the pipe-and-filter and Chiron-2 (C2) architectural styles as illustrations. In particular, we present formal models of C2 at the last three levels of abstraction as a first step in enabling a C2 design environment to perform the necessary analyses of architectures. We discuss the benefits of the formal definitions and our experience to date. 1 Keywords Software architectures, architectural styles, formalism, architecture definition languages, interface definition languages},
author = {Medvidovic, Nenad and Taylor, Richard N. and Whitehead, E. James},
booktitle = {California Software Symposium},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Medvidovic, Taylor, Whitehead - 1996 - Formal modeling of software architectures at multiple levels of abstraction.pdf:pdf},
keywords = {architectural styles,architecture definition languages,formalism,interface definition,software architectures},
pages = {28--40},
title = {{Formal modeling of software architectures at multiple levels of abstraction}},
url = {http://www.cs.ucsc.edu/{~}ejw/papers/medvidovic{\_}css96.pdf},
year = {1996}
}
@article{rademaker2005-cbabel,
author = {Rademaker, Alexandre and Braga, Christiano and Sztajnberg, Alexandre},
doi = {10.1016/j.entcs.2005.03.018},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Rademaker, Braga, Sztajnberg - 2005 - A Rewriting Semantics for a Software Architecture Description Language.pdf:pdf},
issn = {15710661},
journal = {Electronic Notes in Theoretical Computer Science},
month = {may},
pages = {345--377},
title = {{A Rewriting Semantics for a Software Architecture Description Language}},
url = {http://linkinghub.elsevier.com/retrieve/pii/S157106610500229X},
volume = {130},
year = {2005}
}
@misc{Vulgarakis,
author = {Vulgarakis, Aneta},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Vulgarakis - Unknown - Component Models Overview.ppt:ppt},
title = {{Component Models Overview}}
}
@inproceedings{magee1994-regis,
abstract = {Regis is a programming environment aimed at supporting the development and execution of parallel and distributed programs. It embodies a constructive approach to the development of programs based on separating program structure from communication and computation. The emphasis is on constructing programs from multiple parallel computational components which cooperate to achieve the overall goal. The environment is designed to easily accommodate multiple communication mechanisms and primitives. Both the computational and communication elements of Regis programs are programmed in the object oriented programming language C++. The elements are combined into parallel and distributed programs using the configuration language Darwin. The paper describes programming in Regis through a set of small example programs.},
author = {Magee, J. and Dulay, N. and Kramer, J.},
booktitle = {2nd International Workshop on Configurable Distributed Systems},
doi = {10.1109/IWCDS.1994.289940},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Magee, Dulay, Kramer - 1994 - A constructive development environment for parallel and distributed programs.pdf:pdf},
isbn = {0-8186-5390-6},
keywords = {communication,distributed programming,inter-process,parallel programming,parallel programming language,software development},
pages = {4--14},
publisher = {IEEE},
title = {{A constructive development environment for parallel and distributed programs}},
url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=289940},
year = {1994}
}
@inproceedings{pinto2003-daopadl,
abstract = {Architecture description languages deal with the description, analysis and reuse of software architectures. This paper describes DAOP-ADL, a component- and aspect-based language to specify the architecture of an application in terms of components, aspects and a set of plug-compatibility rules between them. With the aim of connecting the specification of the application architecture to the implementation, we describe our language using XML and XML Schemas. The DAOP-ADL language was designed to be interpreted by DAOP, our own dynamic component- and aspect-oriented platform. DAOP provides a composition mechanism that plugs aspects into components dynamically at runtime. The software architect will use the DAOP-ADL language at design time to describe the architecture of the application. Later this architectural information is loaded into the DAOP platform, which needs it to establish the dynamic connections between autonomous components and aspects. Therefore, the use of DAOP-ADL closes the gap between design and implementation of component- and aspect-based applications.},
address = {Erfurt, Germany},
author = {Pinto, Monica and Fuentes, Lidia and Troya, Jose-Maria},
booktitle = {2nd international conference on Generative programming and component engineering (GPCE '03)},
editor = {Pfenning, Frank and Smaragdakis, Yannis},
file = {:Users/eoin/Dropbox/Work/PhDWork/ADL-LitReview/ADL-Papers/DAOP-ADL-PintoEtAl.pdf:pdf},
pages = {118--137},
publisher = {Springer-Verlag},
title = {{DAOP-ADL : An Architecture Description Language for Dynamic Component and Aspect-Based Development}},
url = {http://dl.acm.org/citation.cfm?id=954186.954194},
year = {2003}
}
@inproceedings{magee1995-darwin,
address = {Essen, Germany},
author = {Magee, Jeff and Dulay, Naranker and Eisenbach, Susan and Kramer, Jeff},
booktitle = {5th European Software Engineering Conference (ESEC1995)},
doi = {10.1.1.25.7933},
editor = {Sch{\"{a}}fer, Wilhelm and Botella, Pere},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Magee et al. - 1995 - Specifying Distributed Software Architectures(2).pdf:pdf},
keywords = {LNCS6093},
pages = {137--153},
publisher = {Springer-Verlag},
title = {{Specifying Distributed Software Architectures}},
url = {http://dl.acm.org/citation.cfm?id=651497},
year = {1995}
}
@article{magee1996-darwin,
author = {Magee, Jeff and Kramer, Jeff},
doi = {10.1145/250707.239104},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Magee, Kramer - 1996 - Dynamic structure in software architectures.pdf:pdf},
isbn = {0897917979},
issn = {01635948},
journal = {ACM SIGSOFT Software Engineering Notes},
month = {nov},
number = {6},
pages = {3--14},
title = {{Dynamic structure in software architectures}},
url = {http://portal.acm.org/citation.cfm?doid=250707.239104},
volume = {21},
year = {1996}
}
@inproceedings{zheng2010-dpdadl,
abstract = {Architecture description language (ADL) provides a linguistic approach to represent software architecture. Usually, it has to develop a new ADL for a particular domain. Some domains are difficult to develop the ADLs, e.g. data processing domain (DPD). Since the products of these domains can apply to many different areas as a sub module, which complicates the architecture abstraction. This paper shows the development of our ADL for data processing domain. It has domain independence meta model concept, and it supports variability description and the code generation rules have been indicated too. Our data processing product line can be described by this ADL and generate product code, which will improve the productivity.},
author = {Zheng, Li and Wu, Zhanwei and Zhang, Chao and Yang, Fang},
booktitle = {2010 Seventh International Conference on Information Technology},
doi = {10.1109/ITNG.2010.25},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Zheng et al. - 2010 - Developing an Architecture Description Language for Data Processing Product Line.pdf:pdf},
isbn = {978-1-4244-6270-4},
keywords = {adl,dsm,mda,software architecture,software product line},
pages = {944--949},
publisher = {IEEE},
title = {{Developing an Architecture Description Language for Data Processing Product Line}},
url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=5501510},
year = {2010}
}
@inproceedings{Ng1995,
abstract = {This paper describes work on the application of visual techniques to the design and construction of parallel and distributed programs. In particular, it looks at how the software architectural view can be effectively utilised to provide a common framework for integrating the various software development activities, ranging from early, informal program design to the evolution of the running program. A prototype visual programming environment-the Software Architect's Assistant-has been built for the design and development of Regis distributed programs. It provides the user with automated, intelligent assistance throughout the software design process. Facilities provided include the display of integrated graphical and textual views, a flexible mechanism for recording design information and the automatic generation of program code and formatted reports from design diagrams. Software reuse is also supported through the use of component libraries. Support for graphical monitoring and management of running programs, currently provided by a complementary tool, will be integrated into the environment to provide a complete solution for visual distributed programming.},
address = {Wailea, HI},
author = {Ng, Keng and Kramer, Jeff and Magee, Jeff and Dulay, Naranker},
booktitle = {Twenty-Eighth Hawaii International Conference on System Sciences},
doi = {10.1109/HICSS.1995.375454},
editor = {Mudge, Trevor and Shriver, Bruce and El-Rewini, Hesham and Nunamaker, J. F. and Sprague, Ralph and {Lawrence Hunter}},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Ng et al. - 1995 - The Software Architect's Assistant-a visual environment for distributed programming.pdf:pdf},
isbn = {0-8186-6935-7},
pages = {254--263},
publisher = {IEEE Computer Society Press},
title = {{The Software Architect's Assistant-a visual environment for distributed programming}},
url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=375454},
volume = {2},
year = {1995}
}
@techreport{poizat2007-kadl,
abstract = {This report presents the cash-point case study and mainly describes its specifications with the KADL ADL. The language is a mixed of state transition diagrams, abstract datatype and modal logic. We emphasize the need for abstract and formal descriptions especially communication architectures. We also gives some proofs done using our specific tool based on symbolic transition systems. Last we discuss previous specifications for this case study.},
author = {Poizat, Pascal and Royer, Jean-claude},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Poizat, Royer - 2007 - KADL Specification of The Cash Point Case Study.pdf:pdf},
institution = {IBISC},
keywords = {Abstract Data Type,Architectural Description Language,Cash Point Case Study,Component Based Software Engineering,Symbolic Transition Systems,Verification},
number = {00},
pages = {00.0},
title = {{KADL Specification of The Cash Point Case Study}},
url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.77.3130},
year = {2007}
}
@article{vanommering2000-koala,
abstract = {Most consumer electronics today contain embedded software. In the early days, developing CE software presented relatively minor challenges, but in the past several years three significant problems have arisen: size and complexity of the software in individual products; the increasing diversity of products and their software; and the need for decreased development time. The question of handling diversity and complexity in embedded software at an increasing production speed becomes an urgent one. The authors present their belief that the answer lies not in hiring more software engineers. They are not readily available, and even if they were, experience shows that larger projects induce larger lead times and often result in greater complexity. Instead, they believe that the answer lies in the use and reuse of software components that work within an explicit software architecture. The Koala model, a component-oriented approach detailed in this article, is their way of handling the diversity of software in consumer electronics. Used for embedded software in TV sets, it allows late binding of reusable components with no additional overhead},
author = {van Ommering, R. and van der Linden, F. and Kramer, J. and Magee, J.},
doi = {10.1109/2.825699},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/van Ommering et al. - 2000 - The Koala component model for consumer electronics software.pdf:pdf},
issn = {00189162},
journal = {Computer},
month = {mar},
number = {3},
pages = {78--85},
title = {{The Koala component model for consumer electronics software}},
url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=825699},
volume = {33},
year = {2000}
}
@inproceedings{asikainen2004-koala,
abstract = {An approach for modelling configurable software product families (CSPFs) and for automated configuring of product individuals using the models is presented. It is based on a similar approach for configuring physical products. The conceptual foundation and syntax of the Koalish modelling language used for this purpose are defined. The language extends Koala, a component model and architecture description language, with explicit variation modelling mecha- nisms. Koalish is further provided a formal semantics by defining a translation from it to Weight Constraint Rule Language (WCRL), a form of logic pro- grams. This allows using an existing inference tool for WCRL, smodels, to im- plement the reasoning needed in the configurator. The configurator is able to construct all valid product individuals, with respect to a Koalish model of a CSPF, that satisfy a given set of requirements. The implemented functionality of the configurator has been tested using small-scale toy examples, for which it performs adequately.},
author = {Asikainen, Timo and Soininen, Timo and M{\"{a}}nnist{\"{o}}, Tomi},
booktitle = {Software Product Family Engineering, LNCS 3014},
doi = {10.1007/978-3-540-24667-1_28},
editor = {Linden, Frank},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Asikainen, Soininen, M{\"{a}}nnist{\"{o}} - 2004 - A Koala-based approach for modelling and deploying configurable software product families.pdf:pdf},
pages = {225--249},
publisher = {Springer Berlin Heidelberg},
title = {{A Koala-based approach for modelling and deploying configurable software product families}},
url = {http://www.springerlink.com/index/nhekwtmm45g4gtll.pdf},
year = {2004}
}
@article{poizat2006-kadl,
abstract = {Component Based Software Engineering has now emerged as a discipline for system development. After years of battle between component platforms, the need for means to abstract away from specific implementation details is now recognized. This paves the way for model driven approaches (such as MDE) but also for the more older Architectural Description Language (ADL) paradigm. In this paper we present KADL, an ADL based on the Korrigan formal language which supports the following features: integration of fully formal behaviours and data types, expressive component compo- sition mechanisms through the use of modal logic, specification readability through graphical notations, and dedicated architectural analysis techniques.},
author = {Poizat, Pascal and Royer, JC},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Poizat, Royer - 2006 - A Formal Architectural Description Language based on Symbolic Transition Systems and Modal Logic.pdf:pdf},
journal = {Journal of Universal Computer Science},
keywords = {abstract data,architectural description language,category,component based software engineering,graphical notations,mixed formal specifications,modal logic glue,symbolic transition systems,types,verification},
number = {12},
pages = {1741--1782},
title = {{A Formal Architectural Description Language based on Symbolic Transition Systems and Modal Logic}},
url = {http://www.jucs.org/jucs{\_}12{\_}12/a{\_}formal{\_}architectural{\_}description/jucs{\_}12{\_}12{\_}1741{\_}1782{\_}poizat.pdf},
volume = {12},
year = {2006}
}
@article{Choppy2001,
abstract = {This paper presents an environment to support the use of specification for mixed systems, i.e. systems with both dynamic (behaviour, communication, concurrency) and static (data type) aspects. We provide an open and extensible environment based on the KORRIGAN specification model. This model uses a hierarchy of view concepts to specify data types, behaviours and compositions in a uniform way. The key notion behind a view is the symbolic transition system. A good environment supporting such a model needs to interface with existing languages and tools. At the core of our environment is the CLIS library which is devoted to the representation of our view concepts and existing specification languages. Our environment is implemented using the object-oriented language PYTHON. It provides an integration process for new tools, a specification library, a parser library, LOTOS generation and object-oriented code generation for KORRIGAN specifications.},
author = {Choppy, C and Poizat, P and Royer, JC},
doi = {10.3217/jucs-007-01-0019},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Choppy, Poizat, Royer - 2001 - The Korrigan Environment.pdf:pdf},
journal = {Journal of Universal Computer Science},
number = {1},
pages = {19--36},
title = {{The Korrigan Environment}},
url = {http://jucs.org/jucs{\_}7{\_}1/the{\_}korrigan{\_}environment/Choppy{\_}Ch.pdf},
volume = {7},
year = {2001}
}
@article{smeda2005-madl2,
abstract = {The techniques of meta-modeling and meta-levels have become a mature concept and have been largely used to solve real problems in programming languages, distributed environments, knowledge representation, or data bases. In this article it is shown how the same techniques can be applied in component-based software architecture. It also shown the need to propose mechanisms of reflexivity within the domain of software architecture meta-modeling. The outcome of this is a meta-meta-architecture with a minimal core whose finality is to define meta-components, meta-connectors and meta-architectures. Call this meta-meta-architecture MADL (Meta Architecture Description Language).},
author = {Smeda, Adel and Khammaci, Tahar and Oussalah, Mourad},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Smeda, Khammaci, Oussalah - 2005 - Meta Architecting Towards a New Generation of Architecture Description Languages.pdf:pdf},
journal = {Journal of Computer Science},
keywords = {architecture description languages,component-based systems,software architecture},
number = {4},
pages = {454--460},
title = {{Meta Architecting : Towards a New Generation of Architecture Description Languages}},
url = {http://www.doaj.org/doaj?func=abstract{\&}id=1099285},
volume = {1},
year = {2005}
}
@inproceedings{smeda2005-madl,
abstract = {As the concept of meta-classes was introduced in order to permit the manipulation of classes, we introduce the concept of meta-components, meta-connectors, and meta- architectures to permit the manipulation and the redefinition of architectural elements (structural and behavioral). In this article we present a meta-meta- architecture called MADL (Meta Architecture Description Language) to abstract the notions of architectures (components, connectors, architectures), hence to facilitate their manipulation, reuse, and evolution; and also to ease (hence encourage) the transformation and comparison among ADLs.},
address = {Mt. Pleasant, MI, USA},
author = {Smeda, Adel and Oussalah, Mourad and Khammaci, Tahar},
booktitle = {Third ACIS Int'l Conference on Software Engineering Research, Management and Applications (SERA'05)},
doi = {10.1109/SERA.2005.50},
editor = {Malloy, Brian},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Smeda, Oussalah, Khammaci - 2005 - MADL Meta Architecture Description Language.pdf:pdf},
isbn = {0-7695-2297-1},
keywords = {architecture description languages,architectures,component,component-based software architecture,connectors,meta-modeling},
pages = {152--159},
publisher = {IEEE},
title = {{MADL: Meta Architecture Description Language}},
url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=1563156},
year = {2005}
}
@article{binns1996-metah,
author = {Binns, Pam and Englehart, Matt and Jackson, Mike and Vestal, Steve},
doi = {10.1142/S0218194096000107},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Binns et al. - 1996 - DOMAIN-SPECIFIC SOFTWARE ARCHITECTURES FOR GUIDANCE, NAVIGATION AND CONTROL.pdf:pdf},
issn = {0218-1940},
journal = {International Journal of Software Engineering and Knowledge Engineering},
month = {jun},
number = {02},
pages = {201--227},
title = {{Domain Specific Software Architectures for Guidance, Navigation and Control}},
url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.25.8278 http://www.worldscientific.com/doi/abs/10.1142/S0218194096000107},
volume = {06},
year = {1996}
}
@misc{Vestal2004,
abstract = {The increasing complexity of embedded systems is driving development of improved architectural modeling and analysis approaches that make building systems faster, less expensive, and more predictable. Honeywell's MetaH was the first comprehensive toolset to tackle the issues of integrated modeling, analysis, system integration and verification. Today, MetaH is both the foundation of the SAE AADL (Architecture Analysis and Design Language)—an emerging standard language for specifying embedded computer system architectures including both functional and non-functional behaviors and properties—and the primary AADL toolset. It accepts specifications written in AADL and performs a variety of verification, modeling, analysis, and code generation activities. AADL allows the architecture of a real-time, safety-critical embedded system to be specified as an assembly of communicating components, where component functional interfaces and timing and safety behaviors and properties can be precisely defined. MetaH includes tools to perform schedulability analysis, reliability analysis, partition isolation analysis, and compliance checking of source code against AADL specifications. MetaH also automatically configures a middleware layer integrating all components, and generates and verifies a hybrid automata model of core middleware scheduling and security code.},
author = {Vestal, Steve},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Vestal - 2004 - The MetaH AADL Toolset.pdf:pdf},
pages = {2},
title = {{The MetaH AADL Toolset}},
url = {http://www.honeywell.com/sites/docs/DKRHVMR134XK8DQRHFA5JVOVUZQ23EN0K.pdf},
year = {2004}
}
@incollection{klein2010-model,
author = {Klein, Peter},
booktitle = {Graph transformations and model-driven engineering},
file = {:Users/eoin/Dropbox/Work/PhDWork/ADL-LitReview/ADL-Papers/MoDeL-Klein-LNCS-5765.pdf:pdf},
pages = {249--273},
publisher = {Springer-Verlag},
title = {{The architecture description language model}},
url = {http://www.springerlink.com/index/2K65413251M333RP.pdf},
year = {2010}
}
@inproceedings{oquendo2004-archware,
address = {St Andrews, Scotland},
author = {Oquendo, Flavio and Warboys, Brian and Morrison, Ron and Dindeleux, Régis and Gallo, Ferdinando and Garavel, Hubert and Occhipinti, Carmen},
booktitle = {EWSA 2004, LNCS 3047},
doi = {10.1007/978-3-540-24769-2_23},
editor = {Oquendo, Flavio and Warboys, Brian and Morrison, Ron},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Oquendo et al. - 2004 - ARCHWARE Architecting Evolvable Software.pdf:pdf},
pages = {257--271},
title = {{ARCHWARE: Architecting Evolvable Software}},
url = {http://www.springerlink.com/index/99hd3yhbchhtx4yk.pdf},
year = {2004}
}
@article{oquendo2004-piadl,
abstract = {A key aspect of the design of any software system is its architecture. An architecture description, from a runtime perspective, should provide a formal specification of the architecture in terms of components and connectors and how they are composed together. Further, a dynamic architecture description must provide a specification of how the architecture of the software system can change at runtime. Enabling specification of dynamic architectures is a large challenge for an Architecture Description Language (ADL). This paper presents how $\pi$-ADL, a novel ADL that has been designed in the ArchWare European Project, can be used for specifying dynamic architectures through a case study. While most ADLs focus on describing software architectures from a structural viewpoint, $\pi$-ADL focuses on formally describing architectures encompassing both the structural and behavioural viewpoints. The $\pi$-ADL toolset is outlined.},
author = {Oquendo, Flavio},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Oquendo - 2004 - Formally Describing Dynamic Software Architectures with $\pi$-ADL.pdf:pdf},
journal = {World Scientific and Engineering Transactions on Systems},
month = {jun},
number = {8},
pages = {673--679},
title = {{Formally Describing Dynamic Software Architectures with $\pi$-ADL}},
url = {http://www.wseas.us/e-library/conferences/brazil2004/papers/470-154.pdf},
volume = {3},
year = {2004}
}
@inproceedings{gruhn2005-conmoto,
abstract = {In this paper we motivate an Architecture Description Language (ADL) for mobile distributed systems based on the $\pi$-calculus. Different from other approaches, the non-functional properties, which are essential when mobile architectures are described, are treated in a flexible manner by inserting logical formulae for expressing and checking non-functional properties into $\pi$-calculus processes. A formal example is given to illustrate the approach before the constituents of the ADL are sketched.},
address = {Pisa},
author = {Gruhn, Volker and Schafer, Clemens},
booktitle = {2nd European Workshop on Software Architecture (EWSA 2005)},
editor = {Morrison, Ron and Oquendo, Flavio},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Gruhn, Schafer - 2005 - Architecture Description for Mobile Distributed Systems.pdf:pdf},
isbn = {978-3-540-26275-6},
keywords = {LNCS 3527},
mendeley-tags = {LNCS 3527},
pages = {239--246},
publisher = {Springer Berlin / Heidelberg},
title = {{Architecture Description for Mobile Distributed Systems}},
year = {2005}
}
@article{Oquendo2006,
abstract = {Software systems have become increasingly complex and are often used in highly dynamic, distributed and mobile environments. Formal development of such software systems in order to guarantee their completeness and correctness is a large research challenge. This article presents the $\pi$-Method, a novel formal method that has been designed in the ArchWare European Project to address model-driven development of safe software systems. It is a well-founded theoretically method relying on formal foundations: its formal language for architecture description is based on the $\pi$-calculus, for architecture analysis on the $\mu$-calculus, and for architecture transformation and refinement on the rewriting logic. The $\pi$-Method, like formal methods such as B, FOCUS, VDM, and Z, aims to provide full support for formal development of software systems. However, unlike these methods that do not provide any architectural support, the $\pi$-Method has been built from scratch to formally support architecture-centric component-based model-driven development. Furthermore, a major impetus behind defining formal languages and method is that their formality renders them suitable to be manipulated by software tools. Indeed, a comprehensive toolset supporting formal model-driven engineering has been developed.},
author = {Oquendo, Flavio},
doi = {10.1145/1127878.1127885},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Oquendo - 2006 - $\pi$-Method a model-driven formal method for architecture-centric software engineering.pdf:pdf},
issn = {01635948},
journal = {ACM SIGSOFT Software Engineering Notes},
keywords = {analysis languages,archi- lution process,architecture description languages,architecture transformation,architecture why architecture-centric,component-based software,emerged as an important,engineering,formal methods,model-driven development,refinement software architecture has,subdiscipline,tecture-centric software engineering},
month = {may},
number = {3},
pages = {1--13},
title = {{$\pi$-Method: a model-driven formal method for architecture-centric software engineering}},
url = {http://portal.acm.org/citation.cfm?doid=1127878.1127885},
volume = {31},
year = {2006}
}
@misc{Oquendo2005,
author = {Oquendo, Prof Flavio},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Oquendo - 2005 - Tutorial on ArchWare ADL – Version 2 ( $\pi$-ADL Tutorial ).pdf:pdf},
title = {{Tutorial on ArchWare ADL – Version 2 ( $\pi$-ADL Tutorial )}},
year = {2005}
}
@article{luckham1995-rapide,
abstract = {This paper discusses general requirements for architecture definition languages, and describes the syntax and semantics of the subset of the Rapide language that is designed to satisfy these requirements. Rapide is a concurrent event-based simulation language for defining and simulating the behavior of system architectures. Rapide is intended for modelling the architectures of concurrent and distributed systems, both hardware and software in order to represent the behavior of distributed systems in as much detail as possible. Rapide is designed to make the greatest possible use of event-based modelling by producing causal event simulations. When a Rapide model is executed it produces a simulation that shows not only the events that make up the model's behavior, and their timestamps, but also which events caused other events, and which events happened independently. The architecture definition features of Rapide are described: event patterns, interfaces, architectures and event pattern mappings. The use of these features to build causal event models of both static and dynamic architectures is illustrated by a series of simple examples from both software and hardware. Also we give a detailed example of the use of event pattern mappings to define the relationship between two architectures at different levels of abstraction. Finally, we discuss briefly how Rapide is related to other event-based languages.},
author = {Luckham, DC and Vera, James},
doi = {10.1109/32.464548},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Luckham, Vera - 1995 - An event-based architecture definition language.pdf:pdf},
issn = {00985589},
journal = {IEEE Transactions on Software Engineering},
keywords = {architecture,architecture de nition languages,causal-,concur-,event patterns,formal constraints,par-,prototyping,rapide,rency,simulation,tially ordered event sets},
number = {9},
pages = {717--734},
title = {{An event-based architecture definition language}},
url = {http://ieeexplore.ieee.org/xpls/abs{\_}all.jsp?arnumber=464548 http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=464548},
volume = {21},
year = {1995}
}
@techreport{moriconi1997-sadl,
author = {Moriconi, Mark and Riemenschneider, R A},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Moriconi, Riemenschneider - 1997 - Introduction to SADL 1 .0 A Language for Specifying Software Architecture Hierarchies.pdf:pdf},
institution = {Computer Science Laboratory, SRI International},
pages = {SRI--CSL--97--01},
title = {{Introduction to SADL 1 .0: A Language for Specifying Software Architecture Hierarchies}},
url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.141.1060},
year = {1997}
}
@article{moriconi1995-archrefinement,
abstract = {method is presented for the stepwise refinement of an abstract architecture into a relatively correct lower level architecture that is intended to implement it. A refinement step involves the application of a predefined refinement pattern that provides a routine solution to a standard architectural design problem. A pattern contains an abstract architecture schema and a more detailed schema intended to implement it. The two schemas usually contain very different architectural concepts (from different architectural styles). Once a refinement pattern is proven correct, instances of it can be used without proof in developing specific architectures. Individual refinements are compositional, permitting incremental development and local reasoning. A special correctness criterion is defined for the domain of software architecture, as well as an accompanying proof technique. A useful syntactic form of correct composition is defined. The main points are illustrated by means of familiar architectures for a compiler. A prototype implementation of the method has been used successfully in a real application.},
author = {Moriconi, M. and Qian, X. and Riemenschneider, R.a.},
doi = {10.1109/32.385972},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Moriconi, Qian, Riemenschneider - 1995 - Correct architecture refinement.pdf:pdf},
issn = {00985589},
journal = {IEEE Transactions on Software Engineering},
keywords = {Software architecture,composition.,formal methods,hierarchy,refinement patterns,relative correctness,stepwise refinement},
month = {apr},
number = {4},
pages = {356--372},
title = {{Correct architecture refinement}},
url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=385972},
volume = {21},
year = {1995}
}
@inproceedings{clements1996-adlsurvey,
abstract = {Architecture Description Languages (ADLs) are emerging as viable tools for formally representing the architectures of systems. While growing in number, they vary widely in terms of the abstractions they support and analysis capabilities they provide. Further, many languages not originally designed as ADLs serve reasonably well at representing and analyzing software architectures. This paper summarizes a taxonomic survey of ADLs that is in progress. The survey characterizes ADLs in terms of (a) the classes of systems they support; (b) the inherent properties of the languages themselves; and (c) the process and technology support they provide to represent, refine, analyze, and build systems from an architecture. Preliminary results allow us to draw conclusions about what constitutes an ADL, and how contemporary ADLs differ from each other.},
author = {Clements, Paul C},
booktitle = {8th International Workshop on Software Specification and Design (IWSSD 96)},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Clements - 1996 - A Survey of Architecture Description Languages.pdf:pdf},
month = {mar},
pages = {16--25},
publisher = {IEEE Computer Society},
title = {{A Survey of Architecture Description Languages}},
url = {http://dl.acm.org/citation.cfm?id=858261},
year = {1996}
}
@inproceedings{Faulkner2003,
abstract = {Multi-Agent Systems, Architectural Description Language, BDI Agent Model, System Architecture This paper identifies the foundations for an architectural description language (ADL) to specify multi-agent system architectures for information systems. We propose a set of system architectural concepts based on the BDI agent model and existing classical ADLs. We then conceptualize SKwyRL-ADL, aimed at capturing a "core" set of structural and behavioral concepts, including relationships that are fundamental in architecture description for BDI-MAS. We partially apply our ADL on a peer-to-peer document sharing example.},
address = {Angers, France},
author = {Faulkner, S and Kolp, Manuel},
booktitle = {5th International Conference on Enterprise Information Systems (ICEIS 03)},
editor = {Camp, Olivier and Piattini, Mario},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Faulkner, Kolp - 2003 - Towards an agent architectural description language for information systems.pdf:pdf},
keywords = {adl,architectural description language,based on,bdi agent model,description language,foundations for an architectural,multi-agent systems,of system architectural concepts,system architecture,system architectures for information,systems,this paper identifies the,to specify multi-agent,we propose a set},
pages = {59--66},
publisher = {Kluwer},
title = {{Towards an agent architectural description language for information systems}},
url = {http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.12.6697{\&}rep=rep1{\&}type=pdf},
year = {2003}
}
@techreport{fuxman2000-adlsurvey,
abstract = {In the last few years, a considerable number of architecture description languages (ADLs) have been proposed for describing and reasoning about software architectures. In this work, we classify and compare several ADLs placing emphasis on their features for formal modelling and analysis.},
author = {Fuxman, Arel D.},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Fuxman - 2000 - A Survey of Architecture Description Languages.pdf:pdf},
institution = {Dept of Computer Science, University of Toronto},
pages = {CSRG--407},
title = {{A Survey of Architecture Description Languages}},
url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.26.7113 http://www.cs.toronto.edu/{~}chechik/courses99/csc2108/projects/index.html http://www.cs.toronto.edu/pub/reports/csrg/407/},
year = {2000}
}
@inproceedings{kamal2007-adlpatterns,
abstract = {Architecture patterns provide solutions to recurring design problems at the architecture level. In order to model patterns during software architecture design, one may use a number of existing Architecture Description Languages (ADLs), including the UML, a generic language but also a de facto industry standard. Unfortunately, there is little explicit support offered by such languages to model architecture patterns, mostly due to the inherent variability that patterns entail. In this paper, we analyze the support that few selected languages offer in modeling a limited set of architecture patterns with respect to four specific criteria: syntax, visualization, variability, and extensibility. The results highlight the strengths and weaknesses of the selected ADLs for modeling architecture patterns in software design.},
address = {Luxembourg},
author = {Kamal, Ahmad Waqas and Avgeriou, Paris},
booktitle = {4th International Workshop on Rapid Integration of Software Engineering techniques (RISE07)},
editor = {Guelfi, Nicolas},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Kamal, Avgeriou - 2007 - An Evaluation of ADLs on Modeling Patterns for Software Architecture.pdf:pdf},
keywords = {ADLs,Architecture Patterns,Modeling,Software Architecture,UML.},
publisher = {Springer-Verlag},
title = {{An Evaluation of ADLs on Modeling Patterns for Software Architecture}},
year = {2007}
}
@inproceedings{medvidovic1997-adldomains,
abstract = {Software architectures shift the focus of developers from lines-of-code to coarser-grained elements and their interconnection structure. Architecture description languages (ADLs) have been proposed as domain-specific languages for the domain of software architecture. There is still little consensus in the research community on what problems are most important to address in a study of software architecture, what aspects of an architecture should be modeled in an ADL, or even what an ADL is. To shed light on these issues, we provide a framework of architectural domains, or areas of concern in the study of software architectures. We evaluate existing ADLs with respect to the framework and study the relationship between architectural and application domains. One conclusion is that, while the architectural domains perspective enables one to approach architectures and ADLs in a new, more structured manner, further understanding of architectural domains, their tie to application domains, and their specific influence on ADLs is needed.},
address = {Santa Barbara, California},
author = {Medvidovic, Nenad and Rosenblum, David S.},
booktitle = {Conference on Domain-Specific Languages on Conference on Domain-Specific Languages (DSL97)},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Medvidovic, Rosenblum - 1997 - Domains of concern in software architectures and architecture description languages.pdf:pdf},
isbn = {0897918673},
keywords = {architectural domain,architecture description language,domain,domain-specific language,software architecture},
pages = {16},
publisher = {ACM Press},
title = {{Domains of concern in software architectures and architecture description languages}},
url = {http://portal.acm.org/citation.cfm?doid=243327.243626},
year = {1997}
}
@article{medvidovic2000-adlcomparison,
abstract = {Software architectures shift the focus of developers from lines-of-code to coarser-grained architectural elements and their overall interconnection structure. Architecture description languages (ADLs) have been proposed as modeling notations to support architecture-based development. There is, however, little consensus in the research community on what is an ADL, what aspects of an architecture should be modeled in an ADL, and which of several possible ADLs is best suited for a particular problem. Furthermore, the distinction is rarely made between ADLs on one hand and formal specification, module interconnection, simulation and programming languages on the other. This paper attempts to provide an answer to these questions. It motivates and presents a definition and a classification framework for ADLs. The utility of the definition is demonstrated by using it to differentiate ADLs from other modeling notations. The framework is used to classify and compare several existing ADLs, enabling us, in the process, to identify key properties of ADLs. The comparison highlights areas where existing ADLs provide extensive support and those in which they are deficient, suggesting a research agenda for the future},
author = {Medvidovic, Nenad and Taylor, RN},
doi = {10.1109/32.825767},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Medvidovic, Taylor - 2000 - A Classification and Comparison Framework for Software Architecture Description Languages.pdf:pdf},
journal = {IEEE Transactions on Software Engineering},
number = {1},
pages = {70--93},
title = {{A Classification and Comparison Framework for Software Architecture Description Languages}},
url = {http://ieeexplore.ieee.org/xpls/abs{\_}all.jsp?arnumber=825767},
volume = {26},
year = {2000}
}
@article{medvidovic1997-adlclassification,
abstract = {Software architectures shift developers' focus from lines-of-code to coarser-grained architectural elements and their interconnection structure. Architec- ture description languages (ADLs) have been proposed as modeling notations to support architecture-based development. There is, however, little consensus in the research community on what is an ADL, what aspects of an architecture should be modeled in an ADL, and which ADL is best suited for a particular problem. Fur- thermore, the distinction is rarely made between ADLs on one hand and formal specification, module interconnection, simulation, and programming languages on the other. This paper attempts to provide an answer to these questions. It motivates and presents a definition and a classification framework for ADLs. The utility of the definition is demonstrated by using it to differentiate ADLs from other modcling notations. The framework is used to classify and compare several existing ADLs.},
author = {Medvidovic, Nenad and Taylor, Richard N.},
doi = {10.1145/267896.267903},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Medvidovic, Taylor - 1997 - A framework for classifying and comparing architecture description languages.pdf:pdf},
issn = {01635948},
journal = {ACM SIGSOFT Software Engineering Notes},
keywords = {architecture description languages,classification,comparison,definition,software architecture},
month = {nov},
number = {6},
pages = {60--76},
title = {{A framework for classifying and comparing architecture description languages}},
url = {http://portal.acm.org/citation.cfm?doid=267896.267903},
volume = {22},
year = {1997}
}
@techreport{vestal1993-fouradls,
author = {Vestal, Steve},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Vestal - 1993 - A Cursory Overview and Comparison of Four Architecture Description Languages.pdf:pdf},
institution = {Honeywell Technology Center},
title = {{A Cursory Overview and Comparison of Four Architecture Description Languages}},
url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.6.9755},
year = {1993}
}
@article{shaw1995-abstractions,
abstract = {Architectures for software use rich abstractions and idioms to describe system components, the nature of interactions among the components, and the patterns that guide the composition of components into systems. These abstractions are higher level than the elements usually supported by programming languages and tools. They capture packaging and interaction issues as well as computational functionality. Well-established (if informal) patterns guide the architectural design of systems. We sketch a model for defining architectures and present an implementation of the basic level of that model. Our purpose is to support the abstractions used in practice by software designers. The implementation provides a testbed for experiments with a variety of system construction mechanisms. It distinguishes among different types of components and different ways these components can interact. It supports abstract interactions such as data flow and scheduling on the same footing as simple procedure call. It can express and check appropriate compatibility restrictions and configuration constraints. It accepts existing code as components, incurring no runtime overhead after initialization. It allows easy incorporation of specifications and associated analysis tools developed elsewhere. The implementation provides a base for extending the notation and validating the model .},
author = {Shaw, M. and DeLine, R. and Klein, D.V. and Ross, T.L. and Young, D.M. and Zelesnik, G.},
doi = {10.1109/32.385970},
file = {::},
issn = {00985589},
journal = {IEEE Transactions on Software Engineering},
keywords = {architectural abstraction,architecture description language,organization,software architecture,software engineering,software system},
month = {apr},
number = {4},
pages = {314--335},
title = {{Abstractions for software architecture and tools to support them}},
url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=385970},
volume = {21},
year = {1995}
}
@inproceedings{robbins1998-adlintegration,
abstract = {Software architecture descriptions are high-level models of software systems. Some researchers have proposed special- purpose architectural notations that have a great deal of expressive power but are not well integrated with common development methods. Others have used mainstream development methods that are accessible to developers, but lack semantics needed for extensive analysis. We describe an approach to combining the advantages of these two ways of modeling architectures. We present two examples of extending UML, an emerging standard design notation, for use with two architecture description languages, C2 and Wright. Our approach suggests a practical strategy for bringing architectural modeling into wider use, namely by incorporating substantial elements of architectural models into a standard design method.},
address = {Kyoto, Japan},
author = {Robbins, JE and Medvidovic, Nenad},
booktitle = {20th international conference on Software engineering (ICSE1998)},
file = {:Users/eoin/Downloads/00671120.pdf:pdf},
isbn = {0818683686},
keywords = {architecture,constraint languages,description languages,incremental,object-oriented design,software architecture},
pages = {209--218},
publisher = {IEEE Computer Society},
title = {{Integrating architecture description languages with a standard design method}},
url = {http://ieeexplore.ieee.org/xpls/abs{\_}all.jsp?arnumber=671120},
year = {1998}
}
@inproceedings{Gorlick1991,
abstract = {The authors discuss the architectural features of weaves, their implementation, and their use in a variety of applications. Weaves are networks of concurrently executing tool fragments that communicate by passing objects. Weaves are distinguished from other dataflow styles by their emphasis on instrumentation, continuous observability, and dynamic rearrangement: basic low-overhead instrumentation is inserted automatically, executing weaves can be observed at any time by means of sophisticated analysis agents, without degrading the performance of the weave, and weaves can be dynamically snipped and spliced without interrupting the data flow.},
address = {Austin, TX},
author = {Gorlick, M.M. and Razouk, R.R.},
booktitle = {13th International Conference on Software Engineering},
doi = {10.1109/ICSE.1991.130620},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Gorlick, Razouk - 1991 - Using weaves for software construction and analysis.pdf:pdf},
isbn = {0-8186-2140-0},
keywords = {data flow,incremental development,instrumentation,object-,oriented,parallel execution,performance analysis,software,streams,threads},
pages = {23--34},
publisher = {IEEE Comput. Soc. Press},
title = {{Using weaves for software construction and analysis}},
url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=130620},
year = {1991}
}
@inproceedings{Gorlick1994,
abstract = {Visual programming research has largely focused on the issues of visual programming-in-the-small. However, entirely different concerns arise when one is programming-in-the-large. We present a visual software engineering environment that allows users to construct visually programs consisting of hierarchically organized networks of components that process streams of arbitrary objects. We discuss the problems that occur when trying to construct systems consisting of thousands of interconnected components, examine how this environment deals with some of the problems specific to visual programming-in-the-large, and show why our initial solutions failed to scale successfully. Finally, we argue that a single visual mechanism called “zooming” addresses these scaling problems and, when suitably augmented, can also support automatic component discovery and intelligent error correction},
author = {Gorlick, Michael and Quilici, Alex},
booktitle = {1994 IEEE Symposium on Visual Languages},
doi = {10.1109/VL.1994.363631},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Gorlick, Quilici - 1994 - Visual programming-in-the-large versus visual programming-in-the-small.pdf:pdf},
isbn = {0-8186-6660-9},
keywords = {Aerospace electronics,Aerospace testing,Automatic testing,Documentation,Error correction,Information analysis,Instruments,Programming environments,Software engineering,System testing,arbitrary objects,automatic component discovery,hierarchically organized networks,intelligent error correction,interconnected components,scaling problems,visual languages,visual mechanism,visual programming,visual programming research,visual programming-in-the-large,visual programming-in-the-small,visual software engineering environment,zooming},
language = {English},
pages = {137--144},
publisher = {IEEE Comput. Soc. Press},
title = {{Visual programming-in-the-large versus visual programming-in-the-small}},
url = {http://ieeexplore.ieee.org/xpls/abs{\_}all.jsp?arnumber=363631' escapeXml='false'/{\%}3E http://ieeexplore.ieee.org/xpls/abs{\_}all.jsp?arnumber=363631},
year = {1994}
}
@article{allen1997-formalconn,
abstract = {As software systems become more complex, the overall system structure—or software architecture—becomes a central design problem. An important step toward an engineering discipline of software is a formal basis for describing and analyzing these designs. In the article we present a formal approach to one aspect of architectural design: the interactions among components. The key idea is to define architectural connectors as explicit semantic entities. These are specified as a collection of protocols that characterize each of the participant roles in an interaction and how these roles interact. We illustrate how this scheme can be used to define a variety of common architectural connectors. We further provide a formal semantics and show how this leads to a system in which architectural compatibility can be checked in a way analogous to type-checking in programming languages.},
author = {Allen, Robert and Garlan, David},
doi = {10.1145/258077.258078},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Allen, Garlan - 1997 - A formal basis for architectural connection.pdf:pdf},
issn = {1049331X},
journal = {ACM Transactions on Software Engineering and Methodology},
month = {jul},
number = {3},
pages = {213--249},
title = {{A formal basis for architectural connection}},
url = {http://dl.acm.org/citation.cfm?id=258078 http://portal.acm.org/citation.cfm?doid=258077.258078},
volume = {6},
year = {1997}
}
@article{dashofy2005-xadl,
abstract = {Research over the past decade has revealed that modeling software architecture at the level of components and connectors is useful in a growing variety of contexts. This has led to the development of a plethora of notations for representing software architectures, each focusing on different aspects of the systems being modeled. In general, these notations have been developed without regard to reuse or extension. This makes the effort in adapting an existing notation to a new purpose commensurate with developing a new notation from scratch. To address this problem, we have developed an approach that allows for the rapid construction of new architecture description languages (ADLs). Our approach is unique because it encapsulates ADL features in modules that are composed to form ADLs. We achieve this by leveraging the extension mechanisms provided by XML and XML schemas. We have defined a set of generic, reusable ADL modules called xADL 2.0, useful as an ADL by itself, but also extensible to support new applications and domains. To support this extensibility, we have developed a set of reflective syntax-based tools that adapt to language changes automatically, as well as several semantically-aware tools that provide support for advanced features of xADL 2.0. We demonstrate the effectiveness, scalability, and flexibility of our approach through a diverse set of experiences. First, our approach has been applied in industrial contexts, modeling software architectures for aircraft software and spacecraft systems. Second, we show how xADL 2.0 can be extended to support the modeling features found in two different representations for modeling product-line architectures. Finally, we show how our infrastructure has been used to support its own development. The technical contribution of our infrastructure is augmented by several research contributions: the first decomposition of an architecture description language into modules, insights about how to develop new language modules and a process for integrating them, and insights about the roles of different kinds of tools in a modular ADL-based infrastructure.},
author = {Dashofy, Eric M and van der Hoek, Andr{\'{e}} and Taylor, Richard N},
doi = {10.1145/1061254.1061258},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Dashofy, Hoek, Taylor - 2005 - A comprehensive approach for the development of modular software architecture description languages.pdf:pdf},
issn = {1049331X},
journal = {ACM Transactions on Software Engineering and Methodology},
month = {apr},
number = {2},
pages = {199--245},
title = {{A comprehensive approach for the development of modular software architecture description languages}},
url = {http://portal.acm.org/citation.cfm?doid=1061254.1061258},
volume = {14},
year = {2005}
}
@phdthesis{allen1997-wright,
abstract = {As software systems become more complex, the overall system structure—or software architecture—becomes a central design problem. A system's architecture provides a model of the system that suppresses implementation detail, allowing the architect to concentrate on the analyses and decisions that are most crucial to structuring the system to satisfy its requirements. Unfortunately, current representations of software architecture are informal and ad hoc. While architectural concepts are often embodied in infrastructure to support specific architectural styles and in the initial conceptualization of a system configuration, the lack of an explicit, independently-characterized architecture or architectural style significantly limits the benefits of software architectural design in current practice. In this dissertation, I show that an Architecture Description Language based on a formal, abstract model of system behavior can provide a practical means of describing and analyzing software architectures and architectural styles. This dissertation demonstrates this claim through WRIGHT, an architectural description language based on the formal description of the abstract behavior of architectural com- ponents and connectors. WRIGHT provides a practical formal basis for the description of both architectural configurations and of architectural styles. It is distinguished by the use of explicit, independent connector types as interaction patterns, the ability to describe the abstract behavior of components using a CSP-like notation, the characterization of styles using predicates over system instances, and a collection of static checks to determine the consistency and completeness of an architectural specification. We introduce techniques to support the analysis of large-scale systems, and demonstrate WRIGHT's expressiveness and practicality through three case studies.},
author = {Allen, Robert J.},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Allen - 1997 - A Formal Approach to Software Architecture.pdf:pdf},
number = {May},
pages = {248},
school = {Carnegie Mellon University},
title = {{A Formal Approach to Software Architecture}},
year = {1997}
}
@inproceedings{dashofy2001-xadl,
abstract = {Software architecture research focuses on models of software architectures as specified in architecture description languages (ADLs). As research progresses in specific areas of software architectures, more and more architectural information is created. Ideally, this information can be stored in the model. An extensible modeling language is crucial to experimenting with and building tools for novel modeling constructs that arise from evolving research. Traditional ADLs typically support a small set of modeling constructs very well, but adapt to others poorly. XML provides an ideal platform upon which to develop an extensible modeling language for software architectures. Previous XML-based ADLs successfully leveraged XML's large base of off-the-shelf tool support, but did not take advantage of its extensibility. To give software architecture researchers more freedom to explore new possibilities and modeling techniques, while maximizing reuse of tools and modeling constructs, we have developed xADL 2.0, a highly extensible XML-based ADL. xADL 2.0 supports run-time and design time modeling, architecture configuration management and model-based system instantiation. Additionally, xADL 2.0 has a set of extensible infrastructure tools that support the creation, manipulation, and sharing of xADL 2.0 documents},
author = {Dashofy, E.M. and van der Hoek, A. and Taylor, R.N.},
booktitle = {2001 Working IEEE/IFIP Conference on Software Architecture (WICSA 2001)},
doi = {10.1109/WICSA.2001.948416},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Dashofy, van der Hoek, Taylor - 2001 - A highly-extensible, XML-based architecture description language.pdf:pdf},
isbn = {0-7695-1360-3},
pages = {103--112},
publisher = {IEEE Comput. Soc},
title = {{A highly-extensible, XML-based architecture description language}},
url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=948416},
year = {2001}
}
@inproceedings{dashofy2002-xadlinfa,
abstract = {Research and experimentation in software architectures over the past decade have yielded a plethora of software architecture description languages (ADLs). Continuing innovation indicates that it is reasonable to expect more new ADLs, or at least ADL features. This research process is impeded by the difficulty and cost associated with developing new notations. An architect in need of a unique set of modeling features must either develop a new architecture description language from scratch or undertake the daunting task of modifying an existing language. In either case, it is unavoidable that a significant effort will be expended in building or adapting tools to support the language. To remedy this situation, we have developed an infrastructure for the rapid development of new architecture description languages. Key aspects of the infrastructure are its XML-based modular extension mechanism, its base set of reusable and customizable architectural modeling constructs, and its equally important set of flexible support tools. This paper introduces the infrastructure and demonstrates its value in the context of several real-world applications.},
author = {Dashofy, Eric M and Taylor, Richard N},
booktitle = {24th International Conference on Software Engineering (ICSE2002)},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Dashofy, Taylor - 2002 - An Infrastructure for the Rapid Development of XML-based Architecture Description Languages.pdf:pdf},
pages = {266--276},
publisher = {ACM Press},
title = {{An Infrastructure for the Rapid Development of XML-based Architecture Description Languages}},
url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.13.914},
year = {2002}
}
@article{zhu2003-xyzadl,
abstract = {The architecture description language (ADL) is the foundation of software development based on software architecture. An ADL supporting stepwise refinement can make it more convenient that a good design leads to a good implementation. The architecture description language XYZ/ADL can support the stepwise transition from higher-level architectures to lower-level architectures, because it is based on the temporal logic language (TLL) XYZ/E, which can represent both dynamic semantics and static semantics under a unified logical framework. In this paper, the framework and syntax of XYZ/ADL is presented and its underlying semantics is explained using XYZ/E, and how to describe software architecture and software architecture style using XYZ/ADL is introduced.},
author = {Zhu, Xue-Yang and Tang, Zhi-Song},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Zhu, Tang - 2003 - A temporal logic- based software architecture description language XYZADL.pdf:pdf},
journal = {Journal of Software},
keywords = {architecture description language,chinese-language,software architecture,specification,temporal logic language XYZ/E},
mendeley-tags = {chinese-language},
number = {4},
pages = {713--720},
title = {{A temporal logic- based software architecture description language XYZ/ADL}},
volume = {14},
year = {2003}
}
@techreport{Zhu,
abstract = {The architecture description language (ADL) is the foundation of software development based on software architecture. It is desirable that an ADL can represent both high-level abstract specification and the concrete implementation, thereby provides premise for the smooth transition from specification to implementation. In this aspect, the ADL XYZ/ADL has its built-in advantage, because it is based on the temporal logic language XYZ/E, which can represent both dynamic semantics and static semantics of systems with a unified logical framework. In this paper, the concept framework and syntax of XYZ/ADL is presented and its underlying semantic is explained using XYZ/E, and how to describe software architecture using XYZ/ADL is illustrated.},
author = {Zhu, Xue-Yang and Tang, Zhi-Song},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Zhu, Tang - Unknown - Formalising Software Architecture Description with Temporal Logic.pdf:pdf},
keywords = {Software architecture,XYZ/E,architecture description language,specification,temporal logic},
number = {2},
title = {{Formalising Software Architecture Description with Temporal Logic}}
}
@inproceedings{zhang2009-xyzadl,
abstract = {Web services are emerged as a popular application for implementing large-scale distributed, reactive systems. Web service composition is the hotspot research in the field of Web services. Because the validity is a key requirement in the description of Web service composition, a formal language XYZ/ADL is introduced which describe the composition from the view of architecture. In this paper, we define a mapping from XYZ/ADL to a more practical approach of Web service composition BPEL4WS which is difficult to verify the validity of the composition. First, define the conversion of XYZ/E to BPEL4WS, analyze the similarity between the design elements in XYZ/ADL and activities in BPEL4WS, and then do the conversion of XYZ/ADL to BPEL4WS.},
address = {Xiamen},
author = {Zhang, Guang-quan and Rong, Mei and Wei, Hui},
booktitle = {2009 WRI World Congress on Software Engineering (WCSE09)},
doi = {10.1109/WCSE.2009.389},
file = {:Users/eoin/Dropbox/Work/PhDWork/ADL-LitReview/ADL-Papers/ZYZADL-Zhang-WS-Composition.pdf:pdf},
isbn = {978-0-7695-3570-8},
keywords = {web service composition,web services},
number = {60873047},
pages = {185--188},
publisher = {IEEE},
title = {{Description and Analysis for Web Service Composition Based on XYZ/ADL}},
url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=5319391},
year = {2009}
}
@inproceedings{zhang2011-mismatchdetection,
abstract = {The behaviour mismatch analysis is absolutely necessary for guaranteeing the correct composition of web services. In order to improve the reliability of the Web service composition, we present a mismatch detection method which can capture incompatible behavior and timed conflict among multiple asynchronous services. In this paper, we use software architecture description language XYZ/ADL based on temporal logic to describe Web service composition and use XYZ/RE to express the relative timed constraints. Additionally, we also set up a timed asynchronous service model TASM which can depict asynchronous interacting behavior and timed properties. In particular, the model satisfies the specification of model check UPPAAL. We convert XYZ/ADL description to TASM, and give the definition of compatibility. Then we use UPPAAL to realize mismatch detection of asynchronous Web services. Finally an example is demonstrated to illustrate how the approach we proposed works.},
address = {Jeju Island},
author = {Zhang, Guang-quan and Shi, Hui-juan and Rong, Mei},
booktitle = {2011 IEEE Asia-Pacific Services Computing Conference},
doi = {10.1109/APSCC.2011.44},
editor = {Lee, Changhoon and Hsu, Robert C. H. and Zhang, Jia},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Zhang, Shi, Rong - 2011 - Mismatch Detection of Asynchronous Web Services with Timed Constraints.pdf:pdf},
isbn = {978-1-4673-0206-7},
keywords = {asynchronous web services,mismatch detection,timed constraints,uppaal,xyz},
month = {dec},
number = {1},
pages = {251--258},
publisher = {IEEE},
title = {{Mismatch Detection of Asynchronous Web Services with Timed Constraints}},
url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=6127970},
year = {2011}
}
@article{loques2004,
abstract = {This paper presents a comprehensive approach to describe, deploy and adapt component-based applications having dynamic non-functional requirements. The approach is centered on high-level contracts associated to architectural descriptions, which allow the non-functional requirements to be handled separately during the system design process. This helps to achieve separation of concerns facilitating the reuse of modules that implement the application in other systems. Besides specifying non-functional requirements, contracts are used at runtime to guide configuration adaptations required to enforce these requirements. The infrastructure required to manage the contracts follows an architectural pattern, which can be directly mapped to specific components included in a support- ing reflective middleware. This allows designers to write a contract and to follow standard recipes to insert the extra code required to its enforcement in the supporting middleware.},
author = {Loques, Orlando and Sztajnberg, Alexandre and Curty, Romulo and Ansaloni, Sidney},
doi = {10.1007/BF03192350},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Loques et al. - 2004 - A contract-based approach to describe and deploy non-functional adaptations in software architectures.pdf:pdf},
issn = {0104-6500},
journal = {Journal of the Brazilian Computer Society},
keywords = {contracts,dynamic configuration adaptation,middleware,non-functional requirements,separation of concerns,software architectures},
month = {feb},
number = {1},
pages = {5--20},
title = {{A contract-based approach to describe and deploy non-functional adaptations in software architectures}},
url = {http://www.springerlink.com/index/10.1007/BF03192350},
volume = {10},
year = {2004}
}
@inproceedings{desilva2011-rationale,
abstract = {Besides structural and behavioural properties, rationale plays a crucial role in defining the architecture of a software system. However, unlike other architectural features, rationale often remains unspecified and inaccessible to tools. Existing approaches for recording rationale are not widely adopted. This paper proposes a simple model for capturing rationales as part of an architecture specification and attaching them to elements in the architecture. The bi-directional links between rationales and elements enable forward and backward traceability. We describe a textual architecture description language named Grasp that implements this model, and illustrate its capabilities using an example.},
annote = {10.1007/978-3-642-23798-0{\_}34},
author = {de Silva, Lakshitha and Balasubramaniam, Dharini},
booktitle = {5th European Conferene on Software Architecture (ECSA 2011), LNCS 6903},
doi = {10.1007/978-3-642-23798-0_34},
editor = {Crnkovic, Ivica and Gruhn, Volker and Book, Matthias},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/de Silva, Balasubramaniam - 2011 - A Model for Specifying Rationale Using an Architecture Description Language.pdf:pdf},
isbn = {978-3-642-23797-3},
pages = {319--327},
publisher = {Springer Berlin / Heidelberg},
series = {Lecture Notes in Computer Science},
title = {{A Model for Specifying Rationale Using an Architecture Description Language}},
url = {http://dx.doi.org/10.1007/978-3-642-23798-0{\_}34},
volume = {6903},
year = {2011}
}
@phdthesis{desilva2009-oslo,
abstract = {The architecture of a software system is crucial for studying the behaviour of the system and analysing the impact of changes made to the software. Besides descriptions of the structural organization of the system, an architecture also includes rationale for the various design choices made while constructing the system. Architecture rationale helps understand the intent of its designers which is imperative for maintaining the system. However, unlike the structural aspects of a software system, architecture rationale is often undocumented or inaccessible to tools. A number of formal approaches have been proposed to capture rationale though none have been widely adopted due their complexity. This work presents an approach to capture architecture rationale as part of the architecture modelling process. A conceptual framework was developed to associate design rationale to structural elements of an architecture. The framework models a bi- directional association between design rationale and architecture elements that provides forward and backward traceability. Consequently, an architecture description language (ADL) based on the conceptual framework was designed using the M-Grammar notation available as part of the Microsoft ―Oslo‖ Platform. A compiler that validates and executes architectures specified using the new ADL was developed along with a visualizer tool to renders an architecture using graphical notations. Finally, we evaluated the effectiveness of the conceptual model and the ADL for capturing architecture rationale. The expressiveness of the M-Grammar notation was also evaluated as part of this work.},
author = {Silva, Lakshitha De},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Silva - 2009 - A Rationale-based Architecture Description Language using the “ Oslo ” Modelling Platform.pdf:pdf},
number = {August},
pages = {62},
school = {University of St Andrews},
title = {{A Rationale-based Architecture Description Language using the “ Oslo ” Modelling Platform}},
year = {2009}
}
@phdthesis{klein2000-model,
abstract = {This dissertation is devoted to the topic of architecture modeling for software systems. The architecture describes the structural composition of a system from components and relation- ships between these components. Thereby, it provides a basis for the system's realization on technical as well as on organizational level.},
author = {Klein, Peter},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Klein - 2000 - Architecture Modeling of Distributed and Concurrent Software Systems.pdf:pdf},
school = {heinisch-Westfälischen Technischen Hochschule Aachen},
title = {{Architecture Modeling of Distributed and Concurrent Software Systems}},
type = {PhD},
url = {http://pi.informatik.uni-siegen.de/gi/stt/23{\_}3/05{\_}Dissertationen/klein.pdf},
volume = {82},
year = {2000}
}
@misc{coyette-skwrladl,
author = {Coyette, Adrien and Do, Tung and Faulkner, St{\'{e}}phane and Kolp, Manuel},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Coyette et al. - Unknown - SKwyRL Social Architectures for Agent Software Engineering.pdf:pdf},
keywords = {presentation-slides},
title = {{SKwyRL : Social Architectures for Agent Software Engineering}}
}
@article{mouratidis2010-skwyrladl,
abstract = {Multi-Agent Systems (MAS) architectures are gaining popularity for building open, distributed, and evolving information systems. Unfortunately, despite considerable work in the fields of software architecture and MAS during the last decade, few research efforts have aimed at defining languages for designing and formalising secure agent architectures. This paper proposes a novel Architectural Description Language (ADL) for describing Belief-Desire-Intention (BDI) secure MAS. We specify each element of our ADL using the Z specification language and we employ two example case studies: one to assist us in the description of the proposed language and help readers of the article to better understand the fundamentals of the language; and one to demonstrate its applicability.},
author = {Mouratidis, Haralambos and Kolp, Manuel and Giorgini, Paolo and Faulkner, Stephane},
doi = {10.3233/WIA-2010-0182},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Unknown - 2010 - An Architectural Description Language for Secure Multi-Agent Systems.pdf:pdf},
issn = {1570-1263},
journal = {Web Intelligence and Agent Systems},
keywords = {BDI agent model,Multi-Agent Systems,architectural description language,security,software architecture},
month = {jan},
number = {1},
pages = {99--122},
title = {{An architectural description language for secure Multi-Agent Systems}},
url = {http://dl.acm.org/citation.cfm?id=1734707.1734713},
volume = {8},
year = {2010}
}
@phdthesis{Coyette2003,
author = {Coyette, Adrien},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Coyette - 2003 - The SkwyRL-Agent Architectural Framework Developing An E-Business Application.pdf:pdf},
pages = {143},
school = {UNIVERSITE CATHOLIQUE DE LOUVAIN},
title = {{The SkwyRL-Agent Architectural Framework : Developing An E-Business Application}},
type = {BSc (Licenci{\'{e}} en Sciences des Gestion)},
url = {www.isys.ucl.ac.be/skwyrl/emedia/Files/report.pdf},
year = {2003}
}
@inproceedings{allen1996-aegis,
abstract = {Software architecture is receiving increasingly attention as a critical design level for software systems. However, the current practice of architectural description is largely informal and ad hoc, with the consequence that architectural documents serve as a poor communication mechanism, are difficult to analyze, and may have very little relationship to the implemented system. In an attempt to address these problems several researchers have experimented with formalisms for architectural specification and modelling. One such formalism is WRIGHT. In this paper we show how WRIGHT can be used to provide insight into an architectural design by modelling a prototype implementation of part of the AEGIS Weapons System.},
author = {Allen, Robert and Garlan, D},
booktitle = {8th International Workshop on Software Specification and Design (IWSSD 96)},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Allen, Garlan - 1996 - A Case Study in Architectural Modelling The AEGIS System.pdf:pdf},
number = {March},
pages = {6--15},
title = {{A Case Study in Architectural Modelling : The AEGIS System}},
url = {http://dl.acm.org/citation.cfm?id=858260},
year = {1996}
}
@inproceedings{boucke2007-xadl,
abstract = {Experience with building an architecture for an industrial Automatic Guided Vehicle Transportation System (AGVTS) shows that several essential concerns crosscut the architectural views. To cope with this, a stronger separation proved to be necessary, i.e. using different views for different concerns. In practice this was difficult, since the support for relations between views is very limited. This makes separation of concerns in views hard, thereby increasing maintenance overhead and reducing reuse capabilities. Our claim is that specifying compositions of views is as important as specifying the views itself. This paper extends a representative architectural description language (xADL) which support for composing structural views, by introducing three relations, namely refinement, mapping, and unification. Improving separation of concerns in views and their explicit composition enhances architecture understandability and changeability. The feasibility of the relations is assessed by redesigning the AGVTS architecture. Based on a real maintenance scenario, we investigate to what extent these explicit compositions lead (or not) to enhanced architectural changeability for evolving the distribution strategy in the AGVTS system.},
address = {Vancouver, Canada},
author = {Bouck{\'{e}}, N and Garcia, A and Holvoet, T},
booktitle = {10th international conference on Early aspects: current challenges and future directions, LNCS 4765},
editor = {Moreira, Ana and Grundy, John},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Bouck{\'{e}}, Garcia, Holvoet - 2007 - Composing Structural Views in xADL.pdf:pdf},
pages = {115--138},
publisher = {Springer-Verlag},
title = {{Composing Structural Views in xADL}},
url = {http://www.springerlink.com/index/R2Q6575336Q12K81.pdf},
year = {2007}
}
@inproceedings{Woods2010,
abstract = {This paper proposes a research challenge to narrow the gap between the architecture and implementation of a software system. We discuss the situation today, where little of a system's architecture and design is directly represented in the source code of its implementation and explore why this is a problem and the benefits that might flow from narrowing this gap. We then discuss how the situation could be improved by the creation of technologies that allow the design and architecture of a system to be directly related to its source code and outline the requirements that we believe that any such technology would need to fulfill. Finally, we consider the likely results of widespread application of such a technology and the benefits that would follow.},
address = {Copenhagen},
author = {Woods, Eoin and Rozanski, Nick},
booktitle = {Fourth European Conference on Software Architecture Companion Volume - ECSA '10},
doi = {10.1145/1842752.1842767},
editor = {Babar, M. Ali and Gorton, Ian},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Woods, Rozanski - 2010 - Unifying software architecture with its implementation.pdf:pdf},
isbn = {9781450301794},
pages = {55--58},
publisher = {ACM Press},
title = {{Unifying software architecture with its implementation}},
url = {http://portal.acm.org/citation.cfm?doid=1842752.1842767},
year = {2010}
}
@unpublished{woods2005-adlandarchs,
author = {Woods, Eoin},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Woods - 2005 - Architecture Description Languages and Information Systems Architects Never the Twain Shall Meet.pdf:pdf},
institution = {IFIP Working Group 2.10 on Software Architecture},
title = {{Architecture Description Languages and Information Systems Architects : Never the Twain Shall Meet ?}},
url = {http://www.artechra.com/media/writing/IFIPWG2005-adls-position-paper.pdf http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.129.8807},
year = {2005}
}
@inproceedings{woods2005-adlwg,
abstract = {This short document reports the content and results of the "Architecture Description Languages in Practice" working group held on 9th and 10th November 2005 at the WICSA 5 conference, in Pittsburgh, Pennsylvania, USA.},
address = {Pittsburgh, PA, USA},
author = {Woods, Eoin and Hilliard, Rich},
booktitle = {5th Working IEEE/IFIP Conference on Software Architecture (WICSA'05)},
doi = {10.1109/WICSA.2005.15},
editor = {Nord, Robert and Medvidovic, Nenad and Krikhaar, Ren{\'{e}} and Stafford, Judith and Bosch, Jan},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Woods, Hilliard - 2005 - Architecture Description Languages in Practice Session Report.pdf:pdf},
isbn = {0-7695-2548-2},
pages = {243--246},
publisher = {IEEE},
title = {{Architecture Description Languages in Practice Session Report}},
url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=1620128},
year = {2005}
}
@incollection{Woods2011,
abstract = {Historically a system's requirements and its architectural design have been viewed as having a simple relationship where the requirements drove the architecture and the architecture was designed in order to meet the requirements. In contrast, our experience is that a much more dynamic relationship can be achieved between these key activities within the system design lifecycle, that allows the architecture to constrain the requirements to an achievable set of possibilities, frame the requirements making their implications clearer, and inspire new requirements from the capabilities of the system's architecture. In this article, we describe this relationship, illustrate it with a case study drawn from our experience and present some lessons learned that we believe will be valuable for other software architects.},
address = {Berlin, Heidelberg},
author = {Woods, Eoin and Rozanski, Nick},
booktitle = {Relating Software Requirements and Architectures},
doi = {10.1007/978-3-642-21001-3},
editor = {Avgeriou, Paris and Grundy, John and Hall, Jon G. and Lago, Patricia and Mistr{\'{i}}k, Ivan},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Woods, Rozanski - 2011 - How Software Architecture can Frame, Constrain and Inspire System Requirements.pdf:pdf},
isbn = {978-3-642-21000-6},
pages = {333--352},
publisher = {Springer Berlin Heidelberg},
title = {{How Software Architecture can Frame, Constrain and Inspire System Requirements}},
url = {http://www.springerlink.com/index/10.1007/978-3-642-21001-3},
year = {2011}
}
@inproceedings{Longshaw2004,
abstract = {As systems become more complex it is increasingly difficult to anticipate and handle error conditions in a system. The developers of the system must ensure that errors do not cause problems for the users of the system. To do so, they should Keep Exceptions Exceptional, Hide Technical Details from Users and encapsulate the system in a Big Outer Try Block. The administrators must be informed when an error occurs and must be given sufficient information about what happened, where it happened and why it happened. If a system has Split Domain and Technical Errors and its components only Log Unexpected Errors then the level of error information can stay manageable. If distributed systems Log at Distribution Boundaries then the overall error information in the system can be reduced and the consequences of individual errors can be tied together using a Unique Error Identifier},
address = {Irsee, Germany},
author = {Longshaw, Andy and Woods, Eoin},
booktitle = {9th European Conference on Pattern Languages of Programms (EuroPLoP 2004)},
editor = {Marquardt, Klaus and Sch{\"{u}}tz, Dietmar},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Longshaw, Woods - 2004 - Patterns for Generation, Handling and Management of Errors.pdf:pdf},
pages = {27--52},
publisher = {UVK - Universitaetsverlag Konstanz},
title = {{Patterns for Generation, Handling and Management of Errors}},
url = {http://www.blueskyline.com/ErrorPatterns/ErrorPatternsPaper.pdf},
year = {2004}
}
@article{Woods2012,
abstract = {Scenario based architectural assessment is a well-established approach for assessing architectural designs. However scenario-based methods are not always usable in an industrial context, where in our experience, they can be perceived as complicated and expensive to use. In this paper we explore why this may be the case and define a simpler technique called TARA, which has been designed for use in situations where scenario based methods are unlikely to be successful. The method is illustrated through an experience report that explains how it was applied to the assessment of two quantitative financial analysis systems, and its strengths, weaknesses and relationship to other methods are briefly discussed.},
author = {Woods, Eoin},
doi = {10.1016/j.jss.2012.04.055},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Woods - 2012 - Industrial architectural assessment using TARA.pdf:pdf},
issn = {01641212},
journal = {Journal of Systems and Software},
keywords = {assessment methods,case study,software architecture},
month = {sep},
number = {9},
pages = {2034--2047},
title = {{Industrial architectural assessment using TARA}},
url = {http://linkinghub.elsevier.com/retrieve/pii/S0164121212001264},
volume = {85},
year = {2012}
}
@inproceedings{woods2005-perspectives,
abstract = {A crucial aspect of the software architect's role is to ensure that a system based on their architecture will exhibit the quality properties (performance, security, availability and so on) that are important to their stakeholders. A proven approach to help guide an architect through the process of designing an architecture is to use architectural views, based on formal viewpoint definitions (such as those in the well known "4+1" set). However, a practical problem we have found when using existing viewpoint sets is the lack of guidance relating to system qualities (as opposed to system structures) that they provide. To address this problem, we identified a complimentary concept, called the architectural perspective [15], to provide an architect with practical guidance as to how to ensure that their system exhibits the right set of quality properties. This paper reviews the idea of the architectural perspective and relates a specific experience of applying them to the architectural definition of an enterprise integration project for a financial markets organisation, explaining the strengths and weaknesses we found in the approach.},
address = {Pittsburgh, PA, USA},
author = {Woods, E. and Rozanski, N.},
booktitle = {5th Working IEEE/IFIP Conference on Software Architecture (WICSA'05)},
doi = {10.1109/WICSA.2005.74},
editor = {Nord, Robert and Medvidovic, Nenad and Krikhaar, Ren{\'{e}} and Stafford, Judith and Bosch, Jan},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Woods, Rozanski - 2005 - Using Architectural Perspectives.pdf:pdf},
isbn = {0-7695-2548-2},
pages = {25--35},
publisher = {IEEE},
title = {{Using Architectural Perspectives}},
url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=1620088},
year = {2005}
}
@inproceedings{Woods2009,
abstract = {A common requirement when describing the architecture of a software system is the ability to define the environment of a system, in terms of its external dependencies. In a view-based architectural description approach (such as “4+1” or “Rozanski and Woods”) this need is met by adding a Context view containing this information to the architectural description and ideally defining a corresponding Context viewpoint to guide and standardise such views. This short paper explains the benefits of adding a Context view to architectural descriptions and provides an outline definition of the corresponding viewpoint to explain their content and how they are developed.},
address = {Cambridge},
author = {Woods, Eoin and Rozanski, Nick},
booktitle = {2009 Joint Working IEEE/IFIP Conference on Software Architecture {\&} European Conference on Software Architecture (WICSA2009)},
doi = {10.1109/WICSA.2009.5290673},
editor = {Oquendo, Flavio and Poort, Eltjo and Stafford, Judith},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Woods, Rozanski - 2009 - The system context architectural viewpoint.pdf:pdf},
isbn = {978-1-4244-4984-2},
month = {sep},
pages = {333--336},
publisher = {IEEE},
title = {{The system context architectural viewpoint}},
url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=5290673},
year = {2009}
}
@inproceedings{Longshaw2005,
abstract = {As systems become more complex it is increasingly difficult to anticipate and handle error conditions in a system. The developers of the system must ensure that errors do not cause problems for the users of the system. In a previous paper [Longshaw 2004] a collection of patterns for such distributed error handling was explored. As this collection was refined, two new patterns emerged: Hide Technical Details from Users and Unique Error Identifier. This paper retains the same context and but is focused on obtaining feedback specifically on these new additions.},
address = {Irsee, Germany},
author = {Longshaw, Andy and Woods, Eoin},
booktitle = {Tenth European Conference on Pattern Languages of Programs (EuroPLoP 2005)},
editor = {Longshaw, Andy and Zdun, Uwe},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Longshaw, Woods - 2005 - More Patterns for the Generation , Handling and Management of Errors.pdf:pdf},
pages = {517--530},
publisher = {UVK - Universitaetsverlag Konstanz},
title = {{More Patterns for the Generation , Handling and Management of Errors}},
year = {2005}
}
@article{Woods2010a,
abstract = {UML, used to capture class and component structures, data models, and other aspects of software behavior, is assessed for its use in describing software architecture. UML does not allow architects to describe the constructs that they commonly use to design software-intensive systems and does not express various concerns that architects must take into account. UML needs to have first-class support for describing servers, clients, runtime containers, message buses, and services. Other important features missing from UML include concurrency primitives and error handling, which is one of the most important considerations for many software systems is the ability to detect and recover from errors. UML establishes a resource budget for a component or subsystem, a common technique for performance management.},
author = {Woods, E. and Emery, D.},
doi = {10.1109/MS.2010.145},
issn = {07407459},
journal = {IEEE Software},
keywords = {UML,Unified Modeling Language,software development,stakeholders},
number = {6},
pages = {54+56},
title = {{Is UML sufficient for describing architectures?}},
volume = {27},
year = {2010}
}
@article{Woods2014,
abstract = {{\textcopyright} 1984-2012 IEEE. This column discusses architectural descriptions and the process of representing and communicating designs and how UML is useful when creating architectural descriptions.},
author = {Woods, E.},
doi = {10.1109/MS.2014.139},
issn = {07407459},
journal = {IEEE Software},
keywords = {UML,architecture,modeling,software engineering},
number = {6},
pages = {30--33},
title = {{Harnessing UML for architectural description-The context view}},
volume = {31},
year = {2014}
}
@inproceedings{Baroni2014,
abstract = {A previous study, run by some of the authors in collaboration with practitioners, has emphasized the need to improve architectural languages in order to (i) make them simple and intuitive enough to communicate effectively with project stakeholders, and (ii) enable formality and rigour to allow analysis and other automated tasks. Although a multitude of languages have been created by researchers and practitioners, they rarely address both of these needs. In order to reconcile these divergent needs, this paper presents an approach that (i) combines the rigorous foundations of model-driven engineering with the usability of semantic wikis, and (ii) enables continuous syncronization between them, this allows software architects to simultaneously use wiki pages for communication and models for model-based analysis and manipulation. In this paper we explain how we applied the approach to an industry-inspired case study using the Semantic Media Wiki wiki engine and a model-driven architecture description implemented within the Eclipse Modeling Framework. We also discuss how our approach can be generalized to other wiki-based and model-driven technologies. {\textcopyright} 2014 IEEE.},
author = {Baroni, A. and Muccini, H. and Malavolta, I. and Woods, E.},
booktitle = {Proceedings - Working IEEE/IFIP Conference on Software Architecture 2014, WICSA 2014},
doi = {10.1109/WICSA.2014.21},
isbn = {9781479934126},
keywords = {Architecture Description,Model-Driven Engineering,Wikis},
pages = {251--254},
title = {{Architecture description leveraging model driven engineering and semantic wikis}},
year = {2014}
}
@article{Woods1995,
abstract = {Although widely used, UML has some serious limitations as an architecture description language. {\textcopyright} 1995 IEEE},
author = {Woods, E. and Emery, D.},
doi = {10.1109/12.392855},
issn = {00189340},
journal = {IEEE Transactions on Computers},
number = {7},
pages = {947--951},
title = {{Is UML Sufficient for Describing Architectures?}},
volume = {44},
year = {1995}
}
@book{Woods2004,
abstract = {There has recently been an increase in interest, among information systems architecture practitioners, in using viewpoints for architectural definition and description. This has been caused by a number of factors including the publication of IEEE standard 1471 and the increasing adoption of RUP (and its "4+1" viewpoint set). This short experience report outlines the experiences that two software architects have had in evaluating and applying a number of viewpoint sets to information systems development. The strengths and weaknesses found with each viewpoint set are described and some general observations on viewpoint set use and definition are presented. {\textcopyright} Springer-Verlag 2004.},
author = {Woods, E.},
booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
issn = {03029743 16113349},
pages = {182--193},
title = {{Experiences using viewpoints for information systems architecture: An industrial experience report}},
volume = {3047},
year = {2004}
}
@inproceedings{Woods2012b,
abstract = {An organisation that had developed a large Information System wanted to embark on a programme of significant evolution for the system. As a precursor to this, it was decided to create a comprehensive architectural description. This undertaking faced a number of challenges, including a low general awareness of software modelling and software architecture practices. The approach taken for this project included the definition of a simple, specific, architecture description language. This paper describes the experiences of the project and the ADL created as part of it. {\textcopyright} 2012 IEEE.},
author = {Woods, E. and Bashroush, R.},
booktitle = {Proceedings of the 2012 Joint Working Conference on Software Architecture and 6th European Conference on Software Architecture, WICSA/ECSA 2012},
doi = {10.1109/WICSA-ECSA.212.37},
isbn = {9780769548272},
keywords = {ADL,Description Language,Industrial Experience Report,Software Architecture Discovery,Software Architecture for Legacy Systems},
pages = {239--243},
title = {{Using an architecture description language to model a large-scale information system - An industrial experience report}},
year = {2012}
}
@article{Woods2014a,
abstract = {Many types of architects work in the software industry, but when we consider the breadth of their work and their primary expertise, we find that they can be organized into three major groups: enterprise architects, application architects, and infrastructure architects. Knowing which group an architect falls into helps in understanding their expertise and what to expect of them. {\textcopyright} 2014 IEEE.},
author = {Woods, E.},
doi = {10.1109/MS.2014.69},
issn = {07407459},
journal = {IEEE Software},
keywords = {application,architecture,enterprise,infrastructure,pragmatic architect,software},
number = {3},
pages = {10--13},
title = {{Return of the pragmatic architect}},
volume = {31},
year = {2014}
}
@article{Woods2015,
abstract = {{\textcopyright} 1984-2012 IEEE. Difficulties frequently arise when agile development teams and software architects work together. By adopting practices aligned with the 'agile manifesto,' software architects can work constructively with agile teams and significantly contribute to a project's success.},
author = {Woods, E.},
doi = {10.1109/MS.2015.119},
issn = {07407459},
journal = {IEEE Software},
keywords = {agile teams,software architecture,software design,software development,software engineering},
number = {5},
pages = {24--26},
title = {{Aligning Architecture Work with Agile Teams}},
volume = {32},
year = {2015}
}
@article{Woods2015b,
abstract = {{\textcopyright} 2014 Elsevier Inc. All rights reserved. An organisation that had developed a large information system wanted to embark on a programme that would involve large-scale evolution of it. As a precursor to this, it was decided to create a comprehensive architectural description to capture and understand the system's design. This undertaking faced a number of challenges, including a low general awareness of software modelling and software architecture practices. The approach taken by the software architects tasked with this project included the definition of a simple, very specific, architecture description language. This paper reports our experience of the project and a simple ADL that we created as part of it.},
author = {Woods, E. and Bashroush, R.},
doi = {10.1016/j.jss.2014.09.018},
issn = {01641212},
journal = {Journal of Systems and Software},
keywords = {Architecture description language,Industrial experience report,Software architecture discovery},
pages = {97--108},
title = {{Modelling large-scale information systems using ADLs - An industrial experience report}},
volume = {99},
year = {2015}
}
@article{Bicarregui1997,
abstract = {The use of formality in software development enables formal manipulation at the symbolic level and hence can yield new perspectives on the design which can be submitted to inspection and interactive or automatic analysis. We describe the experience of an industrial pilot project which undertook a formal development using VDM and B and employed a number of techniques for the analysis of the formal texts by animation, test case generation and proof. We assess the effectiveness of methodology and techniques adopted by measuring the introduction and detection of faults. {\textcopyright} 1997 Elsevier Science B.V.},
author = {Bicarregui, J. and Dick, J. and Matthews, B. and Woods, E.},
issn = {01676423},
journal = {Science of Computer Programming},
keywords = {Animation,B,Formal methods,Formal specification,Proof,Test case generation,Testing,VDM},
number = {1-2},
pages = {53--78},
title = {{Making the most of formal specification through animation, testing and proof}},
volume = {29},
year = {1997}
}
@inproceedings{Tekinerdogan2011,
abstract = {This paper summarizes the workshop on Architecture-Based Testing and System Validation which was organized in conjunction with the 9th Working IEEE/IFIP Conference on Software Architecture. The main goal of the workshop was to bring together researchers and practitioners both from the architecture design and software testing community to enable architecture-based software testing. {\textcopyright} 2011 IEEE.},
author = {Tekinerdogan, B. and Clements, P. and Muccini, H. and Chaudron, M. and Polini, A. and Woods, E.},
booktitle = {Proceedings - 9th Working IEEE/IFIP Conference on Software Architecture, WICSA 2011},
doi = {10.1109/WICSA.2011.53},
isbn = {9780769543512},
keywords = {Architecture-Based Testing,Software Architecture,Software testing,System Validation},
pages = {341},
title = {{Architecture-based testing and system validation: Workshop summary}},
year = {2011}
}
@book{Woods2012a,
abstract = {The architect takes a high-profile role in many IT departments today. In fact, it can be quite difficult in some organizations to find a senior member of IT technical staff whose job title does not include the word "architect." However there is little consensus in the academic community or amongst practitioners as to the responsibilities of the many different types of architect we encounter - or indeed, what they should even be called. In this chapter, the authors propose a simple, widely applicable taxonomy of architects, namely enterprise architects, application architects, and infrastructure architects. The authors define distinguishing characteristics, their responsibilities, the stakeholders with whom they engage, and the tools and techniques they use. The chapter shows how this taxonomy can be applied to most, if not all, practicing architects in the information systems domain, and explains how it helps us understand how such architects work together to help deliver the organization's business goals. {\textcopyright} 2013, IGI Global.},
author = {Woods, E. and Rozanski, N.},
booktitle = {Aligning Enterprise, System, and Software Architectures},
doi = {10.4018/978-1-4666-2199-2.ch001},
isbn = {9781466621992},
pages = {1--22},
title = {{Relating enterprise, application, and infrastructure architects}},
year = {2012}
}
@book{Bicarregui1996,
abstract = {{\textcopyright} Springer-Verlag Berlin Heidelberg 1996. This paper reports on the experience gained in the MaFMeth project, which undertook a formal development with tool support for several parts of the life cycle from requirements capture through to C code generation. We explore the hypotheses that formal methods enable the early detection of faults in design by examining the development process in the light of the stages at which faults were introduced and discovered.},
author = {Bicarregui, J. and Dick, J. and Woods, E.},
booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
isbn = {9783540609735},
issn = {16113349 03029743},
pages = {60--73},
title = {{Quantitative analysis of an application of formal methods}},
volume = {1051},
year = {1996}
}
@article{Dick1997,
abstract = {This article describes the rigorous application of formal methods of software development to a system software development project within a conventional industrial software development environment. This project applied formal methods to a small part (one subsystem) of the development of a release of a system software product. The formal methods VDM and B were used to specify, design and implement the administration subsystem of a product that was otherwise developed along conventional lines. Support tools were used to assist with the use of both methods throughout the development lifecycle. Metrics for effort and quality were collected from the project and compared with historical metrics for similar projects to allow the impact of formal methods on cost and quality to be assessed. This article briefly outlines the product being developed and the subsystem to which formal methods were applied. The environment in which this development was performed and the particular approach used are described. The results of this industrial application of formal methods and the lessons learned by the project are discussed at some length. {\textcopyright} 1997 Elsevier Science B. V.},
author = {Dick, J. and Woods, E.},
issn = {09505849},
journal = {Information and Software Technology},
keywords = {Formal method,Process improvement,Software development},
number = {8},
pages = {551--560},
title = {{Lessons learned from rigorous system software development}},
volume = {39},
year = {1997}
}
@book{Woods2011a,
author = {Woods, Eoin},
isbn = {978-0321718334},
month = {oct},
title = {{Software Systems Architecture}},
url = {http://www.amazon.co.uk/Software-Systems-Architecture-Stakeholders-Perspectives/dp/032171833X},
year = {2011}
}
@inproceedings{Garlan2008,
author = {Garlan, D and Woods, E and Kruchten, P},
doi = {10.1109/WICSA.2008.4},
title = {{7th IEEE/IFIP Working Conference on Software Architecture, WICSA 2008: Message from the conference chairs}},
url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-49949119146{\&}partnerID=MN8TOARS},
year = {2008}
}
@article{Bashroush2017,
abstract = {{\textcopyright} 2017 IEEE. Optimizing the energy consumption of today's Internet-scale systems will require a radical approach that considers the whole system. To address system-level energy efficiency, software architects can follow three simple design principles. A case study illustrates the possible savings.},
author = {Bashroush, R. and Woods, E.},
doi = {10.1109/MS.2017.60},
issn = {07407459},
journal = {IEEE Software},
keywords = {Internet,cloud,datacenters,eBay,energy,energy efficiency,green computing,software architect,software development,software engineering},
number = {3},
title = {{Architectural Principles for Energy-Aware Internet-Scale Applications}},
volume = {34},
year = {2017}
}
@book{Woods2017,
abstract = {{\textcopyright} 2017, Springer International Publishing AG. As part of our software architecture research and practice we have found that a common difficulty for new architects is knowing where to focus their effort to maximise their effectiveness. This led us to wonder whether successful experienced architects have reusable heuristics or guidelines that they follow to help them prioritise their work. To investigate this we have performed a study using semi-structured interviews to explore how experienced software architects prioritise their activities in order to maximise their effectiveness. From the primary data collected through the interviews we have synthesised a simple model that organises and explains the heuristics that we found to be common across a number of experienced software architects.},
author = {Woods, E. and Bashroush, R.},
booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
doi = {10.1007/978-3-319-65831-5_13},
isbn = {9783319658308},
issn = {16113349},
keywords = {Software architect effectiveness,Software architecture,Software architecture decision making},
title = {{A model for prioritization of software architecture effort}},
volume = {10475 LNCS},
year = {2017}
}
@article{Woods2017a,
abstract = {{\textcopyright} 1984-2012 IEEE. Should the people performing a system's architecture work also develop some of the system's production code? Involving architects in carefully selected implementation tasks, such as testing, refactoring, or architectural spikes, can yield positive returns on investment for both the architects and their teams.},
author = {Woods, E.},
doi = {10.1109/MS.2017.3571574},
issn = {07407459},
journal = {IEEE Software},
keywords = {coding,software,software architecture,software development,software engineering},
number = {5},
title = {{Should Architects Code?}},
volume = {34},
year = {2017}
}
@article{Woods2016,
abstract = {{\textcopyright} 1984-2012 IEEE. Architecture principles epitomize architecture's function: to clearly define the necessary constraints on a system's design without prescriptively defining all the design details. A good set of principles can provide context and justification for design decisions and can foster team collaboration and communication.},
author = {Woods, E.},
doi = {10.1109/MS.2016.88},
issn = {07407459},
journal = {IEEE Software},
keywords = {design,project management,software architecture,software development,software engineering},
number = {4},
title = {{Harnessing the power of architectural design principles}},
volume = {33},
year = {2016}
}
@article{Woods2016b,
abstract = {{\textcopyright} 2016 IEEE. As software systems have evolved, so has software architecture, with practices growing to meet each era's new challenges. The next phase of evolution - intelligent connected systems - promises to be an exciting time for software architects.},
author = {Woods, E.},
doi = {10.1109/MS.2016.149},
issn = {07407459},
journal = {IEEE Software},
keywords = {Internet of Things,artificial intelligence,cloud,history of computing,software architect,software development,software engineering},
number = {6},
title = {{Software Architecture in a Changing World}},
volume = {33},
year = {2016}
}
@article{Woods2015a,
abstract = {{\textcopyright} 1984-2012 IEEE. The metaphor 'architecting in the gaps' can help software development teams clearly understand the software architect's role and how architecture contributes to a system's overall efficiency.},
author = {Woods, E.},
doi = {10.1109/MS.2015.98},
issn = {07407459},
journal = {IEEE Software},
keywords = {software architecture,software design,software development,software engineering},
number = {4},
title = {{Architecting in the Gaps: A Metaphor for Architecture Work}},
volume = {32},
year = {2015}
}
@article{Woods2016a,
abstract = {{\textcopyright} 2016 IEEE. The emerging DevOps movement emphasizes development and operations staff working together as early as possible-sharing tools, processes, and practices that smooth the production path. This article is part of a theme issue on DevOps.},
author = {Woods, E.},
doi = {10.1109/MS.2016.86},
issn = {07407459},
journal = {IEEE Software},
keywords = {DevOps,operational viewpoint,production,project management,software architecture,software development,software engineering},
number = {3},
title = {{Operational: The Forgotten Architectural View}},
volume = {33},
year = {2016}
}
@article{bashroush2016-datacentreenergy,
abstract = {{\textcopyright} 1984-2012 IEEE. Given environmentalism's rising tide and increasing energy prices and IT workloads, architects must determine whether they can continue designing systems without considering energy and power efficiency.},
author = {Bashroush, R. and Woods, E. and Noureddine, A.},
doi = {10.1109/MS.2016.53},
issn = {07407459},
journal = {IEEE Software},
keywords = {energy efficiency,green computing,software architect,software architecture,software design,software development,software engineering},
number = {2},
pages = {18----21},
title = {{Data center energy demand: What got us here won't get us there}},
volume = {33},
year = {2016}
}
@article{Nakagawa2018,
author = {Nakagawa, E.Y. and Capilla, R. and Woods, E. and Kruchten, P.},
doi = {10.1016/j.jss.2018.02.044},
issn = {01641212},
journal = {Journal of Systems and Software},
title = {{Sustainability and longevity of systems and architectures}},
volume = {140},
year = {2018}
}
@article{Arnold1998,
abstract = {Operating a laser diode in an extended cavity which provides frequency-selective feedback is a very effective method of reducing the laser's linewidth and improving its tunability. We have developed an extremely simple laser of this type, built from inexpensive commercial components with only a few minor modifications. A 780{\~{}}nm laser built to this design has an output power of 80{\~{}}mW, a linewidth of 350{\~{}}kHz, and it has been continuously locked to a Doppler-free rubidium transition for several days.},
author = {Arnold, A S and Wilson, J S and Boshier, M G},
journal = {Review of Scientific Instruments},
month = {mar},
number = {3},
pages = {1236--1239},
title = {{A Simple Extended-Cavity Diode Laser}},
url = {http://link.aip.org/link/?RSI/69/1236/1},
volume = {69},
year = {1998}
}
@article{Hawthorn2001,
abstract = {We have developed an enhanced Littrow configuration extended cavity diode laser (ECDL) that can be tuned without changing the direction of the output beam. The output of a conventional Littrow ECDL is reflected from a plane mirror fixed parallel to the tuning diffraction grating. Using a free-space Michelson wavemeter to measure the laser wavelength, we can tune the laser over a range greater than 10 nm without any alteration of alignment.},
author = {Hawthorn, C J and Weber, K P and Scholten, R E},
journal = {Review of Scientific Instruments},
month = {dec},
number = {12},
pages = {4477--4479},
title = {{Littrow Configuration Tunable External Cavity Diode Laser with Fixed Direction Output Beam}},
url = {http://link.aip.org/link/?RSI/72/4477/1},
volume = {72},
year = {2001}
}
@article{Wieman1991,
abstract = {We present a review of the use of diode lasers in atomic physics with an extensive list of references. We discuss the relevant characteristics of diode lasers and explain how to purchase and use them. We also review the various techniques that have been used to control and narrow the spectral outputs of diode lasers. Finally we present a number of examples illustrating the use of diode lasers in atomic physics experiments. Review of Scientific Instruments is copyrighted by The American Institute of Physics.},
author = {Wieman, Carl E and Hollberg, Leo},
journal = {Review of Scientific Instruments},
keywords = {Diode Laser},
month = {jan},
number = {1},
pages = {1--20},
title = {{Using Diode Lasers for Atomic Physics}},
url = {http://link.aip.org/link/?RSI/62/1/1},
volume = {62},
year = {1991}
}
@incollection{Cuenot2010,
author = {Cuenot, Philippe and Frey, Patrick and Johansson, Rolf and L{\"{o}}nn, Henrik and Papadopoulos, Yiannis and Reiser, Mark-Oliver and Sandberg, Anders and Servat, David and Kolagari, Ramin Tavakoli and T{\"{o}}rngren, Martin and Others},
booktitle = {Model-Based Engineering of Embedded Real-Time Systems},
pages = {297--307},
publisher = {Springer},
title = {11 the east-adl architecture description language for automotive embedded software},
year = {2010}
}
@inproceedings{allen2002-rtsystems,
author = {Allen, Robert and Vestal, Steve and Cornhill, Dennis and Lewis, Bruce},
booktitle = {Proceedings of the third international workshop on Software and performance - WOSP 02},
doi = {10.1145/584395.584399},
publisher = {ACM Press},
title = {{Using an architecture description language for quantitative analysis of real-time systems}},
url = {https://doi.org/10.1145{\%}5C{\%}5C{\%}2F584395.584399},
year = {2002}
}
@inproceedings{lonn2004-east,
author = {Lonn, H},
booktitle = {"Software Engineering for Automotive Systems" Workshop W14S - 26th International Conference on Software Engineering},
doi = {10.1049/ic:20040338},
publisher = {IEE},
title = {{FAR EAST: modeling an automotive software architecture using the EAST ADL}},
url = {https://doi.org/10.1049{\%}2Fic{\%}3A20040338},
year = {2004}
}
@misc{sae2009-aadl,
author = {{SAE International}},
doi = {10.4271/as5506},
publisher = {SAE International},
title = {{Architecture Analysis {\&} Design Language (AADL)}},
url = {https://doi.org/10.4271{\%}2Fas5506},
year = {2009}
}
@article{Garlan2000,
author = {Garlan, David and Monroe, Robert T and Wile, David},
journal = {Foundations of component-based systems},
pages = {47--68},
title = {{Acme: Architectural description of component-based systems}},
volume = {68},
year = {2000}
}
@inproceedings{dunsire2005-abacus,
author = {Dunsire, K and ONeill, T and Denford, M and Leaney, J},
booktitle = {12th IEEE International Conference and Workshops on the Engineering of Computer-Based Systems (ECBS05)},
doi = {10.1109/ecbs.2005.66},
pages = {62--69},
publisher = {IEEE},
title = {{The ABACUS Architectural Approach to Computer-Based System and Enterprise Evolution}},
url = {https://doi.org/10.1109{\%}2Fecbs.2005.66},
year = {2005}
}
@article{shaw1996-unicon,
abstract = {The architecture of a software system shows how the system is realized by a collection of components together with the interactions among these components. Conventional design focuses the components, but the properties of the system depend critically on the character of the interactions. Although software designers have good informal abstractions for these interactions, these abstractions are poorly supported by the available languages and tools. As a result, the choice of interaction is often defaulted or made implicitly rather than deliberately chosen. Further, interactions are usually programmed in terms of underlying mechanisms rather than the designers' natural abstractions. UniCon supports a rich selection of abstractions for the connectors that mediate interactions among components. Connector implementation presents special challenges. The 'compiler' must produce and integrate not only the object code for components, but also a variety of other run-time products. The definition of a connector requires many connector-specific kinds of information in the compiler, graphical editor, and associated tools. Extending the set of connectors supported by UniCon requires this information to be provided by the connector designer and automatically integrated in the compiler. This paper describes the role of connector abstractions in software design, the connector abstractions currently supported by UniCon, and implementation issues associated with supporting an-open-ended collection of connectors.},
author = {Shaw, Mary and DeLine, Robert and Zelesnik, Gregory},
doi = {10.1109/CDS.1996.509340},
isbn = {0-8186-7395-8},
journal = {IEEE International Workshop on Configurable Distributed Systems -Proceedings},
keywords = {architectural abstraction,architecture description language,connectors,software architecture,software system organization,system configuration},
pages = {2--10},
publisher = {IEEE Comput. Soc. Press},
title = {{Abstractions and implementations for architectural connections}},
url = {https://doi.org/10.1109{\%}2Fcds.1996.509340},
year = {1996}
}
@article{allen1996-wright,
author = {Allen, Robert and Garlan, David},
journal = {Technical Report CMU-CS-96-TBD, Carnegie Mellon University, School of Computer Science},
publisher = {Citeseer},
title = {{The Wright architectural specification language}},
year = {1996}
}
@article{batory1997-genvoca,
abstract = {GenVoca generators synthesize software systems by composing components from reuse libraries. GenVoca components are designed to export and import standardized interfaces, and thus be plug-compatible, interchangeable, and interoperable with other components. We examine two different but important issues in software system synthesis. First, not all syntactically correct compositions of components are semantically correct. We present simple, efficient, and domain-independent algorithms for validating compositions of GenVoca components. Second, components that export and import immutable interfaces are too restrictive for software system synthesis. We show that the interfaces and bodies of GenVoca components are subjective, i.e., they mutate and enlarge upon instantiation. This mutability enables software systems with customized interfaces to be composed from components with “standardized” interfaces},
author = {Batory, Don and Geraci, Bart J},
doi = {10.1109/32.585497},
issn = {00985589},
journal = {IEEE Transactions on Software Engineering},
keywords = {Compositon validation,Design rule checking,Genvoca,Software generators,Subjectivity},
number = {2},
pages = {67--82},
publisher = {Institute of Electrical and Electronics Engineers (IEEE)},
title = {{Composition validation and subjectivity in genvoca generators}},
url = {https://doi.org/10.1109{\%}2F32.585497},
volume = {23},
year = {1997}
}
@inproceedings{khare2001-xadl,
abstract = {In order to support architecture-centric tool integration within the ArchStudio 2.0 Integrated Development Environment (IDE), we adopted Extensible Markup Language (XML) to represent the shared architecture-in-progress. Since ArchStudio is an architectural style-based development environment that incorporates an extensive number of tools, including commercial off-the-shelf products, we developed a new, vendor-neutral, ADL-neutral interchange format called Extensible Architecture description Language (xADL), as well as a "vocabulary" specific to the C2 style (xC2). This paper outlines our vision for representing architectures as hypertext, the design rationale behind xADL and xC2, and summarizes our engineering experience with this strategy.},
author = {Khare, R and Guntersdorfer, M and Oreizy, P and Medvidovic, N and Taylor, R.N.},
booktitle = {Proceedings of the 34th Annual Hawaii International Conference on System Sciences},
doi = {10.1109/HICSS.2001.927248},
isbn = {0-7695-0981-9},
issn = {10603425},
pages = {9},
publisher = {IEEE Comput. Soc},
title = {{xADL: enabling architecture-centric tool integration with XML}},
url = {https://doi.org/10.1109{\%}2Fhicss.2001.927248 http://ieeexplore.ieee.org/document/927248/},
year = {2001}
}
@incollection{Bashroush2009,
author = {Bashroush, R and Spence, I},
booktitle = {Information Systems Development},
doi = {10.1007/b137171_24},
pages = {227--237},
publisher = {Springer US},
title = {{An Extensible ADL for Service-Oriented Architectures}},
url = {https://doi.org/10.1007{\%}2Fb137171{\_}24},
year = {2009}
}
@inproceedings{lankhorst2009-archimate,
abstract = {In current business practice, an integrated approach to business and IT is indispensable. In many enterprises, however, such an integrated view of the entire enterprise is still far from reality. To deal with these challenges, an integrated view of the enterprise is needed, enabling impact/change analysis covering all relevant aspects. This need sparked the development of the ArchiMate language, which was developed with the explicit intention of becoming an open standard, and as such has been designed such that it is extendable while still maintaining a clear and orthogonal structure. This paper is concerned with documenting some of the key design decisions and design principles underlying the ArchiMate language. ArchiMate is designed as an architecture description language (ADL) for enterprise architectures. We will start by discussing the challenges facing the design of an architecture description language. Consequently we discuss the way how the design principles of the ArchiMate language aim to tackle these challenges. We then continue with a discussion of the modelling concepts needed. In this, we make a distinction between concepts needed to model domains in general, the modelling of dynamic systems, and the modelling of enterprise architectures.},
author = {Lankhorst, M M and Proper, H A and Jonkers, H},
booktitle = {Lecture Notes in Business Information Processing},
doi = {10.1007/978-3-642-01862-6_30},
isbn = {9783642018619},
issn = {18651348},
pages = {367--380},
publisher = {Springer Berlin Heidelberg},
title = {{The architecture of the ArchiMate language}},
url = {https://doi.org/10.1007{\%}2F978-3-642-01862-6{\_}30},
volume = {29 LNBIP},
year = {2009}
}
@article{smolander1991-metaedit,
abstract = {Existing CASE tools are often rigid and do not support the users'$\backslash$nnative methodologies. To alleviate this, more flexible and customisable$\backslash$ntools called CASE shells are emerging. However, the customisation$\backslash$nof those tools is still cumbersome and error-prone, and demands several$\backslash$nconfiguration files that follow a rigid syntax of some metamodelling$\backslash$nlanguage(s). In order to make the customisation easier, we propose$\backslash$na graphical metamodelling editor, MetaEdit, with which the conceptual$\backslash$nstructures of the user methodology can be modelled easily using an$\backslash$neasy-to-grasp graphical notation. With MetaEdit, methodology models$\backslash$ncan be constructed with less effort and the configuration files for$\backslash$nthe CASE shell can be created (semi)automatically. The tool is flexible$\backslash$ni.e. its symbols and metamodel are user-definable. In consequence$\backslash$nit can be used as a simple CASE shell. MetaEdit is based on the Object-Property-Role-Relationship$\backslash$n(OPRR) data model. The paper presents the principles on which the$\backslash$neditor is built, describes its operation, and discusses its relations$\backslash$nto other research on metamodelling.},
author = {Smolander, Karl and Lyydnen, Kalle and Tahvanalnen, Veli-Pekka and Marttiin, Pentti},
doi = {10.1007/3-540-54059-8_85},
isbn = {978-3-540-54059-5},
issn = {0302-9743},
journal = {Advanced Information Systems Engineering},
keywords = {1this research was ill,case-shells,computer aided software engineering,engineering,finland,metamodelling,methodology,part funded by the,technology development center of},
pages = {168--193},
publisher = {Springer Berlin Heidelberg},
title = {{MetaEdit - A Flexible Graphical Environment for Methodology Modelling 1}},
url = {https://doi.org/10.1007{\%}2F3-540-54059-8{\_}85},
year = {1991}
}
@article{moody2009-notations,
abstract = {Visual notations form an integral part of the language of software engineering (SE). Yet historically, SE researchers and notation designers have ignored or undervalued issues of visual representation. In evaluating and comparing notations, details of visual syntax are rarely discussed. In designing notations, the majority of effort is spent on semantics, with graphical conventions largely an afterthought. Typically, no design rationale, scientific or otherwise, is provided for visual representation choices. While SE has developed mature methods for evaluating and designing semantics, it lacks equivalent methods for visual syntax. This paper defines a set of principles for designing cognitively effective visual notations: ones that are optimized for human communication and problem solving. Together these form a design theory, called the Physics of Notations as it focuses on the physical (perceptual) properties of notations rather than their logical (semantic) properties. The principles were synthesized from theory and empirical evidence from a wide range of fields and rest on an explicit theory of how visual notations communicate. They can be used to evaluate, compare, and improve existing visual notations as well as to construct new ones. The paper identifies serious design flaws in some of the leading SE notations, together with practical suggestions for improving them. It also showcases some examples of visual notation design excellence from SE and other fields.},
author = {Moody, Daniel},
doi = {10.1109/TSE.2009.67},
isbn = {978-1-60558-719-6},
issn = {00985589},
journal = {IEEE Transactions on Software Engineering},
keywords = {Analysis,Communication,Concrete syntax,Diagrams,Modeling,Visual syntax,Visualization},
month = {nov},
number = {6},
pages = {756--779},
publisher = {Institute of Electrical and Electronics Engineers (IEEE)},
title = {{The physics of notations: Toward a scientific basis for constructing visual notations in software engineering}},
url = {https://doi.org/10.1109{\%}2Ftse.2009.67},
volume = {35},
year = {2009}
}
@inproceedings{pinto2001-daop,
abstract = {The increasing complexity in the development of distributed system has promoted the appearance of new software technologies that complements compositional framework technology providing a high degree of separation of concerns. One of these approaches is aspect-oriented programming that introduces a new entity, the aspect, to model those features that cut across different components in the system, increasing its extensibility and configurability. Our goal is the application of this new technology to develop an aspect-oriented application framework to construct highly reusable collaborative virtual environments in short time.},
author = {Pinto, M and Fuentes, L and Troya, J.M. and Fayad, M.E.},
booktitle = {Proceedings of the IEEE Computer Society Workshop on Future Trends of Distributed Computing Systems},
doi = {10.1109/ftdcs.2001.969615},
publisher = {IEEE Comput. Soc},
title = {{Towards an aspect-oriented framework in the design of collaborative virtual environments}},
url = {https://doi.org/10.1109{\%}2Fftdcs.2001.969615},
year = {2001}
}
@incollection{loques2004-crrio,
author = {Loques, Orlando and Sztajnberg, Alexandre},
booktitle = {Lecture Notes in Computer Science},
doi = {10.1007/978-3-540-24848-4_2},
pages = {18--34},
publisher = {Springer Berlin Heidelberg},
title = {{Customizing Component-Based Architectures by Contract}},
url = {https://doi.org/10.1007{\%}2F978-3-540-24848-4{\_}2},
year = {2004}
}
@techreport{feiler2000-realtime,
abstract = {This paper discusses a model-based architectural approach for improving predictability of performance in embedded real-time systems. This approach utilizes automated analysis of task and communication architectures to provide insight into schedulability and reliability during design. Automatic generation of a runtime executive that performs task dispatching and inter-task communication eliminates manual coding errors and results in a system that satisfies the specified execution behavior. The MetaH language and toolset supports this model-based approach. MetaH has been used by the U.S. Army in a pilot project applied to missile guidance systems. Reduced time and cost benefits that have been observed will be discussed as a case study. The paper closes by outlining the current state of commercial availability of such technology and efforts to develop standards, such as those put forth by the Society of Automotive Engineers (SAE); Avionics Systems Division (ASD); working group on Avionics Architecture Description Language (AADL); and the Object Management Group (OMG) Unified Modeling Language (UML) working group on real-time and performance support in UML.},
address = {Pittsburgh, Pennsylvania},
author = {Feiler, Peter H and Lewis, Bruce and Vestal, Steve},
doi = {10.21236/ada387086},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Feiler, Lewis, Vestal - 2000 - Improving Predictability in Embedded Real-Time Systems.pdf:pdf},
institution = {Software Engineering Institute, Carnegie Mellon University},
month = {dec},
number = {December},
pages = {CMU/SEI--2000--SR--011},
publisher = {Defense Technical Information Center},
title = {{Improving Predictability in Embedded Real-Time Systems}},
url = {https://doi.org/10.21236{\%}2Fada387086 http://www.sei.cmu.edu/library/abstracts/reports/00sr011.cfm},
year = {2000}
}
@article{Oquendo2004,
abstract = {A key aspect of the design of any software system is its architecture. An architecture description, from a runtime perspective, should provide a formal specification of the architecture in terms of components and connectors and how they are composed together. Further, a dynamic or mobile architecture description must provide a specification of how the architecture of the software system can change at runtime. Enabling specification of dynamic and mobile architectures is a large challenge for an Architecture Description Language (ADL). This article describes $\pi$-ADL, a novel ADL that has been designed in the ArchWare European Project to address specification of dynamic and mobile architectures. It is a formal, well-founded theoretically language based on the higher-order typed $\pi$-calculus. While most ADLs focus on describing software architectures from a structural viewpoint, $\pi$-ADL focuses on formally describing architectures encompassing both the structural and behavioural viewpoints. The $\pi$-ADL design principles, concepts and notation are presented. How $\pi$-ADL can be used for specifying static, dynamic and mobile architectures is illustrated through case studies. The $\pi$-ADL toolset is outlined.},
author = {Oquendo, Flavio},
doi = {10.1145/986710.986728},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Oquendo - 2004 - $\pi$-ADL an Architecture Description Language based on the higher-order typed $\pi$-calculus for specifying dynamic and mobi.pdf:pdf},
issn = {01635948},
journal = {ACM SIGSOFT Software Engineering Notes},
keywords = {an adl,architecture description languages,behaviours of,describe changing structures and,dynamic architectures,for describing dynamic and,languages,mobile architectures,must be able to,specification software architectures from,structural and behavioural viewpoints,$\pi$- indeed},
month = {may},
number = {3},
pages = {1--14},
publisher = {ACM},
title = {{$\pi$-ADL: an Architecture Description Language based on the higher-order typed $\pi$-calculus for specifying dynamic and mobile software architectures}},
url = {http://dl.acm.org/citation.cfm?id=986728 http://portal.acm.org/citation.cfm?doid=986710.986728},
volume = {29},
year = {2004}
}
@article{luckham1995-rapideexample,
abstract = {Rapide is an event-based concurrent object-oriented language specifically designed for prototyping system architectures. Two principle design goals are (1) to provide constructs for defning executable prototypes of architectures and (2) to adopt an execution model in which the concurrency synchronization dataflow and timing properties of a prototype are explicitly represented. This paper describes the partially ordered event set (poset) execution model and outlines with examples some of the event-based features for defining communication architectures and relationships between architectures. Various features of Rapide are illustrated by excerpts from a prototype of the X/Open distributed transaction processing reference architecture.},
author = {Luckham, DC C and Kenney, JJ J and Augustin, L.M. M and Vera, J. and Bryan, D. and Mann, W.},
doi = {10.1109/32.385971},
file = {:Users/eoin/Library/Application Support/Mendeley Desktop/Downloaded/Luckham et al. - 1995 - Specification and analysis of system architecture using Rapide.pdf:pdf},
issn = {00985589},
journal = {IEEE Transactions on Software Engineering},
keywords = {architecture,architecture definition languages,causality,concurrency,constraint-based specification,event patterns,formal constraints,partially ordered event sets,prototyping,rapide,simulation},
month = {apr},
number = {4},
pages = {336--354},
publisher = {Institute of Electrical and Electronics Engineers (IEEE)},
title = {{Specification and analysis of system architecture using Rapide}},
url = {https://doi.org/10.1109{\%}2F32.385971 http://ieeexplore.ieee.org/xpls/abs{\_}all.jsp?arnumber=385971 http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=385971},
volume = {21},
year = {1995}
}
@article{malavolta2013-industryadlneeds,
abstract = {Many times we are faced with the proliferation of definitions, concepts, languages and tools in certain (research) topics. But often there is a gap between what is provided by existing technologies, and what is needed by their users. The strengths, limitations and needs of the available technologies can be dubious. The same applies to software architectures, and specifically to languages designed to represent architectural models. Tens of different architectural languages have been introduced by the research and industrial communities in the last two decades. However, it is unclear if they fulfill the user's perceived needs in architectural description. As a way to plan for next generation languages for architectural description, this study analyzes practitioners' perceived strengths, limitations and needs associated to existing languages for software architecture modeling in industry.We run a survey by interviewing 48 practitioners from 40 different IT companies in 15 countries. Each participant is asked to fill in a questionnaire of 51 questions. By analyzing the data collected through this study, we have concluded that (a) whilst practitioners are generally satisfied with the design capabilities provided by the languages they use, they are dissatisfied with the architectural language analysis features and their abilities to define extra-functional properties; (b) architectural languages used in practice mostly originate from industrial development instead of from academic research; (c) more formality and better usability are required of an architectural language.},
author = {Malavolta, Ivano and Lago, Patricia and Muccini, Henry and Pelliccione, Patrizio and Tang, Antony},
doi = {10.1109/TSE.2012.74},
isbn = {0098-5589 VO - 39},
issn = {00985589},
journal = {IEEE Transactions on Software Engineering},
keywords = {ADL,Software architecture,architecture description languages,empirical study,survey},
number = {6},
pages = {869--891},
title = {{What industry needs from architectural languages: A survey}},
volume = {39},
year = {2013}
}
@misc{bashroush2006-flexibleadls,
abstract = {Architecture Description Languages (ADLs) have emerged in recent years as a tool for providing high-level descriptions of software systems in terms of their architectural elements and the relationships among them. Most of the current ADLs exhibit limitations which prevent their widespread use in industrial applications. In this paper, we discuss these limitations and introduce ALI, an ADL that has been developed to address such limitations. The ALI language provides a rich and flexible syntax for describing component interfaces, architectural patterns, and meta-information. Multiple graphical architectural views can then be derived from ALI's textual notation. Keywords: Software Architecture, Architecture Description Languages, Architectural Patterns.},
author = {Bashroush, Rabih and Spence, Ivor and Kilpatrick, Peter and Brown, John},
booktitle = {Software Architecture},
doi = {10.1007/11966104_16},
isbn = {978-3-540-69271-3},
keywords = {adl},
title = {{Towards More Flexible Architecture Description Languages for Industrial Applications}},
year = {2006}
}
@inproceedings{cuenot2010-east,
abstract = {Current trends in automotive embedded systems focus on how to manage the increasing software content, with a strong emphasis on standardization of the embedded software structure. The management of engineering information remains a critical challenge in order to support development and other stages of the life-cycle. System modelling based on an Architecture Description Language (ADL) is a way to keep these assets within one information structure. This paper presents the EAST-ADL2 modelling language, developed in the ITEA EAST-EEA project and further enhanced in the ATESST project (www.atesst.org). EAST-ADL2 supports comprehensive model-based development of embedded systems and provides dedicated constructs to facilitate variability and product line management, requirements engineering, representation of functional as well as software/hardware solutions, and timing and safety analysis.},
author = {Cuenot, Philippe and Frey, Patrick and Johansson, Rolf and L{\"{o}}nn, Henrik and Papadopoulos, Yiannis and Reiser, Mark Oliver and Sandberg, Anders and Servat, David and {Tavakoli Kolagari}, Ramin and T{\"{o}}rngren, Martin and Weber, Matthias},
booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
doi = {10.1007/978-3-642-16277-0_11},
isbn = {3642162762},
issn = {03029743},
title = {{The EAST-ADL architecture description language for automotive embedded software}},
year = {2010}
}
@book{shaw1996-softwarearch,
abstract = {Good software developers often adopt one or several architectural patterns as strategies for system organization. But, although they use these patterns purposefully, they often use them informally and nearly unconsciously. This book organizes this substantial emerging "folklore" of system design - with its rich language of system description - and closes the gap between the useful abstractions (constructs and patterns) of system design and the current models, notations and tools. It identifies useful patterns clearly, gives examples, compares them, and evaluates their utility in various settings - allowing readers to develop a repertoire of useful techniques that goes beyond the single-minded current fads. Examines the ways in which architectural issues can impact software design; shows how to design new systems in principled ways using well-understood architectural paradigms; emphasizes informal descriptions, touching lightly on formal notations and specifications, and the tools that support them; explains how to understand and evaluate the design of existing software systems from an architectural perspective; and presents concrete examples of actual system architectures that can serve as models for new designs. For professional software developers looking for new ideas about system organization.},
author = {Shaw, Mary and Garlan, David},
isbn = {0131829572},
issn = {02756617},
publisher = {Prentice Hall},
title = {{Software Architecture: Perspectives on an Emerging Discipline}},
year = {1996}
}
@inproceedings{diruscio2010-byadl,
abstract = {In order to deal with evolving needs and stakeholder concerns, next generation ADLs should support incremental extension and customization. In this direction we proposed byADL (Build Your ADL), a framework which allows software architects to (i) extend existent ADLs with domain specificities, new architectural views, or analysis aspects, (ii) integrate an ADL with development processes and methodologies, and (iii) customize an ADL. This paper presents the byADL tool and its features.},
author = {{Di Ruscio}, Davide and Malavolta, Ivano and Muccini, Henry and Pelliccione, Patrizio and Pierantonio, Alfonso},
booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
doi = {10.1007/978-3-642-15114-9_56},
isbn = {3642151132},
issn = {03029743},
title = {{ByADL: An MDE framework for building extensible architecture description languages}},
year = {2010}
}
@misc{evans2008-iotinfo,
author = {Evans, David},
booktitle = {Cisco Blogs},
title = {{The Internet of Things Infographic}},
url = {http://blogs.cisco.com/diversity/the-internet-of-things-infographic},
urldate = {2015-10-23},
year = {2008}
}
@misc{greengrid2015-dcmm,
author = {Singh, Harkeeret},
title = {{The Green Grid Data Centre Maturity Model}},
url = {https://www.thegreengrid.org/en/resources/library-and-tools/438-Data-Center-Maturity-Model},
year = {2015}
}
@misc{eurocommission2015-energyefficiency,
institution = {European Commission JRC Insitute for Energy and Transport},
title = {{The European Code of Conduct for Energy Efficiency in Data Centres}},
url = {http://iet.jrc.ec.europa.eu/energyefficiency/ict-codes-conduct/data- centres-energy-efficiency},
year = {2015}
}
@article{delforge2014-datacentreenergy,
abstract = {Data centers have become the backbone of the U.S. economy, powering businesses, communications, and online consumer services and helping make our society more productive and efficient. All of our online activity—including email, social media, and conducting business—is delivered through data centers. Ranging from small computer server rooms to mammoth “server farms,” these data centers house an estimated 12 million computer servers for data processing, data storage devices, and networking machines. Data centers also are among the nation's largest and fastest-growing population of consumers of electricity. In 2013 alone, nearly 3 million computer rooms used enough electricity to power all of the households in New York City for two years, equivalent to the annual output of 34 large coal-fired power plants. While the data center industry has made progress in cutting energy waste, an analysis by the Natural Resources Defense Council in partnership with Anthesis finds up to 30 percent of servers are “comatose” and no longer needed, other machines are grossly underutilized, and a number of strategic and tactical barriers still remain. This report recommends steps to accelerate the pace and scale of energy savings across the industry, including the use and public disclosure of energy efficiency metrics. If},
author = {Delforge, Pierre},
journal = {Natural Resources Defense Council (NRDC)},
title = {{America's Data Centers Are Wasting Huge Amounts of Energy}},
year = {2014}
}
@book{allen2015-gettingthingsdone,
author = {Allen, David},
isbn = {978-0349408941},
pages = {352},
publisher = {Piatkus},
title = {{Getting Things Done: The Art of Stress-free Productivity}},
year = {2015}
}
@misc{ebay2013-digitalefficiency,
author = {EBay},
booktitle = {EBay Tech Blog},
title = {{Digital Service Efficiency}},
url = {www.ebaytechblog.com/wp-content/uploads/2013/03/FINAL{\_}DSE-Solution-Paper.pdf},
urldate = {20180713},
year = {2013}
}
@inproceedings{poort2012-rcda,
abstract = {We propose to view architecting as a risk- and cost management discipline. This point of view helps architects identify the key concerns to address in their decision making, by providing a simple, relatively objective way to assess architectural significance. It also helps business stakeholders to align the architect's activities and results with their own goals. We examine the consequences of this point of view on the architecture process. The point of view is the basis of RCDA, the Risk- and Cost Driven Architecture approach. So far, more than 150 architects have received RCDA training. For a majority of the trainees, RCDA has a significant positive impact on their architecting work. {\textcopyright} 2012 Elsevier Inc. All rights reserved.},
author = {Poort, Eltjo R. and {Van Vliet}, Hans},
booktitle = {Journal of Systems and Software},
doi = {10.1016/j.jss.2012.03.071},
isbn = {0164-1212},
issn = {01641212},
keywords = {Cost management,Risk Management,Software architecture},
title = {{RCDA: Architecting as a risk- and cost management discipline}},
year = {2012}
}
@book{charmaz2006-groundedtheory,
abstract = {`Grounded theory is a highly influential way of working with qualitative data and Kathy Charmaz is a major player, both innovative and fluent. This book is a model student text: lively, carefully argued and full of vivid illustrations. Beginning students and professional researchers will find it to be required reading' - David Silverman, Professor Emeritus, Sociology Department, Goldsmiths College and Visiting Professor, Management Department, King's College, University of London Kathy Charmaz is one of the world's leading theorists and exponents of grounded theory. In this important and essential new textbook, she introduces the reader to the craft of using grounded theory in social research, and provides a clear, step-by-step guide for those new to the field.Using worked examples throughout, this book also maps out an alternative vision of grounded theory put forward by its founding thinkers, Glaser and Strauss. To Charmaz, grounded theory must move on from its positivist origins and must incorporate many of the methods and questions posed by constructivists over the past twenty years to become a more nuanced and reflexive practice.Essential reading for students, new researchers and seasoned social scientists alike, this book is one of those rare things, a textbook that is both accessible to those new to the field but also one that has important things to say about the nature of social enquiry itself.},
archivePrefix = {arXiv},
arxivId = {arXiv:1011.1669v3},
author = {Charmaz, Kathy},
booktitle = {Book},
doi = {10.1016/j.lisr.2007.11.003},
eprint = {arXiv:1011.1669v3},
isbn = {9780761973522},
issn = {07408188},
pages = {222},
pmid = {82},
publisher = {Sage},
title = {{Constructing grounded theory: a practical guide through qualitative analysis}},
year = {2006}
}
@book{rozanski2011-ssa2e,
author = {Rozanski, Nick and Woods, Eoin},
edition = {2},
isbn = {978-0321718334},
pages = {704},
publisher = {Addison Wesley},
title = {{Software Systems Architecture: working with stakeholders using viewpoints and perspectives}},
year = {2011}
}
@incollection{matt1994-threatstovalidity,
abstract = {10. Matt, G.E., Cook, T.D.: . eds) T, pp. 503-520. Russell Sage Foundation, New York. 503-520 (1994)},
address = {New York, New York, USA},
author = {Matt, Georg E. and Cook, Thomas D.},
booktitle = {The Handbook of Research Synthesis},
editor = {Cooper, H and Hedges, L.V.},
pages = {503--520},
publisher = {Russell Sage Foundation},
title = {{Threats to the validity of research synthesis}},
year = {1994}
}
@article{kruchten2008-architectsdo,
abstract = {To be successful, a software architect-or a software architecture team, collectively-must strike a delicate balance between an external focus-both outwards: Listening to customers, users, watching technology, developing a long-term vision, and inwards: driving the development teams-and an internal, reflective focus: spending time to make the right design choices, validating them, and documenting them. Teams that stray too far away from this metastable equilibrium fall into some traps that we describe as antipatterns of software architecture teams. {\textcopyright} 2008 Elsevier Inc. All rights reserved.},
author = {Kruchten, Philippe},
doi = {10.1016/j.jss.2008.08.025},
isbn = {0164-1212},
issn = {01641212},
journal = {Journal of Systems and Software},
keywords = {Antipattern,Software architect,Software architecture,Time-management},
number = {12},
pages = {2413--2416},
title = {{What do software architects really do?}},
volume = {81},
year = {2008}
}
@incollection{berander2005-reqpriorization,
abstract = {This chapter provides an overview of techniques for prioritization of requirements for software products. Prioritization is a crucial step towards making good decisions regarding product planning for single and multiple releases. Various aspects of functionality are considered, such as importance, risk, cost, etc. Prioritization decisions are made by stakeholders, including users, managers, developers, or their representatives. Methods are for combining individual prioritizations based on overall objectives and constraints. A range of different techniques and aspects are applied to an example to illustrate their use. Finally, limitations and shortcomings of current methods are pointed out, and open research questions in the area of requirements prioritization are discussed.},
author = {Berander, Patrik and Andrews, Anneliese},
booktitle = {Engineering and Managing Software Requirements},
doi = {10.1007/3-540-28244-0_4},
isbn = {9783540250432},
issn = {978-3-540-25043-2},
keywords = {Decision support,Requirements analysis,Requirements prioritization,Software product planning,Trade offs},
pages = {69--94},
publisher = {Springer Science and Business Media},
title = {{Requirements prioritization}},
year = {2005}
}
@book{bass2012-sainp,
archivePrefix = {arXiv},
arxivId = {arXiv:1011.1669v3},
author = {Bass, Len and Clements, Paul and Kazman, Rick},
doi = {10.1024/0301-1526.32.1.54},
edition = {3},
eprint = {arXiv:1011.1669v3},
isbn = {0321154959},
issn = {03008495},
pages = {640},
pmid = {21301655},
publisher = {Addison Wesley},
title = {{Software Architecture in Practice}},
year = {2012}
}
@misc{wikipedia-sitawareness,
author = {Wikipedia},
booktitle = {Wikipedia},
title = {{Situational Awareness}},
url = {https://en.wikipedia.org/wiki/Situation{\_}awareness},
urldate = {2018-06-23},
year = {2018}
}
@article{ozkaya2008-qualityproperties,
author = {Ozkaya, Ipek and Bass, Len and Sangwan, Raghvinder S and Nord, Robert L},
journal = {IEEE Software},
number = {25-33},
title = {{Making practical use of quality attribute information}},
volume = {25},
year = {2008}
}
@techreport{cisco2016-uksecprioritisation,
author = {Cisco},
institution = {Cisco Systems Inc},
pages = {11},
title = {{United Kingdom: Prioritising Security at Management and Board Levels}},
year = {2016}
}
@article{mills2013-digital-energyusage,
abstract = {The information economy is a blue‐whale economy with its energy uses mostly out of sight. Based on a mid‐range estimate, the world's Information‐Communications‐Technologies (ICT) ecosystem uses about 1,500 TWh of electricity annually, equal to all the electric generation of Japan and Germany combined ‐‐ as much electricity as was used for global illumination in 1985. The ICT ecosystem now approaches 10{\%} of world electricity generation. Or in other energy terms – the zettabyte era already uses about 50{\%} more energy than global aviation. Reduced to personal terms, although charging up a single tablet or smart phone requires a negligible amount of electricity, using either to watch an hour of video weekly consumes annually more electricity in the remote networks than two new refrigerators use in a year.1 And as the world continues to electrify, migrating towards one refrigerator per household, it also evolves towards several smartphones and equivalent per person. The growth in ICT energy demand will continue to be moderated by efficiency gains. But the historic rate of improvement in the efficiency of underlying ICT technologies started slowing around 2005, followed almost immediately by a new era of rapid growth in global data traffic, and in particular the emergence of wireless broadband for smartphones and tablets. The inherent nature of the mobile Internet, a key feature of the emergent Cloud architecture, requires far more energy than do wired networks. The remarkable and recent changes in technology mean that current estimates of global ICT energy use, most of which use pre‐iPhone era data, understate reality. Trends now promise faster, not slower, growth in ICT energy use. Future growth in electricity to power the global ICT ecosystem is anchored in just two variables, demand (how fast traffic grows), and supply (how fast technology efficiency improves): ? As costs keep plummeting, how fast do another billion people buy smartphones and join wireless broadband networks where they will use 1,000 times more data per person than they do today; how fast do another billion, or more, join the Internet at all; how fast do a trillion machines and devices join the Internet to fuel the information appetite of Big Data? ? Can engineers invent, and companies deploy, more efficient ICT hardware faster than data traffic grows? To estimate the amount of electricity used to fuel everything that produces, stores, transports, processes and displays zettabytes of data, one must account for the energy used by: ? Data centers that have become warehouse‐scale supercomputers unlike anything in history; ? Ubiquitous broadband wired and wireless communications networks; ? The myriad of end‐use devices from PCs to tablets and smart phones to digital TV, and, ? The manufacturing facilities producing all the ICT hardware. Hourly Internet traffic will soon exceed the annual traffic of the year 2000. And demand for data and bandwidth and the associated infrastructure are growing rapidly not just to enable new consumer products and video, but also to drive revolutions in everything from healthcare to cars, and from factories to farms. Historically, demand for bits has grown faster than the energy efficiency of using them. In order for worldwide ICT electric demand to merely double in a decade, unprecedented improvements in efficiency will be needed now. Electricity fuels the infrastructure of the world's ICT ecosystem ‐‐ the Internet, Big Data and the Cloud. Coal is the world's largest single current and future source of electricity. Hence the title of this paper.},
author = {{P. Mills}, Mark},
journal = {by Digital Power Group},
title = {{The cloud begins with coal: Big data, Big Networks, Big infrastructure, and Big power - An Overview of the Electricity use by the Global Digital Ecosystem}},
year = {2013}
}
@article{koomey2011-trends-energy-efficiency,
abstract = {Moore's},
author = {Koomey, Jonathan G. and Berard, Stephen and Sanchez, Marla and Wong, Henry},
doi = {10.1109/MAHC.2010.28},
isbn = {1058-6180},
issn = {10586180},
journal = {IEEE Annals of the History of Computing},
keywords = {Moore's law,computer performance,electrical efficiency,history of computing,mobile computing,power usage},
pmid = {5440129},
title = {{Implications of historical trends in the electrical efficiency of computing}},
year = {2011}
}
@inproceedings{islam2016-energysoftwarefeatures,
abstract = {With the proliferation of Software systems and the rise of paradigms such the Internet of Things, Cyber-Physical Systems and Smart Cities to name a few, the energy consumed by software applications is emerging as a major concern. Hence, it has become vital that software engineers have a better understanding of the energy consumed by the code they write. At software level, work so far has focused on measuring the energy consumption at function and application level. In this paper, we propose a novel approach to measure energy consumption at a feature level, cross-cutting multiple functions, classes and systems. We argue the importance of such measurement and the new insight it provides to non-traditional stakeholders such as service providers. We then demonstrate, using an experiment, how the measurement can be done with a combination of tools, namely our program slicing tool (PORBS) and energy measurement tool (Jolinar).},
author = {Islam, Syed and Noureddine, Adel and Bashroush, Rabih},
booktitle = {IEEE International Conference on Program Comprehension},
doi = {10.1109/ICPC.2016.7503726},
isbn = {9781509014286},
title = {{Measuring energy footprint of software features}},
year = {2016}
}
@article{achimugu2014-reqprio-litreview,
abstract = {During requirements engineering, prioritization is performed to grade or rank requirements in their order of importance and subsequent implementation releases. It is a major step taken in making crucial decisions so as to increase the economic value of a system.$\backslash$nObjective$\backslash$nThe purpose of this study is to identify and analyze existing prioritization techniques in the context of the formulated research questions.$\backslash$nMethod$\backslash$nSearch terms with relevant keywords were used to identify primary studies that relate requirements prioritization classified under journal articles, conference papers, workshops, symposiums, book chapters and IEEE bulletins.$\backslash$nResults$\backslash$n73 Primary studies were selected from the search processes. Out of these studies; 13 were journal articles, 35 were conference papers and 8 were workshop papers. Furthermore, contributions from symposiums as well as IEEE bulletins were 2 each while the total number of book chapters amounted to 13.$\backslash$nConclusion$\backslash$nPrioritization has been significantly discussed in the requirements engineering domain. However, it was generally discovered that, existing prioritization techniques suffer from a number of limitations which includes: lack of scalability, methods of dealing with rank updates during requirements evolution, coordination among stakeholders and requirements dependency issues. Also, the applicability of existing techniques in complex and real setting has not been reported yet.},
author = {Achimugu, Philip and Selamat, Ali and Ibrahim, Roliana and Mahrin, Mohd Naz'ri},
doi = {10.1016/j.infsof.2014.02.001},
isbn = {0950-5849},
issn = {0950-5849},
journal = {Information and Software Technology},
number = {6},
pages = {568--585},
title = {{A systematic literature review of software requirements prioritization research}},
volume = {56},
year = {2014}
}
@inproceedings{hermann2008-reqprioritization,
abstract = {In early phases of the software cycle, requirements prioritization necessarily relies on the specified requirements and on predictions of benefit and cost of individual requirements. This paper presents results of a systematic review of literature, which investigates how existing methods approach the problem of requirements prioritization based on benefit and cost. From this review, it derives a set of under-researched issues which warrant future efforts and sketches an agenda for future research in this area.},
author = {Herrmann, A and Daneva, M},
booktitle = {Proc. 16th IEEE Int'l Conf. Requirements Eng.},
doi = {10.1109/RE.2008.48},
isbn = {0-7695-1980-6},
issn = {1089-6503},
keywords = {requirements prioritization,software},
pages = {125--134},
title = {{Requirements Prioritization Based on Benefit and Cost Prediction: An Agenda for Future Research}},
year = {2008}
}
@book{lapan2012-qualitativeresearch,
abstract = {Lapan, S., Quartaroli, ML, Riemer, F. (2012) “Introduction to Qualitative Research”},
author = {Lapan, Stephen and Quartaroli, MaryLynn and Riemer, Frances},
booktitle = {Qualitative research in practice: Examples for {\ldots}},
isbn = {978-0470548004},
pages = {560},
publisher = {John Wiley and Sons},
title = {{Qualitative research: An introduction to methods and designs.}},
year = {2012}
}
@book{koch1998-8020principle,
author = {Koch, Richard},
isbn = {978-0385491709},
pages = {277},
publisher = {Bantam Doubleday Dell Publishing Group},
title = {{The 80/20 principle: the secret to achieving more with less.}},
year = {1998}
}
@inproceedings{woods2017-archpriorisation,
author = {Woods, Eoin and Bashroush, Rabih},
booktitle = {European Conference on Software Architecture},
pages = {183--190},
publisher = {Springer},
title = {{A Model for Prioritization of Software Architecture Effort}},
year = {2017}
}
@misc{uptime2015-tierclassification,
author = {Institute, Uptime},
title = {{Tier Classification System}},
url = {http://uptimeinstitute.com/tiers},
urldate = {2018-07-13},
year = {2015}
}
@misc{shapiro2015-datacentre-mythsrealities,
author = {Shapiro, Steven},
title = {{Myths and Realities About Designing High Availability Data Centers}},
url = {http://blog.morrisonhershfield.com/myths-realities-designing-high-availability-data-centers/},
year = {2015}
}
@techreport{josey2004-ieee1003,
author = {Josey, Andrew and Cragun, Donald and Stoughton, Nicholas and Brown, Mark and Hughes, Cathy},
institution = {The IEEE and The Open Group},
title = {{The Open Group base specifications issue 6 IEEE Standard 1003.1}},
url = {http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/contents.html},
year = {2004}
}
@misc{unix_sar_command,
author = {Godard and Sebastien},
booktitle = {Unix man pages},
title = {{Unix sar(1) command manual page}},
url = {https://linux.die.net/man/1/sar},
urldate = {2018-07-16},
year = {2018}
}
@misc{windows_performance_monitor,
author = {Morrison, Blake},
booktitle = {Ask the Performance Team Blog},
title = {{Windows Performance Monitor Overview}},
url = {https://blogs.technet.microsoft.com/askperf/2014/07/17/windows-performance-monitor-overview/},
year = {2014}
}
@misc{hitachi_drive_data_sheet,
author = {Hitachi},
title = {{Hitachi Ultrastar C10K1800 Hard Drive Data Sheet}},
url = {https://www.hgst.com/sites/default/files/resources/USC10K1800{\_}ds.pdf},
year = {2015}
}
@article{bashroush2018_hardwarerefresh,
author = {Bashroush, R},
doi = {10.1109/TSUSC.2018.2795465},
journal = {IEEE Transactions on Sustainable Computing},
keywords = {Cognition,Data centres,Energy consumption,Hardware,Market research,Mathematical model,Servers,energy efficiency,environmental impact,hardware refresh rate},
pages = {1},
title = {{A Comprehensive Reasoning Framework for Hardware Refresh in Data Centres}},
year = {2018}
}
@techreport{dc4cities2014_dcmetrics,
author = {ENEA},
institution = {DC4Cities Project},
pages = {77},
title = {{Description of Energy Metrics for Data Centres D7.1}},
url = {www.dc4cities.eu/en/?smd {\_}process{\_}download=1{\&}download {\_}id=3430},
year = {2014}
}
@misc{wikipedia_microservices,
booktitle = {Wikipedia},
title = {{Wikipedia - Microservices}},
url = {https://en.wikipedia.org/wiki/Microservices},
year = {2018}
}
@misc{richardson2018_microservices,
author = {Richardson, Chris},
booktitle = {microservices.io},
title = {{Pattern: Microservice Architecture}},
url = {http://microservices.io/patterns/microservices.html},
year = {2018}
}
@inproceedings{mazlami2017_microservices_monoliths,
author = {Mazlami, G and Cito, J and Leitner, P},
booktitle = {2017 IEEE International Conference on Web Services (ICWS)},
doi = {10.1109/ICWS.2017.61},
keywords = {Cloud computing,Clustering algorithms,Computer architecture,Couplings,DevOps,Industries,Tools,Web services,Web-based prototype,algorithmic recommendation,cloud computing,cloud computing infrastructure,coupling,domain-specific redundancy,elastic computing,extraction,formal models,graph-based clustering,informal migration patterns,microservice architectural style,microservice candidates,microservice extraction model,microservice-oriented architectures,microservice-specific metrics,microservices,mobile computing,monolithic code bases,monolithic legacy applications,monolithic software architectures,performance evaluation,service-oriented architecture},
month = {jun},
pages = {524--531},
title = {{Extraction of Microservices from Monolithic Software Architectures}},
year = {2017}
}
@misc{openapi2018,
keywords = {v3.0.1},
mendeley-tags = {v3.0.1},
title = {{OpenAPI Specification}},
url = {https://swagger.io/specification/},
year = {2018}
}
@misc{raml2018,
title = {{RESTful API Modeling Language}},
url = {https://github.com/raml-org/raml-spec},
year = {2018}
}
@article{lange2009-specpower,
abstract = {To drive energy efficiency initiatives, SPEC established SPECpower{\_}ssj2008, the first industry-standard benchmark for measuring power and performance characteristics of computer systems.},
author = {Lange, Klaus Dieter},
doi = {10.1109/MC.2009.84},
isbn = {0018-9162 VO - 42},
issn = {00189162},
journal = {Computer},
keywords = {Benchmark testing,Benchmarks,Computers,Energy efficiency,Green IT,Industries,Power measurement,SPECpower{\_}ssj2008,Servers,Temperature sensors},
number = {3},
pages = {92----97},
title = {{Identifying shades of green: The SPECpower benchmarks}},
volume = {42},
year = {2009}
}
@book{newman2015_microservices,
abstract = {Distributed systems have become more fine-grained in the past 10 years, shifting from code-heavy monolithic applications to smaller, self-contained microservices. But developing these systems brings its own set of headaches. With lots of examples and practical advice, this book takes a holistic view of the topics that system architects and administrators must consider when building, managing, and evolving microservice architectures.Microservice technologies are moving quickly. Author Sam Newman provides you with a firm grounding in the concepts while diving into current solutions for modeling, integrating, testing, deploying, and monitoring your own autonomous services. You'll follow a fictional company throughout the book to learn how building a microservice architecture affects a single domain.Discover how microservices allow you to align your system design with your organization's goalsLearn options for integrating a service with the rest of your systemTake an incremental approach when splitting monolithic codebasesDeploy individual microservices through continuous integrationExamine the complexities of testing and monitoring distributed servicesManage security with user-to-service and service-to-service modelsUnderstand the challenges of scaling microservice architectures},
archivePrefix = {arXiv},
arxivId = {1606.04036},
author = {Newman, Sam},
booktitle = {O'Reilly},
doi = {10.1109/MS.2016.64},
eprint = {1606.04036},
isbn = {978-1-491-95035-7},
issn = {07407459},
keywords = {www.it-ebooks.info},
pmid = {15003161},
publisher = {O'Reilly},
title = {{Building Microservices: designing fine-grained systems}},
year = {2015}
}
@article{noureddine2016-jolinar,
abstract = {Monitoring energy consumption of applications is crucial for energy optimisation and improvements in software systems. With the recent emphasis on energy efficiency, it is vital that software engineers have an understanding of the energy consumed by the code they write. In this paper, we present Jolinar, a tool that bridges the gap between energy mea-surements and accessibility to software engineers and even end-users. The tool builds on top of recent energy models to provide an accurate, light and easy-to-use interface for en-ergy measurements. The target audience of Jolinar is both software engineers and non-technical end-users who want to monitor their applications' energy footprint. We show that end-users can use Jolinar's GUI to determine the energy consumed by the software they are using, and software en-gineers can use the tool to analyse energy consumption of systems to make energy-conscious decisions.},
author = {Noureddine, Adel and Islam, Syed and Bashroush, Rabih},
doi = {10.1145/2931037.2948706},
isbn = {9781450343909},
journal = {Proceedings of the 25th International Symposium on Software Testing and Analysis - ISSTA 2016},
keywords = {energy footprint,program analysis},
title = {{Jolinar: analysing the energy footprint of software applications}},
year = {2016}
}
@book{evans2006_ddd,
abstract = {The most complicated aspect of large software projects is not the implementation, it is the real world domain that the software serves. Domain Driven Design is a vision and approach for dealing with highly complex domains that is based on making the domain itself the main focus of the project, and maintaining a software model that reflects a deep understanding of the domain. The vision was brought to the world by Eric Evans in his book "Domain Driven Design". Eric's work was based on 20 years of widely accepted best practices in the object community, as well as Eric's own insights. Domain Driven Design Quickly is a short, quick-readable summary and introduction to the fundamentals of DDD. A special interview with Eric Evans on the state of Domain Driven Design is also included.},
archivePrefix = {arXiv},
arxivId = {arXiv:1011.1669v3},
author = {Evans, Eric},
doi = {978-1-4116-0925-9},
eprint = {arXiv:1011.1669v3},
isbn = {1411609255},
issn = {00155713},
pmid = {12566760},
publisher = {Addison Wesley},
title = {{Domain Driven Design}},
year = {2006}
}
